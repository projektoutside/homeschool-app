<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Geometry Polygon Playground</title>
    <style>
        /* CSS Custom Properties for Responsive Design System */
        :root {
            /* Base font size - scales with viewport */
            --base-font-size: clamp(12px, 1.5vw, 16px);
            --font-scale: 1;

            /* Spacing system - relative units */
            --spacing-xs: clamp(4px, 0.5vw, 6px);
            --spacing-sm: clamp(6px, 0.75vw, 8px);
            --spacing-md: clamp(8px, 1vw, 12px);
            --spacing-lg: clamp(12px, 1.5vw, 16px);
            --spacing-xl: clamp(16px, 2vw, 24px);
            --spacing-2xl: clamp(20px, 2.5vw, 32px);

            /* Touch target sizes - minimum 44px for accessibility */
            --touch-target-min: 44px;
            --touch-target-sm: clamp(36px, 4.5vw, 44px);
            --touch-target-md: clamp(44px, 5.5vw, 56px);
            --touch-target-lg: clamp(48px, 6vw, 64px);

            /* Sidebar widths - responsive */
            --sidebar-width-mobile: 0;
            --sidebar-width-tablet: clamp(200px, 25vw, 280px);
            --sidebar-width-desktop: clamp(240px, 20vw, 320px);

            /* Border radius - scales with size */
            --radius-sm: clamp(4px, 0.5vw, 6px);
            --radius-md: clamp(6px, 0.75vw, 8px);
            --radius-lg: clamp(8px, 1vw, 12px);
            --radius-xl: clamp(12px, 1.5vw, 16px);

            /* Colors */
            --color-primary: #667eea;
            --color-primary-dark: #764ba2;
            --color-bg: rgba(255, 255, 255, 0.95);
            --color-border: #e0e0e0;

            /* Z-index layers */
            --z-toolbar: 1000;
            --z-menu: 1100;
            --z-overlay: 2000;

            /* Device type flags (set by JS) */
            --is-mobile: 0;
            --is-tablet: 0;
            --is-desktop: 1;
            --is-touch: 0;
            --is-portrait: 0;
            --is-landscape: 1;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            font-size: var(--base-font-size);
            -webkit-text-size-adjust: 100%;
            -moz-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
            text-size-adjust: 100%;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            display: flex;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            /* Dynamic viewport height for mobile */
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-size: var(--base-font-size);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            touch-action: manipulation;
            /* Prevent double-tap zoom on buttons */
        }

        /* Learn Geometry Full Page */
        #learnPage {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            background: #f8fafc;
            z-index: 3000;
            display: none;
            flex-direction: column;
            overflow-y: auto;
        }

        #learnPage.active {
            display: flex;
        }

        .learn-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: clamp(16px, 2vw, 20px) clamp(24px, 4vw, 40px);
            color: white;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .learn-header h1 {
            font-size: clamp(20px, 2.5vw, 24px);
            font-weight: 600;
            margin: 0;
        }

        .close-learn-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 8px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .close-learn-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        .learn-content-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 24px;
            padding: clamp(20px, 4vw, 40px);
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
        }

        .learn-card {
            background: white;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            border: 1px solid #e2e8f0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .learn-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(to bottom, #667eea, #764ba2);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .learn-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 24px rgba(102, 126, 234, 0.15);
            border-color: transparent;
        }

        .learn-card:hover::before {
            opacity: 1;
        }

        .learn-card-title {
            color: #2d3748;
            font-weight: 700;
            font-size: 18px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .learn-card-icon {
            font-size: 24px;
            background: #f0f4ff;
            width: 40px;
            height: 40px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #667eea;
        }

        .learn-card-desc {
            color: #718096;
            line-height: 1.6;
            font-size: 15px;
        }

        /* Main Layout - Fully Responsive */
        .app-container {
            display: flex;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            max-width: 100%;
            max-height: none;
            background: white;
            /* White background to match toolbar areas */
            border-radius: 0;
            margin: 0;
            overflow: hidden;
            box-shadow: none;
            flex-direction: row;
            position: relative;
        }

        /* Main Body Row - Ensure white background in top area */
        .main-body-row {
            background: white;
            /* White background to prevent gray sections above sidebars */
        }

        /* Mobile: Stack vertically */
        @media (max-width: 768px) {
            .app-container {
                flex-direction: column;
                height: 100vh;
                height: 100dvh;
                margin: 0;
            }
        }

        /* Landscape mobile */
        @media (max-width: 768px) and (orientation: landscape) {
            .app-container {
                height: 100vh;
                height: 100dvh;
                margin: 0;
            }
        }

        /* Tablet adjustments */
        @media (min-width: 769px) and (max-width: 1024px) {
            .app-container {
                margin: 0;
            }
        }

        /* Panel Resizing - Responsive */
        .resizable-panel {
            display: flex;
            flex-direction: column;
            height: 100%;
            min-height: 0;
            flex-shrink: 0;
        }

        .resizable-panel-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            min-height: 0;
            -webkit-overflow-scrolling: touch;
        }

        /* Divider - Touch-friendly on mobile */
        .panel-divider {
            height: clamp(8px, 1vw, 12px);
            min-height: var(--touch-target-sm);
            background: var(--color-border);
            cursor: row-resize;
            position: relative;
            transition: background 0.2s;
            -webkit-user-select: none;
            user-select: none;
            touch-action: none;
            flex-shrink: 0;
        }

        /* Mobile: Larger touch target for divider */
        @media (max-width: 768px) {
            .panel-divider {
                min-height: var(--touch-target-min);
            }
        }

        .panel-divider:hover {
            background: #94a3b8;
        }

        .panel-divider::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 2px;
            background: #94a3b8;
            border-radius: 1px;
        }

        /* Panel Header with Drag Handle - Responsive */
        .panel-header {
            padding: var(--spacing-md) var(--spacing-lg);
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-dark) 100%);
            color: white;
            font-weight: 600;
            font-size: clamp(13px, 1.75vw, 16px);
            cursor: pointer;
            -webkit-user-select: none;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: var(--touch-target-min);
            flex-shrink: 0;
            position: relative;
        }

        /* Panel header layout with back button */
        .panel-header {
            position: relative;
        }

        .panel-header .panel-back-btn {
            position: absolute;
            left: var(--spacing-md);
            top: 50%;
            transform: translateY(-50%);
            z-index: 10;
        }

        /* Adjust header content when back button exists */
        .panel-header .panel-back-btn+span,
        .panel-header .panel-back-btn~span {
            margin-left: 60px;
            /* Offset for back button on left */
        }

        .panel-header.dragging {
            opacity: 0.7;
            background: linear-gradient(135deg, #4a6de5 0%, #5a52a3 100%);
        }

        .panel-header.dragging .drag-handle {
            color: white;
        }

        /* Back Button for Mobile Panels */
        .panel-back-btn {
            display: none;
            /* Hidden on desktop */
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 8px;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.2s ease;
            align-items: center;
            justify-content: center;
            min-height: var(--touch-target-min);
            min-width: var(--touch-target-min);
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        /* Show back button on mobile/tablet and style it */
        @media (max-width: 1024px) {
            .panel-back-btn {
                display: flex;
            }
        }

        .panel-back-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateX(-2px);
        }

        .panel-back-btn:active {
            transform: translateX(-2px) scale(0.95);
        }

        .panel-back-btn svg {
            width: 18px;
            height: 18px;
            stroke-width: 2.5;
        }

        /* Back button visibility is handled above */

        /* Toolbar - Compact Top Bar for All Devices */
        .toolbar {
            position: fixed;
            top: clamp(56px, 7vw, 66px);
            /* Pushed down by top tools bar with additional gap */
            left: 0;
            right: 0;
            width: 100%;
            background: white;
            border-bottom: 1px solid var(--color-border);
            padding: clamp(8px, 1.5vw, 12px);
            /* Increased padding */
            display: flex;
            gap: clamp(8px, 2vw, 12px);
            /* Increased gap significantly */
            z-index: var(--z-toolbar);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            align-items: center;
            justify-content: center;
            flex-wrap: nowrap;
            overflow-x: auto;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
            scrollbar-color: rgba(0, 0, 0, 0.2) transparent;
            min-height: clamp(48px, 6vw, 56px);
            /* Increased height */
            max-height: clamp(60px, 8vw, 70px);
            box-sizing: border-box;
        }

        /* Ensure toolbar buttons fit on small screens */
        @media (max-width: 320px) {
            .toolbar {
                padding: 8px;
                gap: 6px;
            }

            .tool-btn {
                width: 36px;
                min-width: 36px;
                height: 36px;
                min-height: 36px;
                font-size: 16px;
            }
        }

        .toolbar::-webkit-scrollbar {
            height: 4px;
        }

        .toolbar::-webkit-scrollbar-track {
            background: transparent;
        }

        .toolbar::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 2px;
        }

        .toolbar::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.3);
        }

        .tool-btn {
            width: clamp(40px, 5vw, 48px);
            /* Larger touch target */
            min-width: clamp(40px, 5vw, 48px);
            height: clamp(40px, 5vw, 48px);
            min-height: clamp(40px, 5vw, 48px);
            border: none;
            background: #f0f0f0;
            border-radius: var(--radius-md);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(18px, 2.5vw, 22px);
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            flex-shrink: 0;
            touch-action: manipulation;
            padding: 0;
            margin: 0;
        }

        .tool-btn.combine-btn,
        .tool-btn.split-btn {
            width: auto;
            padding: 0 16px;
            font-size: 14px;
            font-weight: 600;
        }

        .tool-btn:hover {
            background: #e0e0e0;
            transform: scale(1.05);
        }

        .tool-btn:active {
            transform: scale(0.95);
        }

        .tool-btn.active {
            background: var(--color-primary);
            color: white;
            box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3);
        }

        .tool-btn::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 4px 8px;
            border-radius: var(--radius-sm);
            font-size: clamp(10px, 1.25vw, 12px);
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: calc(var(--z-toolbar) + 1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .tool-btn:hover::after {
            opacity: 1;
        }

        /* Mobile: Smaller tooltips */
        @media (max-width: 768px) {
            .tool-btn::after {
                display: none;
                /* Hide tooltips on mobile to save space */
            }
        }

        /* Sidebar Panels - Responsive Widths */
        .sidebar {
            width: var(--sidebar-width-desktop);
            min-width: 0;
            max-width: 100%;
            background: white;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--color-border);
            overflow-y: auto;
            overflow-x: hidden;
            min-height: 0;
            flex-shrink: 0;
            transition: transform 0.3s ease, width 0.3s ease, position 0.3s ease;
            /* Ensure sidebars are visible by default */
            visibility: visible;
            opacity: 1;
        }

        .sidebar-right {
            border-right: none;
            border-left: 1px solid var(--color-border);
        }

        /* Mobile: Sidebars become overlays */
        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                /* Start below toolbar - top tools bar + toolbar height */
                top: clamp(96px, 12vw, 126px);
                left: 0;
                width: min(85vw, 320px);
                /* Height adjusted to account for top offset */
                height: calc(100vh - clamp(96px, 12vw, 126px));
                height: calc(100dvh - clamp(96px, 12vw, 126px));
                z-index: var(--z-menu);
                transform: translateX(-100%);
                box-shadow: 2px 0 8px rgba(0, 0, 0, 0.15);
            }

            .sidebar.sidebar-right {
                left: auto;
                right: 0;
                transform: translateX(100%);
                border-left: none;
                border-right: 1px solid var(--color-border);
            }

            .sidebar.mobile-open {
                transform: translateX(0);
            }

            .sidebar-right.mobile-open {
                transform: translateX(0);
            }
        }

        /* Tablet: Sidebars visible by default (like desktop), but can be toggled to overlay */
        @media (min-width: 769px) and (max-width: 1024px) {
            .sidebar {
                /* On tablets, sidebars are visible by default like desktop */
                width: var(--sidebar-width-tablet);
                position: relative !important;
                transform: none !important;
                box-shadow: none;
                /* Push sidebars down below toolbar - top-tools-bar + toolbar height */
                /* Top tools bar: clamp(48px, 6vw, 56px) + Toolbar: clamp(48px, 6vw, 56px) to clamp(60px, 8vw, 70px) */
                margin-top: clamp(96px, 12vw, 126px);
                /* Constrain height to fill remaining viewport below toolbar */
                height: calc(100vh - clamp(96px, 12vw, 126px));
                height: calc(100dvh - clamp(96px, 12vw, 126px));
                max-height: calc(100vh - clamp(96px, 12vw, 126px));
                max-height: calc(100dvh - clamp(96px, 12vw, 126px));
                top: auto;
                left: auto;
                right: auto;
                z-index: auto;
                /* Ensure visibility */
                visibility: visible !important;
                opacity: 1 !important;
                display: flex !important;
                /* Align to start of flex container */
                align-self: flex-start;
            }

            /* When toggled to overlay mode on tablet (mobile-open class) */
            .sidebar.mobile-open {
                position: fixed !important;
                top: clamp(96px, 12vw, 126px) !important;
                left: 0;
                width: min(70vw, 400px);
                height: calc(100vh - clamp(96px, 12vw, 126px));
                height: calc(100dvh - clamp(96px, 12vw, 126px));
                z-index: var(--z-menu);
                transform: translateX(0) !important;
                box-shadow: 2px 0 8px rgba(0, 0, 0, 0.15);
                /* Reset margin when in overlay mode */
                margin-top: 0 !important;
                align-self: auto;
            }

            .sidebar.sidebar-right.mobile-open {
                left: auto;
                right: 0;
                transform: translateX(0) !important;
                border-left: none;
                border-right: 1px solid var(--color-border);
                /* Reset margin when in overlay mode */
                margin-top: 0 !important;
                align-self: auto;
            }
        }

        .panel {
            border-bottom: 1px solid #e0e0e0;
            flex: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            padding: 12px 16px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            -webkit-user-select: none;
            user-select: none;
            /* For Safari compatibility */
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-content {
            padding: var(--spacing-md);
            overflow-y: auto;
            overflow-x: hidden;
            flex: 1;
            min-height: 0;
            -webkit-overflow-scrolling: touch;
        }

        /* Canvas Area - Fully Responsive */
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #fafafa;
            min-width: 0;
            min-height: 0;
            width: 100%;
            height: 100%;
        }

        /* Mobile: Canvas takes full height minus toolbar */
        @media (max-width: 768px) {
            .canvas-container {
                flex: 1 1 auto;
                min-height: 0;
                order: -1;
                /* Canvas appears first on mobile */
            }
        }

        #mainCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            touch-action: none;
            /* Prevent default touch behaviors */
        }

        /* Zoom Controls - Responsive Positioning */
        .zoom-controls {
            position: absolute;
            bottom: clamp(12px, 2vw, 20px);
            right: clamp(12px, 2vw, 20px);
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
            z-index: calc(var(--z-toolbar) - 1);
        }

        /* Mobile: Adjust position to avoid toolbar */
        @media (max-width: 768px) {
            .zoom-controls {
                bottom: clamp(80px, 12vw, 100px);
                right: var(--spacing-md);
            }
        }

        .zoom-btn {
            width: var(--touch-target-md);
            min-width: var(--touch-target-min);
            height: var(--touch-target-md);
            min-height: var(--touch-target-min);
            border: none;
            background: white;
            border-radius: var(--radius-md);
            cursor: pointer;
            box-shadow: 0 clamp(2px, 0.5vw, 4px) clamp(6px, 1vw, 8px) rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(16px, 2vw, 20px);
            transition: all 0.2s;
            touch-action: manipulation;
        }

        .zoom-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .zoom-btn:active {
            transform: scale(0.95);
        }

        /* Fullscreen button in top tools bar */
        .fullscreen-top-btn {
            background: white;
            border: 1px solid var(--color-border);
            padding: 8px 14px;
            border-radius: 10px;
            font-size: 20px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            min-width: 44px;
            height: 36px;
            color: #4a5568;
        }

        .fullscreen-top-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            background: #f7fafc;
            border-color: var(--color-primary);
        }

        .fullscreen-top-btn:active {
            transform: translateY(0);
        }

        .fullscreen-top-btn.active {
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-dark) 100%);
            color: white;
            border-color: var(--color-primary);
            box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3);
        }

        .fullscreen-top-btn.active:hover {
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.4);
        }

        /* Fullscreen styles */
        :fullscreen,
        :-webkit-full-screen,
        :-moz-full-screen,
        :-ms-fullscreen {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        body:fullscreen,
        body:-webkit-full-screen,
        body:-moz-full-screen,
        body:-ms-fullscreen {
            display: flex;
            width: 100%;
            height: 100%;
        }

        .fullscreen-active .canvas-container {
            height: 100vh;
            width: 100vw;
        }

        .fullscreen-active .app-container {
            width: 100vw;
            height: 100vh;
        }

        /* Properties Display - Responsive */
        .property-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 8px;
            font-size: clamp(12px, 1.4vw, 14px);
            gap: 12px;
            min-height: 28px;
            align-items: center;
            border-radius: 4px;
            transition: background-color 0.15s ease;
        }

        .property-row:hover {
            background-color: #f8f9fa;
        }

        .property-label {
            color: #64748b;
            flex-shrink: 0;
            font-weight: 500;
            font-size: clamp(11px, 1.3vw, 13px);
        }

        .property-value {
            font-weight: 600;
            color: #1e293b;
            text-align: right;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: clamp(12px, 1.4vw, 14px);
        }

        /* Layer Item - Responsive */
        .layer-item {
            padding: var(--spacing-md);
            background: #f8f8f8;
            border-radius: var(--radius-md);
            margin-bottom: var(--spacing-sm);
            margin-left: var(--spacing-md);
            margin-right: var(--spacing-md);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            cursor: pointer;
            transition: all 0.2s;
            min-height: var(--touch-target-min);
            touch-action: manipulation;
        }

        .layer-item:hover {
            background: #f0f0f0;
        }

        .layer-item.selected {
            background: #e8e0ff;
            border: 1px solid #667eea;
        }

        .layer-color {
            width: clamp(28px, 3.5vw, 32px);
            min-width: clamp(28px, 3.5vw, 32px);
            height: clamp(28px, 3.5vw, 32px);
            min-height: clamp(28px, 3.5vw, 32px);
            border-radius: var(--radius-sm);
            border: clamp(2px, 0.25vw, 3px) solid white;
            box-shadow: 0 clamp(1px, 0.125vw, 2px) clamp(2px, 0.375vw, 3px) rgba(0, 0, 0, 0.2);
            flex-shrink: 0;
        }

        .layer-name {
            flex: 1;
            font-size: clamp(13px, 1.75vw, 16px);
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .layer-actions {
            display: flex;
            gap: 4px;
        }

        .layer-action-btn {
            width: var(--touch-target-sm);
            min-width: var(--touch-target-min);
            height: var(--touch-target-sm);
            min-height: var(--touch-target-min);
            border: none;
            background: transparent;
            cursor: pointer;
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(14px, 1.875vw, 18px);
            transition: background 0.2s;
            touch-action: manipulation;
            flex-shrink: 0;
        }

        .layer-action-btn:hover {
            background: rgba(0, 0, 0, 0.1);
        }

        /* Learn Panel - Responsive */
        .learn-item {
            padding: var(--spacing-md);
            background: #f0f9ff;
            border-radius: var(--radius-md);
            margin-bottom: var(--spacing-sm);
            margin-left: var(--spacing-md);
            margin-right: var(--spacing-md);
            cursor: pointer;
            transition: all 0.2s;
            border: clamp(2px, 0.25vw, 3px) solid transparent;
            min-height: var(--touch-target-min);
            touch-action: manipulation;
            display: flex;
            align-items: center;
        }

        .learn-item:hover {
            background: #e0f2fe;
            border-color: #0ea5e9;
        }

        .learn-item.active {
            background: #eef2ff;
            border-color: #818cf8;
        }

        .visualizer-checkbox {
            width: 20px;
            height: 20px;
            border: 2px solid #cbd5e1;
            border-radius: 4px;
            background: white;
            margin-right: 12px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .learn-item:hover .visualizer-checkbox {
            border-color: #0ea5e9;
        }

        .learn-item.active .visualizer-checkbox {
            background: #4f46e5;
            border-color: #4f46e5;
        }

        .learn-item.active .visualizer-checkbox::after {
            content: 'âœ“';
            color: white;
            font-size: 14px;
            font-weight: 800;
        }

        .learn-item-title {
            font-weight: 600;
            color: #0369a1;
            margin-bottom: var(--spacing-xs);
            font-size: clamp(13px, 1.75vw, 16px);
        }

        .learn-item-desc {
            font-size: clamp(12px, 1.625vw, 15px);
            color: #64748b;
            line-height: 1.4;
        }

        /* Triangle Classifier - Responsive */
        .triangle-classifier {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 8px 10px;
            border-radius: 6px;
            margin: 0;
            grid-column: 1 / -1;
        }

        .triangle-classifier-title {
            font-weight: 600;
            margin-bottom: 6px;
            font-size: clamp(11px, 1.3vw, 13px);
            opacity: 0.95;
        }

        .classifier-badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.25);
            padding: 3px 8px;
            border-radius: 4px;
            font-size: clamp(10px, 1.2vw, 12px);
            margin-right: 6px;
            margin-top: 2px;
            font-weight: 500;
            backdrop-filter: blur(4px);
        }

        /* Coordinate Display - Responsive */
        .coord-display {
            position: absolute;
            bottom: clamp(12px, 2vw, 20px);
            left: clamp(12px, 2vw, 20px);
            background: white;
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: var(--radius-md);
            font-size: clamp(11px, 1.5vw, 14px);
            font-family: monospace;
            box-shadow: 0 clamp(2px, 0.5vw, 4px) clamp(6px, 1vw, 8px) rgba(0, 0, 0, 0.1);
            z-index: calc(var(--z-toolbar) - 1);
            max-width: calc(100% - var(--spacing-2xl));
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Mobile: Adjust position */
        @media (max-width: 768px) {
            .coord-display {
                bottom: clamp(80px, 12vw, 100px);
                left: var(--spacing-md);
                max-width: calc(100% - clamp(120px, 20vw, 160px));
            }
        }

        /* Color Picker - Responsive */
        .color-picker {
            display: flex;
            gap: var(--spacing-sm);
            flex-wrap: wrap;
            margin-top: var(--spacing-md);
            padding: 0 var(--spacing-md);
        }

        .color-option {
            width: clamp(32px, 4vw, 40px);
            min-width: clamp(32px, 4vw, 40px);
            height: clamp(32px, 4vw, 40px);
            min-height: clamp(32px, 4vw, 40px);
            border-radius: var(--radius-sm);
            cursor: pointer;
            border: clamp(2px, 0.25vw, 3px) solid transparent;
            transition: all 0.2s;
            touch-action: manipulation;
            flex-shrink: 0;
        }

        .color-option:hover {
            transform: scale(1.1);
            border-color: #333;
        }

        .color-option.selected {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }

        /* Create New Polygon Button & Menu - Responsive */
        .create-polygon-container {
            position: relative;
            margin-bottom: var(--spacing-lg);
            padding: 0 var(--spacing-md);
        }

        .create-polygon-btn {
            width: 100%;
            padding: var(--spacing-md) var(--spacing-lg);
            min-height: var(--touch-target-min);
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-dark) 100%);
            color: white;
            border: none;
            border-radius: var(--radius-md);
            font-size: clamp(13px, 1.75vw, 16px);
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            touch-action: manipulation;
        }

        .create-polygon-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #7c8ff0 0%, #8659af 100%);
            opacity: 0;
            transition: opacity 0.2s;
        }

        .create-polygon-btn:hover::before {
            opacity: 1;
        }

        .create-polygon-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.3);
        }

        .create-polygon-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
        }

        .create-polygon-btn:focus-visible {
            outline: 3px solid #667eea;
            outline-offset: 2px;
        }

        .create-polygon-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .create-polygon-btn .btn-icon,
        .create-polygon-btn .btn-chevron {
            position: relative;
            z-index: 1;
        }

        .create-polygon-btn .btn-icon {
            flex-shrink: 0;
        }

        .create-polygon-btn span {
            position: relative;
            z-index: 1;
            flex: 1;
            text-align: left;
        }

        /* Shape Selection Grid - Modal */
        .shape-option-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 16px;
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .shape-option-card:hover {
            border-color: #667eea;
            background: #f0f4ff;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.15);
        }

        .shape-option-card:active {
            transform: translateY(0);
        }

        .shape-option-card .shape-icon {
            width: 48px;
            height: 48px;
            font-size: 24px;
            margin-bottom: 12px;
            background: #eef2ff;
            color: #4f46e5;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius-md);
        }

        .shape-option-card .shape-name {
            font-size: 15px;
            margin-bottom: 4px;
            color: #2d3748;
            font-weight: 600;
        }

        .shape-option-card .shape-hint {
            font-size: 12px;
            color: #718096;
        }

        .shape-shortcut {
            padding: 4px 8px;
            background: #f0f0f0;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            color: #666;
            font-family: monospace;
        }

        /* Announcement for screen readers */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Flash animation for feedback */
        @keyframes flash {

            0%,
            100% {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            }

            50% {
                background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            }
        }



        /* Tutorial Overlay - Responsive */
        .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: var(--z-overlay);
            padding: var(--spacing-lg);
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .tutorial-modal {
            background: white;
            border-radius: var(--radius-xl);
            padding: var(--spacing-xl);
            max-width: min(90vw, 500px);
            width: 100%;
            max-height: min(90vh, 600px);
            overflow-y: auto;
            animation: slideIn 0.3s ease-out;
            margin: auto;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .tutorial-title {
            font-size: clamp(20px, 3vw, 28px);
            font-weight: 700;
            margin-bottom: var(--spacing-lg);
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-dark) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .tutorial-content {
            font-size: clamp(13px, 1.75vw, 16px);
            line-height: 1.6;
            color: #444;
        }

        .tutorial-actions {
            margin-top: 20px;
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .btn {
            padding: var(--spacing-md) var(--spacing-lg);
            min-height: var(--touch-target-min);
            border: none;
            border-radius: var(--radius-md);
            font-size: clamp(13px, 1.75vw, 16px);
            cursor: pointer;
            transition: all 0.2s;
            touch-action: manipulation;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        /* Grid Toggle - Responsive */
        /* Top Tools Bar - Professional Tabs */
        .top-tools-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            width: 100%;
            height: clamp(48px, 6vw, 56px);
            /* Increased height matches toolbar */
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 24px;
            /* Fixed generous gap */
            background: white;
            padding: 0 16px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            /* z-index must be higher than toolbar */
            z-index: calc(var(--z-toolbar) + 1);
            box-sizing: border-box;
        }

        .top-tool-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 0 12px;
            height: 100%;
            cursor: pointer;
        }

        .top-tool-item:hover {
            background: #f7fafc;
        }

        .learn-tab-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 10px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3);
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
        }

        .learn-tab-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.4);
            opacity: 0.95;
        }

        .top-bar-btn {
            background: white;
            border: 1px solid var(--color-border);
            padding: 8px 16px;
            border-radius: 10px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
            color: #4a5568;
        }

        .top-bar-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            background: #f7fafc;
            color: var(--color-primary);
            border-color: var(--color-primary);
        }

        .top-bar-btn:active {
            transform: translateY(0);
        }

        /* Mobile: Adjust position */
        @media (max-width: 768px) {
            .top-tools-bar {
                top: clamp(10px, 2vw, 15px);
            }
        }

        .toggle-switch {
            width: 36px;
            height: 20px;
            background: #ccc;
            border-radius: 10px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: #667eea;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
        }

        .toggle-switch.active::after {
            transform: translateX(16px);
        }

        /* Drag Handle for Panels */
        .drag-handle {
            cursor: move;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            -webkit-user-select: none;
            user-select: none;
            /* For Safari compatibility */
            padding: 0 4px;
        }

        .drag-handle:hover {
            color: white;
        }

        .panel-header.dragging {
            opacity: 0.7;
            background: linear-gradient(135deg, #4a6de5 0%, #5a52a3 100%);
        }

        .panel.drag-over {
            box-shadow: 0 0 0 2px #667eea;
        }

        .panel {
            transition: box-shadow 0.2s ease;
        }

        /* Resizable Panel Styles */
        .resizable-panel {
            display: flex;
            flex-direction: column;
            min-height: 0;
            /* Important for flex children to shrink */
            overflow: hidden;
            position: relative;
        }

        .resizable-panel-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            min-height: 0;
            position: relative;
            padding: var(--spacing-sm);
        }

        /* Custom scrollbar for panels */
        .resizable-panel-content::-webkit-scrollbar {
            width: clamp(6px, 0.75vw, 8px);
        }

        .resizable-panel-content::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .resizable-panel-content::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: var(--radius-sm);
        }

        .resizable-panel-content::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        /* Mobile and Tablet sidebar backdrop */
        .sidebar-backdrop {
            position: fixed;
            /* Start below toolbar - same as sidebar top */
            top: clamp(96px, 12vw, 126px);
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: calc(var(--z-menu) - 1);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            display: none;
        }

        /* Show backdrop on mobile only (tablets don't need it as sidebars are visible) */
        @media (max-width: 768px) {
            .sidebar-backdrop {
                display: block;
            }
        }

        .sidebar-backdrop.active {
            opacity: 1;
            pointer-events: auto;
        }

        /* Ensure text is always readable */
        @media (max-width: 768px) {
            body {
                font-size: clamp(14px, 4vw, 16px);
            }
        }

        /* Prevent text from being too small */
        @media (max-width: 320px) {
            :root {
                --base-font-size: 14px;
            }
        }

        /* Large screen optimizations */
        @media (min-width: 1920px) {
            .app-container {
                max-width: none;
                margin: 0;
            }
        }

        /* High DPI display optimizations */
        @media (-webkit-min-device-pixel-ratio: 2),
        (min-resolution: 192dpi) {

            .tool-btn,
            .zoom-btn,
            .layer-action-btn {
                image-rendering: -webkit-optimize-contrast;
                image-rendering: crisp-edges;
            }
        }

        /* Landscape mobile optimizations */
        @media (max-width: 768px) and (orientation: landscape) {
            .toolbar {
                min-height: clamp(32px, 4vw, 40px);
                max-height: clamp(32px, 4vw, 40px);
                padding: clamp(3px, 0.4vw, 5px) clamp(6px, 0.75vw, 10px);
            }

            .app-container {
                margin-top: clamp(32px, 4vw, 40px);
            }

            .zoom-controls {
                bottom: clamp(50px, 8vw, 70px);
            }

            .coord-display {
                bottom: clamp(50px, 8vw, 70px);
            }
        }

        /* Portrait mobile optimizations */
        @media (max-width: 768px) and (orientation: portrait) {
            .toolbar {
                gap: clamp(2px, 0.25vw, 3px);
                padding: clamp(4px, 0.5vw, 6px) clamp(6px, 0.75vw, 10px);
            }
        }

        /* Ensure all interactive elements are accessible */
        button,
        a,
        [role="button"],
        [tabindex="0"] {
            min-height: var(--touch-target-min);
            min-width: var(--touch-target-min);
        }

        /* Focus states for accessibility */
        *:focus-visible {
            outline: clamp(2px, 0.25vw, 3px) solid var(--color-primary);
            outline-offset: clamp(2px, 0.25vw, 3px);
        }

        /* Smooth transitions for layout changes */
        .app-container,
        .sidebar,
        .canvas-container {
            transition: width 0.3s ease, height 0.3s ease, transform 0.3s ease;
        }

        /* Mobile Menu Toggle Buttons */
        .mobile-menu-toggle {
            position: absolute;
            width: 44px;
            height: 44px;
            z-index: 999;
            background: white;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none;
            user-select: none;
        }

        .mobile-menu-toggle:active {
            transform: scale(0.95);
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
        }

        /* Hide on desktop */
        @media (min-width: 769px) {
            .mobile-menu-toggle {
                display: none !important;
            }
        }

        /* Ensure buttons don't interfere with canvas interactions */
        @media (max-width: 768px) {
            .mobile-menu-toggle {
                pointer-events: auto;
            }

            /* Make sure canvas container allows pointer events through except for buttons */
            #canvasContainer {
                position: relative;
            }
        }

        /* Zoom Controls - Responsive Positioning */
        .zoom-controls {
            position: absolute;
            bottom: clamp(60px, 8vw, 80px);
            /* Pushed up to avoid bottom panel overlap */
            right: clamp(16px, 2vw, 24px);
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: var(--z-canvas-ui);
        }

        /* Coordinate Display */
        .coord-display {
            position: absolute;
            bottom: clamp(60px, 8vw, 80px);
            /* Pushed up */
            left: clamp(16px, 2vw, 24px);
            background: rgba(255, 255, 255, 0.9);
            padding: 6px 12px;
            border-radius: var(--radius-md);
            font-family: monospace;
            font-size: 12px;
            pointer-events: none;
            z-index: var(--z-canvas-ui);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(4px);
        }

        /* Bottom Properties Panel */
        .bottom-panel {
            width: 100%;
            background: white;
            border-top: 1px solid var(--color-border);
            display: flex;
            flex-direction: column;
            transition: height 0.3s ease;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.05);
            z-index: 1001;
            height: 180px;
            /* Default expanded height */
        }

        .bottom-panel.collapsed {
            height: 40px;
            /* Header height only */
            pointer-events: none;
            position: relative;
        }

        .bottom-panel.collapsed * {
            pointer-events: none;
        }

        .bottom-panel.collapsed .bottom-panel-content {
            display: none;
            pointer-events: none;
        }

        .bottom-panel.collapsed .bottom-panel-header {
            pointer-events: auto !important;
            position: relative;
            z-index: 1002;
        }

        .bottom-panel.collapsed .bottom-panel-header * {
            pointer-events: auto;
        }

        .bottom-panel-header {
            height: 40px;
            padding: 0 16px;
            background: linear-gradient(135deg, #f8fafc 0%, #edf2f7 100%);
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid var(--color-border);
            cursor: pointer;
        }

        .bottom-panel-title {
            font-weight: 600;
            color: #4a5568;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .bottom-panel-toggle {
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            color: #718096;
            transition: transform 0.3s;
        }

        .bottom-panel.collapsed .bottom-panel-toggle {
            transform: rotate(180deg);
        }

        .bottom-panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px 12px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 8px;
            align-content: start;
        }

        /* Ensure app container uses column flow */
        .app-container {
            flex-direction: column !important;
        }

        /* Prevent layout shift during resize */
        .canvas-container {
            contain: layout style paint;
        }

        /* Combine Button - Wider for text */
        .tool-btn.combine-btn {
            width: auto;
            min-width: clamp(60px, 8vw, 80px);
            padding: 0 var(--spacing-sm);
            font-weight: 600;
            font-size: clamp(12px, 1.5vw, 14px);
        }

        /* Split Button */
        .tool-btn.split-btn {
            width: auto;
            min-width: clamp(50px, 6vw, 60px);
            padding: 0 var(--spacing-sm);
            font-weight: 600;
            font-size: clamp(12px, 1.5vw, 14px);
        }

        /* Combine Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            backdrop-filter: blur(4px);
        }

        .modal-content {
            background: white;
            border-radius: var(--radius-lg);
            padding: var(--spacing-xl);
            max-width: min(90vw, 400px);
            width: 100%;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                transform: translateY(20px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            font-size: clamp(18px, 2.5vw, 22px);
            font-weight: 700;
            color: var(--color-primary-dark);
            margin-bottom: var(--spacing-md);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #718096;
            padding: 4px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s, color 0.2s;
            line-height: 1;
        }

        .modal-close-btn:hover {
            background: #edf2f7;
            color: #2d3748;
        }

        .modal-body {
            font-size: clamp(14px, 1.75vw, 16px);
            color: #444;
            line-height: 1.5;
            margin-bottom: var(--spacing-lg);
        }

        .modal-footer {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
        }

        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #666;
            cursor: pointer;
        }

        .modal-btn {
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-dark) 100%);
            color: white;
            border: none;
            padding: 12px;
            border-radius: var(--radius-md);
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .modal-btn:hover {
            opacity: 0.9;
        }
    </style>
</head>

<body>

    <div class="app-container">
        <!-- Main Body Row (Sidebars + Canvas) -->
        <div class="main-body-row" style="display: flex; flex: 1; min-height: 0; width: 100%; position: relative;">

            <!-- Mobile Sidebar Backdrop -->
            <div class="sidebar-backdrop" id="sidebarBackdrop"></div>

            <!-- Left Sidebar -->
            <div class="sidebar">

                <!-- Wrapper for Layers Panel full height -->
                <div class="resizable-panel" id="layersPanel" style="height: 100%; flex: 1;">
                    <!-- Layers Panel -->
                    <div class="panel-header">
                        <button class="panel-back-btn" id="layersBackBtn" aria-label="Close Layers Panel">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M19 12H5M12 19l-7-7 7-7" />
                            </svg>
                        </button>
                        <span>
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                                style="display: inline-block; vertical-align: middle; margin-right: 6px;">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2" />
                                <rect x="7" y="7" width="10" height="10" rx="1" ry="1" />
                                <rect x="11" y="11" width="6" height="6" rx="0.5" ry="0.5" />
                            </svg>
                            Layers
                        </span>
                        <span id="layerCount">0</span>
                    </div>
                    <div class="resizable-panel-content">
                        <!-- Create New Polygon Button -->
                        <div class="create-polygon-container">
                            <button id="createPolygonBtn" class="create-polygon-btn"
                                aria-label="Open create new polygon menu">
                                <svg class="btn-icon" width="20" height="20" viewBox="0 0 24 24" fill="none"
                                    stroke="currentColor" stroke-width="2">
                                    <path d="M12 2L2 7L2 17L12 22L22 17L22 7L12 2Z" />
                                </svg>
                                <span>Create New Polygon</span>
                            </button>
                        </div>

                        <!-- Layers List -->
                        <div id="layersList"></div>
                    </div>
                </div>
            </div>

            <!-- Canvas Container -->
            <div class="canvas-container" id="canvasContainer">
                <canvas id="mainCanvas"></canvas>

                <!-- Toolbar -->
                <div class="toolbar">
                    <button class="tool-btn" id="toolbarCreateBtn" data-tooltip="Create New Polygon">âž•</button>
                    <button class="tool-btn active" data-tool="select" data-tooltip="Select/Move (S)">âœ‹</button>

                    <!-- Color Picker Button -->
                    <div style="position: relative; display: inline-flex;">
                        <button class="tool-btn" id="toolbarColorBtn" data-tooltip="Change Color">ðŸŽ¨</button>
                        <input type="color" id="toolbarColorInput" value="#667eea"
                            style="position: absolute; opacity: 0; width: 0; height: 0; pointer-events: none;">
                    </div>

                    <button class="tool-btn combine-btn" data-tool="combine"
                        data-tooltip="Combine Polygons">Combine</button>
                    <button class="tool-btn combine-btn" id="cancelCombineBtn"
                        style="display: none; background: #e53e3e; color: white;"
                        data-tooltip="Cancel Combine">Cancel</button>
                    <button class="tool-btn split-btn" data-tool="split" data-tooltip="Split Polygon">Split</button>
                    <button class="tool-btn split-btn" id="cancelSplitBtn"
                        style="display: none; background: #e53e3e; color: white;"
                        data-tooltip="Cancel Split">Cancel</button>
                    <button class="tool-btn" data-tool="undo" data-tooltip="Undo (Ctrl+Z)">â†¶</button>
                    <button class="tool-btn" data-tool="redo" data-tooltip="Redo (Ctrl+Y)">â†·</button>
                </div>

                <!-- Top Tools Bar (Tabs) -->
                <div class="top-tools-bar">
                    <button class="learn-tab-btn" id="openLearnPageBtn">
                        ðŸŽ“ Learn Polygons
                    </button>
                    <button class="top-bar-btn" data-tool="save" title="Save Project">
                        ðŸ’¾ Save
                    </button>
                    <button class="top-bar-btn" data-tool="load" title="Open Project">
                        ðŸ“ Open
                    </button>
                    <button class="fullscreen-top-btn" id="fullscreenToggle" title="Toggle Fullscreen">â¤¢</button>
                </div>

                <!-- Zoom Controls -->
                <div class="zoom-controls">
                    <button class="zoom-btn" id="zoomIn">âž•</button>
                    <button class="zoom-btn" id="zoomOut">âž–</button>
                    <button class="zoom-btn" id="zoomReset">ðŸ”</button>
                </div>

                <!-- Coordinate Display -->
                <div class="coord-display" id="coordDisplay">X: 0, Y: 0</div>
            </div>

            <!-- Right Sidebar -->
            <div class="sidebar sidebar-right">
                <!-- Visualizers Panel -->
                <div class="panel">
                    <div class="panel-header">
                        <button class="panel-back-btn" id="visualizersBackBtn" aria-label="Close Visualizers Panel">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M19 12H5M12 19l-7-7 7-7" />
                            </svg>
                        </button>
                        <span>ðŸ‘ï¸ Visualizers</span>
                    </div>
                    <div class="panel-content">
                        <div class="learn-item" data-viz="angles">
                            <div class="visualizer-checkbox"></div>
                            <div class="learn-item-title">Show Angles</div>
                        </div>
                        <div class="learn-item" data-viz="medians">
                            <div class="visualizer-checkbox"></div>
                            <div class="learn-item-title">Show Medians & Centroid</div>
                        </div>
                        <div class="learn-item" data-viz="altitudes">
                            <div class="visualizer-checkbox"></div>
                            <div class="learn-item-title">Show Altitudes & Orthocenter</div>
                        </div>
                        <div class="learn-item" data-viz="bisectors">
                            <div class="visualizer-checkbox"></div>
                            <div class="learn-item-title">Show Perpendicular Bisectors</div>
                        </div>
                        <div class="learn-item" data-viz="diagonals">
                            <div class="visualizer-checkbox"></div>
                            <div class="learn-item-title">Show Diagonals</div>
                        </div>
                        <div class="learn-item" data-viz="vertices">
                            <div class="visualizer-checkbox"></div>
                            <div class="learn-item-title">Show Vertices</div>
                        </div>
                        <div class="learn-item" data-viz="perimeters">
                            <div class="visualizer-checkbox"></div>
                            <div class="learn-item-title">Show Perimeters</div>
                        </div>
                        <div class="learn-item" data-viz="baseHeight">
                            <div class="visualizer-checkbox"></div>
                            <div class="learn-item-title">Show Base & Height</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Bottom Properties Panel -->
        <div id="bottomPropertiesPanel" class="bottom-panel expanded">
            <div class="bottom-panel-header">
                <div class="bottom-panel-title">
                    <span>ðŸ“Š Properties</span>
                </div>
                <button class="bottom-panel-toggle" id="bottomPanelToggle">
                    <span class="toggle-icon">â–¼</span>
                </button>
            </div>
            <div class="bottom-panel-content" id="propertiesPanelContent">
                <div class="property-row" style="justify-content: center; padding: 12px;">
                    <span class="property-label" style="color: #94a3b8; font-style: italic;">Select a polygon to view
                        properties</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Learn Geometry Full Page -->
    <div id="learnPage">
        <div class="learn-header">
            <h1>ðŸŽ“ Learn Polygon</h1>
            <button class="close-learn-btn" id="closeLearnPageBtn">
                <span>Back to App</span>
                âœ•
            </button>
        </div>
        <div class="learn-content-grid" id="learnPageContent">
            <!-- Content populated by JS -->
        </div>
    </div>

    <!-- Combine Tool Modal -->
    <!-- Combine Tool Modal -->
    <div class="modal-overlay" id="combineModal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">Combine Polygons</span>
                <button class="modal-close-btn"
                    onclick="document.getElementById('combineModal').style.display = 'none'">&times;</button>
            </div>
            <div class="modal-body">
                Please select two or more polygons to combine them into a single morphed polygon.
            </div>
            <div class="modal-footer">
                <label class="checkbox-wrapper">
                    <input type="checkbox" id="combineDontShowAgain">
                    Don't show this again
                </label>
                <button class="modal-btn" id="combineContinueBtn">Continue</button>
            </div>
        </div>
    </div>

    <!-- Split Tool Modal -->
    <div class="modal-overlay" id="splitModal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">Split Polygon</span>
                <button class="modal-close-btn"
                    onclick="document.getElementById('splitModal').style.display = 'none'">&times;</button>
            </div>
            <div class="modal-body">
                Use the Line vector to split your polygon into two pieces.
            </div>
            <div class="modal-footer">
                <label class="checkbox-wrapper">
                    <input type="checkbox" id="splitDontShowAgain">
                    Don't show this again
                </label>
                <button class="modal-btn" id="splitContinueBtn">Continue</button>
            </div>
        </div>
    </div>

    <!-- Combine Selection Error Modal -->
    <div class="modal-overlay" id="combineSelectionModal" style="z-index: 3100;">
        <div class="modal-content" style="max-width: 400px; text-align: center;">
            <div class="modal-header" style="justify-content: center;">
                <span class="modal-title">Select Polygons</span>
            </div>
            <div class="modal-body">
                Please select at least two polygons to combine.
            </div>
            <div class="modal-footer" style="justify-content: center;">
                <button class="modal-btn"
                    onclick="document.getElementById('combineSelectionModal').style.display = 'none'">OK</button>
            </div>
        </div>
    </div>

    <!-- Split Selection Confirmation Modal -->
    <div class="modal-overlay" id="splitConfirmSelectionModal">
        <div class="modal-content" style="max-width: 300px; text-align: center;">
            <div class="modal-header" style="justify-content: center;">Confirm Selection</div>
            <div class="modal-body">
                Do you want to split this polygon?
            </div>
            <div class="modal-footer" style="flex-direction: row; justify-content: center;">
                <button class="modal-btn" style="background: #e1e4e8; color: #1a202c;"
                    id="splitCancelSelectionBtn">Cancel</button>
                <button class="modal-btn" style="background: #667eea; color: white;"
                    id="splitConfirmSelectionBtnModal">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Reset Confirmation Modal -->
    <div class="modal-overlay" id="resetModal">
        <div class="modal-content">
            <div class="modal-header" style="color: #e53e3e;">âš ï¸ Reset Everything?</div>
            <div class="modal-body">
                This will clear the entire canvas and cannot be undone. Are you sure you want to proceed?
            </div>
            <div class="modal-footer" style="flex-direction: row; justify-content: flex-end;">
                <button class="modal-btn" id="cancelResetBtn"
                    style="background: #edf2f7; color: #4a5568;">Cancel</button>
                <button class="modal-btn" id="confirmResetBtn" style="background: #e53e3e; color: white;">Yes,
                    Reset</button>
            </div>
        </div>
    </div>

    <!-- Create Shape Modal -->
    <div class="modal-overlay" id="createShapeModal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <span>Create New Polygon</span>
                <button id="closeCreateShapeModal" class="modal-close-btn">&times;</button>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 20px; color: #4a5568; font-size: 15px;">Which shape polygon would you like to
                    create?</p>
                <div class="shape-grid"
                    style="display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 12px;">
                    <div class="shape-option-card" data-shape="triangle" data-sides="3">
                        <div class="shape-icon">â–²</div>
                        <div class="shape-name">Triangle</div>
                        <div class="shape-hint">3 sides</div>
                    </div>
                    <div class="shape-option-card" data-shape="square" data-sides="4">
                        <div class="shape-icon">â– </div>
                        <div class="shape-name">Square</div>
                        <div class="shape-hint">4 equal sides</div>
                    </div>
                    <div class="shape-option-card" data-shape="rectangle" data-sides="4">
                        <div class="shape-icon">â–¬</div>
                        <div class="shape-name">Rectangle</div>
                        <div class="shape-hint">4 sides</div>
                    </div>
                    <div class="shape-option-card" data-shape="pentagon" data-sides="5">
                        <div class="shape-icon">â¬Ÿ</div>
                        <div class="shape-name">Pentagon</div>
                        <div class="shape-hint">5 sides</div>
                    </div>
                    <div class="shape-option-card" data-shape="hexagon" data-sides="6">
                        <div class="shape-icon">â¬¢</div>
                        <div class="shape-name">Hexagon</div>
                        <div class="shape-hint">6 sides</div>
                    </div>
                    <div class="shape-option-card" data-shape="heptagon" data-sides="7">
                        <div class="shape-icon">â¬ </div>
                        <div class="shape-name">Heptagon</div>
                        <div class="shape-hint">7 sides</div>
                    </div>
                    <div class="shape-option-card" data-shape="octagon" data-sides="8">
                        <div class="shape-icon">â¬¡</div>
                        <div class="shape-name">Octagon</div>
                        <div class="shape-hint">8 sides</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Tutorial Modal -->
    <div class="modal-overlay" id="tutorialOverlay">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header" style="justify-content: center;">
                <span class="tutorial-title" style="margin: 0; font-size: 24px;">Welcome to Geometry Playground!
                    ðŸŽ‰</span>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 12px;"><strong>Get started:</strong></p>
                <ul style="margin: 12px 0; padding-left: 20px;">
                    <li>Click "Create New Polygon" for quick shapes</li>
                    <li>Use âœ‹ to select and move shapes</li>
                    <li>Zoom with scroll wheel or buttons</li>
                    <li>Click "Learn" ðŸŽ“ for definitions</li>
                </ul>
                <p style="margin-top: 12px; font-size: 0.9em; color: #666;"><strong>Keyboard shortcuts:</strong> Ctrl+N
                    (New shape), S (Select), Space (Pan), Ctrl+Z (Undo)</p>
            </div>
            <div class="modal-footer">
                <button class="modal-btn" onclick="closeTutorial()">Let's Start!</button>
            </div>
        </div>
    </div>
    <!-- Learn Page Overlay -->
    <div id="learnPage"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 2000; background: #f8fafc; display: none; flex-direction: column;">
        <div class="learn-header"
            style="background: white; padding: 16px 24px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); display: flex; align-items: center; justify-content: space-between; position: relative; z-index: 10;">
            <div
                style="font-size: 24px; font-weight: 700; color: #2d3748; display: flex; align-items: center; gap: 12px;">
                ðŸŽ“ Learn Polygons
            </div>
            <button id="closeLearnPageBtn"
                style="padding: 8px 16px; background: #edf2f7; color: #4a5568; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                Back to App
            </button>
        </div>
        <div style="flex: 1; overflow-y: auto; padding: 24px;">
            <div id="learnPageContent" class="learn-content-grid">
                <!-- Content populated by JS -->
            </div>
        </div>
    </div>

    <script>
        // Device Detection and Viewport Intelligence System
        class DeviceDetector {
            constructor() {
                this.deviceInfo = {
                    type: 'desktop',
                    isMobile: false,
                    isTablet: false,
                    isDesktop: true,
                    isTouch: false,
                    orientation: 'landscape',
                    screenWidth: window.innerWidth,
                    screenHeight: window.innerHeight,
                    aspectRatio: window.innerWidth / window.innerHeight,
                    pixelRatio: window.devicePixelRatio || 1
                };

                this.updateDeviceInfo();
                this.setupListeners();
                this.applyDeviceClasses();
            }

            updateDeviceInfo() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                const aspectRatio = width / height;

                // Detect device type
                this.deviceInfo.screenWidth = width;
                this.deviceInfo.screenHeight = height;
                this.deviceInfo.aspectRatio = aspectRatio;
                this.deviceInfo.orientation = width > height ? 'landscape' : 'portrait';

                // Touch detection
                this.deviceInfo.isTouch = 'ontouchstart' in window ||
                    navigator.maxTouchPoints > 0 ||
                    navigator.msMaxTouchPoints > 0;

                // Device type detection
                if (width <= 768) {
                    this.deviceInfo.type = 'mobile';
                    this.deviceInfo.isMobile = true;
                    this.deviceInfo.isTablet = false;
                    this.deviceInfo.isDesktop = false;
                } else if (width <= 1024) {
                    this.deviceInfo.type = 'tablet';
                    this.deviceInfo.isMobile = false;
                    this.deviceInfo.isTablet = true;
                    this.deviceInfo.isDesktop = false;
                } else {
                    this.deviceInfo.type = 'desktop';
                    this.deviceInfo.isMobile = false;
                    this.deviceInfo.isTablet = false;
                    this.deviceInfo.isDesktop = true;
                }
            }

            setupListeners() {
                // Resize handler with debouncing
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        this.updateDeviceInfo();
                        this.applyDeviceClasses();
                        this.onResize();
                    }, 100);
                });

                // Orientation change handler
                window.addEventListener('orientationchange', () => {
                    setTimeout(() => {
                        this.updateDeviceInfo();
                        this.applyDeviceClasses();
                        this.onOrientationChange();
                    }, 100);
                });

                // Touch detection
                document.addEventListener('touchstart', () => {
                    if (!this.deviceInfo.isTouch) {
                        this.deviceInfo.isTouch = true;
                        this.applyDeviceClasses();
                    }
                }, { once: true });
            }

            applyDeviceClasses() {
                const root = document.documentElement;
                const body = document.body;

                // Remove existing classes
                body.classList.remove('device-mobile', 'device-tablet', 'device-desktop',
                    'is-touch', 'is-mouse', 'orientation-portrait', 'orientation-landscape');

                // Add device type classes
                body.classList.add(`device-${this.deviceInfo.type}`);

                // Add touch/mouse classes
                if (this.deviceInfo.isTouch) {
                    body.classList.add('is-touch');
                } else {
                    body.classList.add('is-mouse');
                }

                // Add orientation classes
                body.classList.add(`orientation-${this.deviceInfo.orientation}`);

                // Set CSS custom properties
                root.style.setProperty('--is-mobile', this.deviceInfo.isMobile ? '1' : '0');
                root.style.setProperty('--is-tablet', this.deviceInfo.isTablet ? '1' : '0');
                root.style.setProperty('--is-desktop', this.deviceInfo.isDesktop ? '1' : '0');
                root.style.setProperty('--is-touch', this.deviceInfo.isTouch ? '1' : '0');
                root.style.setProperty('--is-portrait', this.deviceInfo.orientation === 'portrait' ? '1' : '0');
                root.style.setProperty('--is-landscape', this.deviceInfo.orientation === 'landscape' ? '1' : '0');
            }

            onResize() {
                // Trigger custom event for other components
                window.dispatchEvent(new CustomEvent('deviceResize', {
                    detail: this.deviceInfo
                }));
            }

            onOrientationChange() {
                // Trigger custom event for orientation changes
                window.dispatchEvent(new CustomEvent('deviceOrientationChange', {
                    detail: this.deviceInfo
                }));
            }

            getInfo() {
                return { ...this.deviceInfo };
            }
        }

        // Global device detector instance
        let deviceDetector;

        // Geometry Polygon Playground - Main Application
        class PolygonPlayground {
            constructor() {
                this.canvas = document.getElementById('mainCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.container = document.getElementById('canvasContainer');

                // Initialize device detector
                if (!deviceDetector) {
                    deviceDetector = new DeviceDetector();
                }
                this.deviceInfo = deviceDetector.getInfo();

                // State
                this.polygons = [];
                this.selectedPolygon = null;
                this.selectedVertex = null;
                this.currentTool = 'select';
                this.gridSize = 20;
                this.gridSnap = true;
                this.zoom = 1;
                this.pan = { x: 0, y: 0 };
                this.isDragging = false;
                this.isPanning = false;
                this.dragStart = null;
                this.potentialDragStart = null; // Store initial click for drag threshold detection
                this.dragThreshold = 3; // Pixels to move before starting drag
                this.panStartPos = null; // Track initial click position for pan detection
                this.panThreshold = 5; // Minimum pixels to move before starting pan
                this.history = [];
                this.historyIndex = -1;
                this.visualizers = new Set();
                this.colors = [
                    '#667eea', '#f56565', '#48bb78', '#ed8936', '#9f7aea',
                    '#38b2ac', '#f687b3', '#4299e1', '#ecc94b', '#a0aec0'
                ];
                this.currentColor = '#667eea';

                // Combine Tool State
                this.combineMode = false;
                this.combineSelection = new Set();
                // For cycling through overlapping polygons in combine mode
                this.combineLastClickPos = null;
                this.combineLastClickTime = 0;
                this.combineCycleIndex = 0;

                // Split Tool State
                this.splitMode = false;
                this.splitStep = 0; // 0: Select Polygon, 1: Draw Line
                this.splitLineStart = null;
                this.splitLineEnd = null;
                this.splitLineType = 'free'; // 'free', 'horizontal', 'vertical'

                // Mouse tracking
                this.mousePos = { x: 0, y: 0 };
                this.mouseWorldPos = { x: 0, y: 0 };

                // Shape menu state
                this.shapeMenuOpen = false;
                this.currentMenuIndex = -1;
                this.lastUsedShape = localStorage.getItem('lastUsedShape') || 'triangle';
                this.lastShapeCreationTime = 0; // Debounce for shape creation

                // Telemetry callbacks
                this.telemetry = {
                    onShapeMenuOpen: null,
                    onShapeMenuClose: null,
                    onShapeSelect: null
                };

                // Panel resizing state
                this.isResizing = false;
                this.activeDivider = null;
                this.startY = 0;
                this.startHeight = 0;
                this.originalHeights = [];

                // Touch/pinch state
                this.isPinching = false;
                this.pinchDistance = 0;
                this.pinchZoom = 1;
                this.touchStartTime = null;
                this.lastTouchTime = 0; // Track last touch to prevent mouse event conflicts
                this.touchStartPos = null; // Store initial touch position for tap detection
                this.touchTapThreshold = 10; // Pixels to move before considering it a drag
                this.touchPanThreshold = 15; // Pixels to move before starting pan (higher for touch)
                this.touchDragThreshold = 8; // Pixels to move before starting drag
                this.touchGestureLocked = false; // Lock gesture type once determined
                this.touchLastMoveTime = 0; // Track movement timing for velocity
                this.touchVelocity = { x: 0, y: 0 }; // Track touch velocity
                this.lastDimensions = null; // Track dimensions for resize compensation
                this.isResizingCanvas = false; // Flag to track intentional resize operations

                // Grid optimization state
                this.gridCache = null;
                this.lastGridState = null; // Track grid state to avoid unnecessary redraws
                this.gridViewBounds = null; // Cache view bounds for grid
                this.gridNeedsRedraw = true; // Flag to track if grid needs redraw
                this.renderScheduled = false; // Throttle render calls
                this.lastRenderTime = 0;
                this.renderThrottleMs = 16; // ~60fps max render rate
                this.renderAnimationFrameId = null; // Track RAF for cleanup

                this.init();
            }

            setTelemetryCallbacks(callbacks) {
                this.telemetry = { ...this.telemetry, ...callbacks };
            }

            init() {
                this.setupCanvas();
                this.setupEventListeners();
                this.setupToolbar();
                this.setupColorPicker();
                this.setupLearnPanel();
                this.setupResizablePanels();
                this.setupBottomPanel();
                this.setupShapeMenu();
                this.setupResponsiveHandlers();

                // Ensure layout is settled before creating polygon so it is perfectly centered
                // Use multiple RAF calls to ensure canvas is fully sized and ready
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        // First, ensure canvas is properly sized
                        this.syncResize(false); // Don't compensate pan on initial resize
                        requestAnimationFrame(() => {
                            // Now create the polygon and render
                            this.createSamplePolygon();
                            // Force a render to ensure everything is visible
                            this.render(true);
                        });
                    });
                });

                // Show tutorial on first load
                if (!localStorage.getItem('tutorialShown')) {
                    document.getElementById('tutorialOverlay').style.display = 'flex';
                    localStorage.setItem('tutorialShown', 'true');
                }
            }

            setupResponsiveHandlers() {
                // Debounced resize handler to prevent excessive calls
                let resizeTimeout;
                const handleResize = () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        this.handleViewportChange();
                        this.resizeCanvas();
                    }, 150); // Debounce resize operations
                };

                // Handle device resize (from DeviceDetector)
                window.addEventListener('deviceResize', (e) => {
                    this.deviceInfo = e.detail;
                    handleResize();
                });

                // Handle orientation change
                window.addEventListener('deviceOrientationChange', (e) => {
                    this.deviceInfo = e.detail;
                    // Use longer timeout for orientation change to ensure layout is stable
                    setTimeout(() => {
                        this.handleViewportChange();
                        this.resizeCanvas();
                    }, 200);
                });

                // Handle window resize (consolidated handler)
                window.addEventListener('resize', handleResize);

                // Initial viewport setup
                this.handleViewportChange();
            }

            handleViewportChange() {
                // Update sidebar visibility based on device type
                if (this.deviceInfo.isMobile || window.innerWidth <= 768) {
                    // Mobile: sidebars are overlays that start closed
                    document.querySelectorAll('.sidebar').forEach(sidebar => {
                        sidebar.classList.remove('mobile-open');
                    });
                    // Hide backdrop
                    const backdrop = document.getElementById('sidebarBackdrop');
                    if (backdrop) {
                        backdrop.classList.remove('active');
                    }
                } else if (this.deviceInfo.isTablet || (window.innerWidth > 768 && window.innerWidth <= 1024)) {
                    // Tablet: sidebars are visible by default (like desktop)
                    // Remove mobile-open class to make them visible in normal position
                    document.querySelectorAll('.sidebar').forEach(sidebar => {
                        sidebar.classList.remove('mobile-open');
                    });
                    // Hide backdrop (sidebars are visible, not overlays)
                    const backdrop = document.getElementById('sidebarBackdrop');
                    if (backdrop) {
                        backdrop.classList.remove('active');
                    }
                } else {
                    // Desktop: sidebars are always visible (not overlays)
                    document.querySelectorAll('.sidebar').forEach(sidebar => {
                        sidebar.classList.remove('mobile-open');
                    });
                    const backdrop = document.getElementById('sidebarBackdrop');
                    if (backdrop) {
                        backdrop.classList.remove('active');
                    }
                }

                // Adjust toolbar for mobile/tablet
                const toolbar = document.querySelector('.toolbar');
                if (toolbar && (this.deviceInfo.isMobile || this.deviceInfo.isTablet || window.innerWidth <= 1024)) {
                    toolbar.scrollLeft = 0; // Reset scroll on mobile/tablet
                }

                // Ensure canvas is properly sized
                this.resizeCanvas();
            }

            setupResizablePanels() {
                const divider1 = document.getElementById('divider1');
                const layersPanel = document.getElementById('layersPanel');
                const colorPanel = document.getElementById('colorPanel');

                // Set initial heights for sidebar panels
                const sidebar = document.querySelector('.sidebar');
                if (!sidebar) return; // Guard clause

                const totalHeight = sidebar.clientHeight;

                // Split 50/50 between Layers and Color since Properties is gone
                const panelHeight = Math.floor(totalHeight * 0.5);

                if (layersPanel) layersPanel.style.height = panelHeight + 'px';
                if (colorPanel) colorPanel.style.height = panelHeight + 'px';

                // Make divider draggable
                if (divider1 && layersPanel && colorPanel) {
                    divider1.addEventListener('mousedown', (e) => {
                        this.isResizing = true;
                        this.activeDivider = divider1;
                        this.startY = e.clientY;
                        this.startHeight = parseInt(window.getComputedStyle(layersPanel).height);

                        document.body.style.cursor = 'row-resize';
                        document.body.style.userSelect = 'none';

                        e.preventDefault();
                    });

                    // Global resize handlers
                    document.addEventListener('mousemove', (e) => {
                        if (!this.isResizing || this.activeDivider !== divider1) return;

                        const deltaY = e.clientY - this.startY;
                        const newHeight1 = Math.max(50, this.startHeight + deltaY);
                        // Adjust second panel to fill remaining space
                        // Note: Flexbox usually handles the fill, but setting specific height might fight it.
                        // Ideally we rely on flex-grow, but since we're using explicit heights:
                        // Let's just update the first panel and let flex take care of the rest or update both.
                        // For simplicity in this existing system, we update both.
                        const sidebarRect = sidebar.getBoundingClientRect();
                        const availableHeight = sidebarRect.height - 12; // divider height
                        const newHeight2 = Math.max(50, availableHeight - newHeight1);

                        layersPanel.style.height = newHeight1 + 'px';
                        colorPanel.style.height = newHeight2 + 'px';

                        this.resizeCanvas();
                    });

                    document.addEventListener('mouseup', () => {
                        if (this.isResizing) {
                            this.isResizing = false;
                            this.activeDivider = null;
                            document.body.style.cursor = '';
                            document.body.style.userSelect = '';
                        }
                    });
                }

            }

            setupBottomPanel() {
                const setupPanel = () => {
                    const panel = document.getElementById('bottomPropertiesPanel');
                    const header = document.querySelector('#bottomPropertiesPanel .bottom-panel-header');
                    const toggleButton = document.getElementById('bottomPanelToggle');

                    if (!panel || !header || !toggleButton) {
                        // Retry if elements not found yet
                        setTimeout(setupPanel, 50);
                        return;
                    }

                    // Helper function to toggle the panel
                    const togglePanel = () => {
                        panel.classList.toggle('collapsed');
                        panel.classList.toggle('expanded');

                        // Animate resize during transition to prevent stretching/squashing
                        const startTime = Date.now();
                        const duration = 350; // Slightly longer than CSS to ensure we catch the end

                        const animateResize = () => {
                            // Synchronous update prevents white flash
                            // Update dimensions immediately
                            this.syncResize(true);
                            // Force redraw immediately
                            this.gridNeedsRedraw = true;
                            this.lastGridState = null;
                            this.render(true);

                            if (Date.now() - startTime < duration) {
                                requestAnimationFrame(animateResize);
                            } else {
                                // Final ensure of text/layout sharpness
                                this.resizeCanvas();
                            }
                        };

                        requestAnimationFrame(animateResize);
                    };

                    // Handle header click first - but ignore clicks on the button
                    header.addEventListener('click', (e) => {
                        // Check if the click originated from the button or its children
                        const clickedButton = e.target.closest('.bottom-panel-toggle') ||
                            e.target.closest('#bottomPanelToggle');
                        if (clickedButton || e.target === toggleButton) {
                            return; // Let button handler deal with it
                        }
                        e.preventDefault();
                        togglePanel();
                    });

                    // Handle button click - stop propagation so header doesn't also trigger
                    toggleButton.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        togglePanel();
                        return false;
                    });

                    // Also handle clicks on the toggle icon span inside the button
                    const toggleIcon = toggleButton.querySelector('.toggle-icon');
                    if (toggleIcon) {
                        toggleIcon.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            e.stopImmediatePropagation();
                            togglePanel();
                            return false;
                        });
                    }
                };

                // Try immediately, then with small delay if needed
                setupPanel();
            }

            setupCanvas() {
                this.resizeCanvas();
                // Note: Resize handler is managed in setupResponsiveHandlers to avoid duplicates
            }

            syncResize(compensatePan = false) {
                const rect = this.container.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;

                // First run initialization or check if update is needed
                if (!this.lastDimensions) {
                    this.lastDimensions = { width: rect.width, height: rect.height };

                    // Initialize canvas size
                    this.canvas.width = rect.width * dpr;
                    this.canvas.height = rect.height * dpr;
                    this.ctx.scale(dpr, dpr);
                    this.canvas.style.width = rect.width + 'px';
                    this.canvas.style.height = rect.height + 'px';
                    return true;
                }

                const oldCssHeight = this.lastDimensions.height;
                const newCssHeight = rect.height;
                const oldCssWidth = this.lastDimensions.width;
                const newCssWidth = rect.width;

                // Check if resize is needed (with small threshold for floating point jitter)
                if (Math.abs(oldCssHeight - newCssHeight) < 0.5 && Math.abs(oldCssWidth - newCssWidth) < 0.5) {
                    return false;
                }

                // Update canvas size
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;

                // Scale context to match device pixel ratio
                this.ctx.scale(dpr, dpr);

                // Set CSS size to maintain aspect ratio
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';

                // Adjust pan to maintain the visual position relative to Top Center.
                // ONLY apply compensation during intentional resize operations (panel toggle, window resize)
                // This prevents random pan drift when DOM updates cause micro layout shifts
                if (compensatePan && Math.abs(oldCssHeight - newCssHeight) > 1) {
                    this.pan.y = this.pan.y + (oldCssHeight - newCssHeight) / 2;
                }

                // Store new dimensions
                this.lastDimensions = { width: rect.width, height: rect.height };
                return true;
            }

            resizeCanvas() {
                // Use requestAnimationFrame for smooth resizing
                requestAnimationFrame(() => {
                    // This is an intentional resize, so compensate pan
                    const didResize = this.syncResize(true);
                    // Mark grid for redraw on resize
                    this.gridNeedsRedraw = true;
                    this.lastGridState = null;
                    // Only render if resize actually happened
                    if (didResize) {
                        this.render();
                    }
                });
            }

            setupEventListeners() {
                // Mouse events
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));
                this.canvas.addEventListener('dblclick', (e) => this.handleDoubleClick(e));

                // Touch events
                this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
                this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
                this.canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e));

                // Keyboard events
                document.addEventListener('keydown', (e) => this.handleKeyDown(e));
                document.addEventListener('keyup', (e) => this.handleKeyUp(e));

                // UI events
                document.getElementById('zoomIn').addEventListener('click', () => this.zoomIn());
                document.getElementById('zoomOut').addEventListener('click', () => this.zoomOut());
                document.getElementById('zoomReset').addEventListener('click', () => this.zoomReset());
                document.getElementById('fullscreenToggle').addEventListener('click', () => this.toggleFullscreen());

                // Fullscreen change event listeners (with browser prefixes)
                document.addEventListener('fullscreenchange', () => this.handleFullscreenChange());
                document.addEventListener('webkitfullscreenchange', () => this.handleFullscreenChange());
                document.addEventListener('mozfullscreenchange', () => this.handleFullscreenChange());
                document.addEventListener('MSFullscreenChange', () => this.handleFullscreenChange());

                // Visualizer toggles
                document.querySelectorAll('[data-viz]').forEach(item => {
                    item.addEventListener('click', () => {
                        const viz = item.dataset.viz;
                        if (this.visualizers.has(viz)) {
                            this.visualizers.delete(viz);
                            item.classList.remove('active');
                        } else {
                            this.visualizers.add(viz);
                            item.classList.add('active');
                        }
                        this.render(true); // Force render when toggling visualizers
                    });
                });
            }

            setupToolbar() {
                const tools = document.querySelectorAll('[data-tool]');
                tools.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const tool = btn.dataset.tool;

                        if (tool === 'undo') {
                            this.undo();
                        } else if (tool === 'redo') {
                            this.redo();
                        } else if (tool === 'save') {
                            this.save();
                        } else if (tool === 'load') {
                            this.load();
                        } else if (tool === 'reset') {
                            this.reset();
                        } else if (tool === 'combine') {
                            this.handleCombineToolClick();
                        } else if (tool === 'split') {
                            this.handleSplitToolClick();
                        } else {
                            // Tool selection
                            if (this.combineMode && tool !== 'combine') {
                                this.exitCombineMode();
                            }
                            if (this.splitMode && tool !== 'split') {
                                this.exitSplitMode();
                            }
                            tools.forEach(t => t.classList.remove('active'));
                            btn.classList.add('active');
                            this.currentTool = tool;
                            this.updateCursor();
                        }
                    });
                });

                // Setup Cancel Combine Button
                const cancelBtn = document.getElementById('cancelCombineBtn');
                if (cancelBtn) {
                    cancelBtn.addEventListener('click', () => {
                        this.exitCombineMode();
                        this.setTool('select');
                    });
                }

                // Setup Cancel Split Button
                const cancelSplitBtn = document.getElementById('cancelSplitBtn');
                if (cancelSplitBtn) {
                    cancelSplitBtn.addEventListener('click', () => {
                        this.exitSplitMode();
                        this.setTool('select');
                    });
                }

                // Setup Split Confirmation Modal Buttons
                const splitConfirmBtn = document.getElementById('splitConfirmSelectionBtnModal');
                if (splitConfirmBtn) {
                    splitConfirmBtn.addEventListener('click', () => {
                        const confirmModal = document.getElementById('splitConfirmSelectionModal');
                        if (confirmModal) confirmModal.style.display = 'none';

                        // Execute split setup
                        this.splitStep = 1; // Move to line drawing
                        this.updateSplitLineConstraint(this.selectedPolygon.getCenter()); // Init
                        this.render();
                    });
                }

                // Setup Reset Modal Buttons
                const resetModal = document.getElementById('resetModal');
                const confirmResetBtn = document.getElementById('confirmResetBtn');
                const cancelResetBtn = document.getElementById('cancelResetBtn');

                if (confirmResetBtn) {
                    confirmResetBtn.addEventListener('click', () => {
                        this.executeReset();
                        resetModal.style.display = 'none';
                    });
                }

                if (cancelResetBtn) {
                    cancelResetBtn.addEventListener('click', () => {
                        resetModal.style.display = 'none';
                    });
                }

                // Close reset modal on outside click
                if (resetModal) {
                    resetModal.addEventListener('click', (e) => {
                        if (e.target === resetModal) {
                            resetModal.style.display = 'none';
                        }
                    });
                }

                // Setup Split Confirmation Modal Buttons
                const confirmModal = document.getElementById('splitConfirmSelectionModal');
                const cancelSelBtn = document.getElementById('splitCancelSelectionBtn');
                const confirmSelBtn = document.getElementById('splitConfirmSelectionBtnModal');

                if (cancelSelBtn) {
                    cancelSelBtn.onclick = () => {
                        confirmModal.style.display = 'none';
                        this.selectedPolygon = null;
                        this.render();
                    };
                }

                if (confirmSelBtn) {
                    confirmSelBtn.onclick = () => {
                        confirmModal.style.display = 'none';
                        this.splitStep = 1; // Move to drawing line phase
                        this.updateSplitPrompt("Step 2: Draw a line across the polygon to split it.");
                        this.render();
                    };
                }
            }

            setupColorPicker() {
                const colorBtn = document.getElementById('toolbarColorBtn');
                const colorInput = document.getElementById('toolbarColorInput');

                if (colorBtn && colorInput) {
                    // Sync button color with current selection
                    const updateButtonColor = (color) => {
                        colorBtn.style.color = color;
                        // Optional: Add a small indicator or border
                        colorBtn.style.borderBottom = `3px solid ${color}`;
                    };

                    updateButtonColor(this.currentColor);

                    // When button is clicked, trigger the hidden color input
                    colorBtn.addEventListener('click', () => {
                        colorInput.click();
                    });

                    // Handle color change
                    colorInput.addEventListener('input', (e) => {
                        const color = e.target.value;
                        this.currentColor = color;
                        updateButtonColor(color);

                        if (this.selectedPolygon) {
                            this.selectedPolygon.color = color;
                            this.saveHistory();
                            this.render();
                            this.updateLayers(); // To update the color indicator in layers
                        }
                    });

                    // Also handle direct confirmation (change event)
                    colorInput.addEventListener('change', (e) => {
                        this.saveHistory(); // Ensure history is saved on final selection
                    });
                }
            }

            setupShapeMenu() {
                const modal = document.getElementById('createShapeModal');
                const createPolygonBtn = document.getElementById('createPolygonBtn');
                const toolbarCreateBtn = document.getElementById('toolbarCreateBtn');
                const closeBtn = document.getElementById('closeCreateShapeModal');

                // Open Modal
                const openMenu = () => this.openShapeMenu();
                if (createPolygonBtn) createPolygonBtn.addEventListener('click', openMenu);
                if (toolbarCreateBtn) toolbarCreateBtn.addEventListener('click', openMenu);

                // Close Modal with X button
                closeBtn.addEventListener('click', () => {
                    this.closeShapeMenu();
                });

                // Close Modal when clicking outside
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        this.closeShapeMenu();
                    }
                });

                // Handle shape selection
                document.querySelectorAll('.shape-option-card').forEach(option => {
                    option.addEventListener('click', (e) => {
                        this.selectShape(e.currentTarget);
                    });
                });
            }

            toggleShapeMenu() {
                const modal = document.getElementById('createShapeModal');
                if (modal.style.display === 'flex') {
                    this.closeShapeMenu();
                } else {
                    this.openShapeMenu();
                }
            }

            openShapeMenu() {
                const modal = document.getElementById('createShapeModal');
                modal.style.display = 'flex';
                this.shapeMenuOpen = true;

                if (this.telemetry.onShapeMenuOpen) {
                    this.telemetry.onShapeMenuOpen();
                }
            }

            closeShapeMenu() {
                const modal = document.getElementById('createShapeModal');
                modal.style.display = 'none';
                this.shapeMenuOpen = false;

                if (this.telemetry.onShapeMenuClose) {
                    this.telemetry.onShapeMenuClose();
                }
            }

            selectShape(option) {
                // simple debounce to prevent double-click creation
                const now = Date.now();
                if (now - this.lastShapeCreationTime < 500) return;
                this.lastShapeCreationTime = now;

                const shapeType = option.dataset.shape;
                const sides = parseInt(option.dataset.sides);

                // Get the center of the current viewport, snapped to grid
                const viewportCenter = this.getViewportCenter();
                const centerX = viewportCenter.x;
                const centerY = viewportCenter.y;

                // Create polygon based on shape type, centered on viewport
                let vertices;
                switch (shapeType) {
                    case 'triangle':
                        // Equilateral triangle, 60 units per side (snapped to grid)
                        const triSize = Math.round(60 / this.gridSize) * this.gridSize;
                        vertices = [
                            { x: centerX, y: centerY - triSize * 0.577 }, // Top vertex
                            { x: centerX - triSize * 0.5, y: centerY + triSize * 0.289 }, // Bottom left
                            { x: centerX + triSize * 0.5, y: centerY + triSize * 0.289 }  // Bottom right
                        ];
                        break;
                    case 'square':
                        // Square, 60 units per side (snapped to grid)
                        const squareSize = Math.round(60 / this.gridSize) * this.gridSize;
                        const halfSize = squareSize / 2;
                        vertices = [
                            { x: centerX - halfSize, y: centerY - halfSize },
                            { x: centerX + halfSize, y: centerY - halfSize },
                            { x: centerX + halfSize, y: centerY + halfSize },
                            { x: centerX - halfSize, y: centerY + halfSize }
                        ];
                        break;
                    case 'rectangle':
                        // Rectangle, 80x60 units (snapped to grid)
                        const rectWidth = Math.round(80 / this.gridSize) * this.gridSize;
                        const rectHeight = Math.round(60 / this.gridSize) * this.gridSize;
                        const halfWidth = rectWidth / 2;
                        const halfHeight = rectHeight / 2;
                        vertices = [
                            { x: centerX - halfWidth, y: centerY - halfHeight },
                            { x: centerX + halfWidth, y: centerY - halfHeight },
                            { x: centerX + halfWidth, y: centerY + halfHeight },
                            { x: centerX - halfWidth, y: centerY + halfHeight }
                        ];
                        break;
                    case 'pentagon':
                        vertices = this.createRegularPolygon(5, 50, centerX, centerY);
                        break;
                    case 'hexagon':
                        vertices = this.createRegularPolygon(6, 40, centerX, centerY);
                        break;
                    case 'heptagon':
                        vertices = this.createRegularPolygon(7, 35, centerX, centerY);
                        break;
                    case 'octagon':
                        vertices = this.createRegularPolygon(8, 30, centerX, centerY);
                        break;
                    default:
                        // Default to triangle
                        const defaultSize = Math.round(60 / this.gridSize) * this.gridSize;
                        vertices = [
                            { x: centerX, y: centerY - defaultSize * 0.577 },
                            { x: centerX - defaultSize * 0.5, y: centerY + defaultSize * 0.289 },
                            { x: centerX + defaultSize * 0.5, y: centerY + defaultSize * 0.289 }
                        ];
                }

                // Snap all vertices to grid to ensure perfect grid alignment
                vertices = vertices.map(v => this.snapToGrid(v));

                const polygon = new Polygon(vertices, this.currentColor);
                polygon.name = `${shapeType.charAt(0).toUpperCase() + shapeType.slice(1)} ${this.polygons.length + 1}`;
                this.polygons.push(polygon);
                this.selectedPolygon = polygon;
                this.saveHistory();
                this.updateProperties();
                this.updateLayers();
                this.render();

                this.closeShapeMenu();

                if (this.telemetry.onShapeSelect) {
                    this.telemetry.onShapeSelect({
                        type: shapeType,
                        sides: sides,
                        polygon: polygon
                    });
                }

                // Store last used shape
                localStorage.setItem('lastUsedShape', shapeType);
            }

            createRegularPolygon(sides, radius, centerX, centerY) {
                // Snap center to grid
                const snappedCenter = this.snapToGrid({ x: centerX, y: centerY });
                centerX = snappedCenter.x;
                centerY = snappedCenter.y;

                // Snap radius to grid for better alignment
                radius = Math.round(radius / this.gridSize) * this.gridSize;

                const vertices = [];
                const angleStep = (Math.PI * 2) / sides;

                for (let i = 0; i < sides; i++) {
                    const angle = i * angleStep - Math.PI / 2; // Start from top
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);

                    // Snap each vertex to grid for perfect alignment
                    vertices.push(this.snapToGrid({ x, y }));
                }

                return vertices;
            }

            setupLearnPanel() {
                const concepts = [
                    // Fundamentals
                    { title: 'Polygon', desc: 'A closed shape with straight sides. From Greek "poly" (many) and "gonia" (angle).', icon: 'â¬¡' },
                    { title: 'Vertex', desc: 'A corner point where two sides meet.', icon: 'â€¢' },
                    { title: 'Edge', desc: 'A line segment joining two vertices of a polygon.', icon: 'â•±' },
                    { title: 'Perimeter', desc: 'The total distance around the outside of a shape.', icon: 'ðŸ“' },
                    { title: 'Area', desc: 'The amount of space inside a 2D shape.', icon: 'â¬›' },
                    { title: 'Regular Polygon', desc: 'A polygon with all sides equal and all angles equal.', icon: 'ðŸ›‘' },
                    { title: 'Irregular Polygon', desc: 'A polygon where sides and/or angles are not all equal.', icon: 'ðŸ—ºï¸' },

                    // Angles & Geometry
                    { title: 'Interior Angle', desc: 'An angle inside the polygon at one of its vertices.', icon: 'âˆ ' },
                    { title: 'Exterior Angle', desc: 'The angle between a side of a polygon and an adjacent side extended outward.', icon: 'â†ªï¸' },
                    { title: 'Convex', desc: 'A polygon with no interior angle greater than 180Â°. All vertices point outwards.', icon: 'âºï¸' },
                    { title: 'Concave', desc: 'A polygon with at least one interior angle greater than 180Â°. Has a "cave" or dent.', icon: 'ðŸŒ™' },
                    { title: 'Diagonal', desc: 'A line segment connecting two non-adjacent vertices.', icon: 'âš¡' },
                    { title: 'Apothem', desc: 'A line from the center of a regular polygon perpendicular to a side.', icon: 'âŠ¥' },
                    { title: 'Radius', desc: 'A line from the center of a regular polygon to a vertex.', icon: 'â¨‚' },

                    // Triangles
                    { title: 'Triangle', desc: 'A polygon with 3 sides and 3 angles. Sum of angles is 180Â°.', icon: 'â–²' },
                    { title: 'Equilateral', desc: 'Triangle with all 3 sides equal and all angles 60Â°.', icon: 'â–³' },
                    { title: 'Isosceles', desc: 'Triangle with at least 2 sides equal.', icon: 'ðŸ“' },
                    { title: 'Scalene', desc: 'Triangle with no equal sides.', icon: 'ðŸ“' },
                    { title: 'Right Triangle', desc: 'Triangle with one 90Â° angle.', icon: 'âˆŸ' },
                    { title: 'Centroid', desc: 'The geometric center of a triangle, where medians meet.', icon: 'ðŸŽ¯' },
                    { title: 'Altitude', desc: 'Perpendicular line from a vertex to the opposite side (or its extension).', icon: 'âŠ¥' },
                    { title: 'Median', desc: 'Line from a vertex to the midpoint of the opposite side.', icon: 'â«–' },

                    // Quadrilaterals
                    { title: 'Quadrilateral', desc: 'A polygon with 4 sides and 4 angles. Sum of angles is 360Â°.', icon: 'â¬œ' },
                    { title: 'Square', desc: 'Regular quadrilateral with 4 equal sides and 4 right angles.', icon: 'â– ' },
                    { title: 'Rectangle', desc: 'Quadrilateral with 4 right angles. Opposite sides are equal.', icon: 'â–¬' },
                    { title: 'Rhombus', desc: 'Quadrilateral with 4 equal sides, but no right angles.', icon: 'ðŸ”¶' },
                    { title: 'Parallelogram', desc: 'Quadrilateral with 2 pairs of parallel sides.', icon: 'â–±' },
                    { title: 'Trapezoid', desc: 'Quadrilateral with at least 1 pair of parallel sides.', icon: 'â¢' },
                    { title: 'Kite', desc: 'Quadrilateral with 2 pairs of equal-length adjacent sides.', icon: 'ðŸª' },

                    // Other Polygons
                    { title: 'Pentagon', desc: 'A polygon with 5 sides. Sum of angles is 540Â°.', icon: 'â¬Ÿ' },
                    { title: 'Hexagon', desc: 'A polygon with 6 sides. Sum of angles is 720Â°.', icon: 'â¬¢' },
                    { title: 'Heptagon', desc: 'A polygon with 7 sides.', icon: 'â¬ ' },
                    { title: 'Octagon', desc: 'A polygon with 8 sides. Stop signs are regular octagons.', icon: 'ðŸ›‘' },
                    { title: 'Nonagon', desc: 'A polygon with 9 sides.', icon: 'â—‹' },
                    { title: 'Decagon', desc: 'A polygon with 10 sides.', icon: 'ðŸ”Ÿ' },
                    { title: 'Dodecagon', desc: 'A polygon with 12 sides.', icon: 'ðŸ•›' },
                    { title: 'n-gon', desc: 'A polygon with n sides.', icon: 'â™¾ï¸' }
                ];

                const panel = document.getElementById('learnPageContent');
                concepts.forEach(concept => {
                    const item = document.createElement('div');
                    item.className = 'learn-card';
                    item.innerHTML = `
                            <div class="learn-card-title">
                                ${concept.title}
                                <div class="learn-card-icon">${concept.icon}</div>
                            </div>
                            <div class="learn-card-desc">${concept.desc}</div>
                        `;
                    // item.addEventListener('click', () => this.highlightConcept(concept.title)); // Optional: close and highlight
                    panel.appendChild(item);
                });

                this.setupLearnPageToggles();
            }

            setupLearnPageToggles() {
                const openBtn = document.getElementById('openLearnPageBtn');
                const closeBtn = document.getElementById('closeLearnPageBtn');
                const learnPage = document.getElementById('learnPage');

                openBtn.addEventListener('click', () => {
                    learnPage.classList.add('active');
                    // Hide scroll on main body to prevent scrolling background
                    document.body.style.overflow = 'hidden';
                });

                const closePage = () => {
                    learnPage.classList.remove('active');
                    document.body.style.overflow = '';
                };

                closeBtn.addEventListener('click', closePage);

                // Optional: Close on Esc
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && learnPage.classList.contains('active')) {
                        closePage();
                    }
                });
            }

            // Calculate the centroid (geometric center) of a polygon
            getPolygonCenter(polygon) {
                if (!polygon || !polygon.vertices || polygon.vertices.length === 0) {
                    return { x: 0, y: 0 };
                }
                const sum = polygon.vertices.reduce((acc, v) => ({ x: acc.x + v.x, y: acc.y + v.y }), { x: 0, y: 0 });
                return {
                    x: sum.x / polygon.vertices.length,
                    y: sum.y / polygon.vertices.length
                };
            }

            // Center the view on a specific world coordinate
            centerViewOn(worldX, worldY) {
                // To center world point (worldX, worldY) at viewport center:
                // Viewport center in world coords = screenToWorld(cssWidth/2, cssHeight/2)
                // We want: screenToWorld(cssWidth/2, cssHeight/2) = (worldX, worldY)
                // From screenToWorld: (cssWidth/2 - cssWidth/2 - pan.x) / zoom = worldX
                // So: -pan.x / zoom = worldX
                // Therefore: pan.x = -worldX * zoom
                // Similarly: pan.y = -worldY * zoom
                const rect = this.canvas.getBoundingClientRect();
                const cssWidth = rect.width;
                const cssHeight = rect.height;

                // Calculate pan needed to center the world point at viewport center
                this.pan.x = -worldX * this.zoom;
                this.pan.y = -worldY * this.zoom;
            }

            createSamplePolygon() {
                // Reset pan and zoom to ensure consistent initial state
                // World origin (0,0) appears at screen center when pan is (0,0) and zoom is 1
                this.pan = { x: 0, y: 0 };
                this.zoom = 1;

                // Create a triangle at world origin (0,0) snapped to grid
                // The triangle will be centered on the screen since pan is (0,0)
                const centerX = 0;
                const centerY = 0;

                // Equilateral triangle, 60 units per side (snapped to grid)
                const triSize = Math.round(60 / this.gridSize) * this.gridSize;
                const vertices = [
                    { x: centerX, y: centerY - triSize * 0.577 }, // Top vertex
                    { x: centerX - triSize * 0.5, y: centerY + triSize * 0.289 }, // Bottom left
                    { x: centerX + triSize * 0.5, y: centerY + triSize * 0.289 }  // Bottom right
                ].map(v => this.snapToGrid(v));

                const triangle = new Polygon(vertices, this.currentColor);
                triangle.name = 'Triangle 1';
                this.polygons.push(triangle);

                // Select the default polygon so properties are visible immediately
                this.selectedPolygon = triangle;

                // Mark grid for redraw since we changed selection
                this.markGridForRedraw();

                this.saveHistory();
                this.updateProperties();
                this.updateLayers();
            }

            handleCombineToolClick() {
                if (this.combineMode) {
                    // Second click: Execute Combine
                    this.executeCombine();
                } else {
                    // First click: Enter Selection Mode
                    if (localStorage.getItem('hideCombineWarning') === 'true') {
                        this.enterCombineMode();
                    } else {
                        this.showCombineModal();
                    }
                }
            }

            showCombineModal() {
                const modal = document.getElementById('combineModal');
                const continueBtn = document.getElementById('combineContinueBtn');
                const checkbox = document.getElementById('combineDontShowAgain');

                modal.style.display = 'flex';

                // One-time listener setup (or remove old ones to be safe, but simple is ok here)
                continueBtn.onclick = () => {
                    if (checkbox.checked) {
                        localStorage.setItem('hideCombineWarning', 'true');
                    }
                    modal.style.display = 'none';
                    this.enterCombineMode();
                };

                // Close on outside click? Maybe not for this specific modal flow.
            }

            enterCombineMode() {
                this.combineMode = true;
                this.combineSelection.clear();
                // Reset cycling state for fresh start
                this.combineLastClickPos = null;
                this.combineLastClickTime = 0;
                this.combineCycleIndex = 0;
                this.setTool('combine'); // Visual update for button

                // Update button text or style to indicate "Execute"
                const btn = document.querySelector('[data-tool="combine"]');
                if (btn) {
                    btn.textContent = 'Execute Combine';
                    btn.classList.add('active');
                    btn.style.background = 'linear-gradient(135deg, #f6ad55 0%, #ed8936 100%)';
                    btn.style.color = 'white';
                }

                // Show Cancel button
                const cancelBtn = document.getElementById('cancelCombineBtn');
                if (cancelBtn) {
                    cancelBtn.style.display = 'flex';
                }

                this.selectedPolygon = null;
                this.selectedVertex = null;
                this.render();
            }

            exitCombineMode() {
                this.combineMode = false;
                this.combineSelection.clear();

                const btn = document.querySelector('[data-tool="combine"]');
                if (btn) {
                    btn.textContent = 'Combine';
                    btn.classList.remove('active');
                    btn.style.background = '';
                    btn.style.color = '';
                }

                // Hide Cancel button
                const cancelBtn = document.getElementById('cancelCombineBtn');
                if (cancelBtn) {
                    cancelBtn.style.display = 'none';
                }

                this.render();
            }

            executeCombine() {
                if (this.combineSelection.size < 2) {
                    const errorModal = document.getElementById('combineSelectionModal');
                    if (errorModal) {
                        errorModal.style.display = 'flex';
                    }
                    return;
                }

                const polygonsToCombine = Array.from(this.combineSelection);

                // Validate that all polygons to combine still exist in the main array
                const validPolygons = polygonsToCombine.filter(p => this.polygons.includes(p));
                if (validPolygons.length !== polygonsToCombine.length) {
                    console.warn('Some polygons to combine are no longer in the array');
                    alert('Error: Some selected polygons are no longer available. Please try again.');
                    this.exitCombineMode();
                    return;
                }

                // CRITICAL SAFETY: Deep clone the ENTIRE state before ANY operation
                // This allows complete restoration if anything goes wrong
                const stateBackup = {
                    polygons: this.polygons.map(p => ({
                        vertices: p.vertices.map(v => ({ x: v.x, y: v.y })),
                        color: p.color,
                        name: p.name,
                        visible: p.visible
                    })),
                    selectedPolygonName: this.selectedPolygon ? this.selectedPolygon.name : null,
                    combineSelectionNames: polygonsToCombine.map(p => p.name)
                };

                try {
                    // STEP 1: Try to compute union
                    let unionResultVertices = null;
                    let unionError = null;

                    try {
                        unionResultVertices = PolygonBoolean.union(polygonsToCombine);
                    } catch (e) {
                        unionError = e;
                        console.error('Union computation error:', e);
                    }

                    // STEP 2: Validate union result
                    const isValidUnion = unionResultVertices &&
                        Array.isArray(unionResultVertices) &&
                        unionResultVertices.length >= 3 &&
                        unionResultVertices.every(v =>
                            v &&
                            typeof v.x === 'number' &&
                            typeof v.y === 'number' &&
                            isFinite(v.x) &&
                            isFinite(v.y)
                        );

                    if (!isValidUnion) {
                        // Union failed - try convex hull fallback for overlapping polygons
                        console.warn('Standard union failed, trying convex hull fallback');

                        // Collect all vertices from all polygons to combine
                        const allVertices = [];
                        for (const poly of polygonsToCombine) {
                            for (const v of poly.vertices) {
                                allVertices.push({ x: v.x, y: v.y });
                            }
                        }

                        // Check if polygons actually overlap or touch
                        let polygonsOverlap = false;
                        outer: for (let i = 0; i < polygonsToCombine.length; i++) {
                            for (let j = i + 1; j < polygonsToCombine.length; j++) {
                                const polyA = polygonsToCombine[i];
                                const polyB = polygonsToCombine[j];
                                // Check if any vertex of one is inside the other
                                for (const v of polyA.vertices) {
                                    if (polyB.containsPoint(v)) {
                                        polygonsOverlap = true;
                                        break outer;
                                    }
                                }
                                for (const v of polyB.vertices) {
                                    if (polyA.containsPoint(v)) {
                                        polygonsOverlap = true;
                                        break outer;
                                    }
                                }
                                // Check for edge intersections
                                for (let a = 0; a < polyA.vertices.length; a++) {
                                    const a1 = polyA.vertices[a];
                                    const a2 = polyA.vertices[(a + 1) % polyA.vertices.length];
                                    for (let b = 0; b < polyB.vertices.length; b++) {
                                        const b1 = polyB.vertices[b];
                                        const b2 = polyB.vertices[(b + 1) % polyB.vertices.length];
                                        if (this.segmentsIntersect(a1, a2, b1, b2)) {
                                            polygonsOverlap = true;
                                            break outer;
                                        }
                                    }
                                }
                            }
                        }

                        if (!polygonsOverlap) {
                            // Polygons don't overlap - can't combine
                            if (unionError) {
                                alert('Error combining polygons: ' + (unionError.message || unionError.toString()));
                            } else {
                                alert('Could not combine polygons. Ensure they overlap or touch to form a valid shape.');
                            }
                            return; // Early return - no state was modified
                        }

                        // Create convex hull as fallback
                        unionResultVertices = this.computeConvexHull(allVertices);

                        if (!unionResultVertices || unionResultVertices.length < 3) {
                            alert('Could not combine polygons. The union operation failed.');
                            return; // Early return - no state was modified
                        }

                        console.log('Using convex hull fallback for combine');
                    }

                    // STEP 3: Validate polygon area
                    const area = Math.abs(PolygonBoolean.getArea(unionResultVertices));
                    if (!isFinite(area) || area < 1e-6) {
                        console.warn('Combined polygon would be degenerate', { area });
                        alert('Combined polygon would be too small or invalid.');
                        return; // Early return - no state was modified
                    }

                    // STEP 4: Create new polygon
                    const newPoly = new Polygon(unionResultVertices, this.currentColor);
                    newPoly.name = 'Combined Polygon ' + (this.polygons.length + 1);

                    if (!newPoly.vertices || newPoly.vertices.length < 3) {
                        console.error('New polygon creation failed');
                        alert('Error: Could not create combined polygon.');
                        return; // Early return - no state was modified
                    }

                    // STEP 5: NOW save history - we're about to modify state
                    // This saves the CURRENT state (before combine) for undo to return to
                    this.saveHistory();

                    // STEP 6: Modify state atomically
                    const polygonsToRemove = new Set(this.combineSelection);
                    const originalLength = this.polygons.length;
                    this.polygons = this.polygons.filter(p => !polygonsToRemove.has(p));
                    this.polygons.push(newPoly);

                    // STEP 7: Verify modification was correct
                    const expectedLength = originalLength - polygonsToRemove.size + 1;
                    if (this.polygons.length !== expectedLength) {
                        throw new Error(`Polygon count mismatch after combine: expected ${expectedLength}, got ${this.polygons.length}`);
                    }

                    // STEP 8: Save new state for redo functionality
                    // This saves the COMBINED result so redo can restore it
                    this.saveHistory();

                    // STEP 9: Update UI
                    this.selectedPolygon = newPoly;
                    this.updateProperties();
                    this.updateLayers();
                    this.exitCombineMode();
                    this.setTool('select');
                    this.render();

                    console.log('Combine successful', {
                        removedCount: polygonsToRemove.size,
                        newPolygonVertices: newPoly.vertices.length,
                        totalPolygons: this.polygons.length
                    });

                } catch (e) {
                    console.error('Critical error in executeCombine:', e);

                    // CRITICAL: Restore state from backup
                    console.log('Restoring state from backup...');
                    this.polygons = stateBackup.polygons.map(p => {
                        const poly = new Polygon(p.vertices, p.color);
                        poly.name = p.name;
                        poly.visible = p.visible;
                        return poly;
                    });

                    // Try to restore selection
                    if (stateBackup.selectedPolygonName) {
                        this.selectedPolygon = this.polygons.find(p => p.name === stateBackup.selectedPolygonName) || null;
                    } else {
                        this.selectedPolygon = null;
                    }

                    this.updateProperties();
                    this.updateLayers();
                    this.render();

                    alert('Error combining polygons. Your original shapes have been restored.');
                }
            }

            // Helper: Check if two line segments intersect
            segmentsIntersect(p1, p2, p3, p4) {
                const d1 = this.direction(p3, p4, p1);
                const d2 = this.direction(p3, p4, p2);
                const d3 = this.direction(p1, p2, p3);
                const d4 = this.direction(p1, p2, p4);

                if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&
                    ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) {
                    return true;
                }

                const eps = 1e-9;
                if (Math.abs(d1) < eps && this.onSegment(p3, p4, p1)) return true;
                if (Math.abs(d2) < eps && this.onSegment(p3, p4, p2)) return true;
                if (Math.abs(d3) < eps && this.onSegment(p1, p2, p3)) return true;
                if (Math.abs(d4) < eps && this.onSegment(p1, p2, p4)) return true;

                return false;
            }

            direction(a, b, c) {
                return (c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y);
            }

            onSegment(a, b, c) {
                return c.x >= Math.min(a.x, b.x) - 1e-9 && c.x <= Math.max(a.x, b.x) + 1e-9 &&
                    c.y >= Math.min(a.y, b.y) - 1e-9 && c.y <= Math.max(a.y, b.y) + 1e-9;
            }

            // Helper: Compute convex hull using Graham scan
            computeConvexHull(points) {
                if (!points || points.length < 3) return null;

                // Remove duplicates
                const unique = [];
                const seen = new Set();
                for (const p of points) {
                    const key = `${Math.round(p.x * 1000)},${Math.round(p.y * 1000)}`;
                    if (!seen.has(key)) {
                        seen.add(key);
                        unique.push({ x: p.x, y: p.y });
                    }
                }

                if (unique.length < 3) return null;

                // Find bottom-most point (or left-most in case of tie)
                let start = 0;
                for (let i = 1; i < unique.length; i++) {
                    if (unique[i].y < unique[start].y ||
                        (unique[i].y === unique[start].y && unique[i].x < unique[start].x)) {
                        start = i;
                    }
                }

                const pivot = unique[start];

                // Sort by polar angle
                const sorted = unique.filter((_, i) => i !== start).sort((a, b) => {
                    const angleA = Math.atan2(a.y - pivot.y, a.x - pivot.x);
                    const angleB = Math.atan2(b.y - pivot.y, b.x - pivot.x);
                    if (Math.abs(angleA - angleB) < 1e-9) {
                        const distA = (a.x - pivot.x) ** 2 + (a.y - pivot.y) ** 2;
                        const distB = (b.x - pivot.x) ** 2 + (b.y - pivot.y) ** 2;
                        return distA - distB;
                    }
                    return angleA - angleB;
                });

                const hull = [{ x: pivot.x, y: pivot.y }];
                for (const p of sorted) {
                    while (hull.length > 1) {
                        const a = hull[hull.length - 2];
                        const b = hull[hull.length - 1];
                        const cross = (b.x - a.x) * (p.y - a.y) - (b.y - a.y) * (p.x - a.x);
                        if (cross <= 0) break;
                        hull.pop();
                    }
                    hull.push({ x: p.x, y: p.y });
                }

                return hull.length >= 3 ? hull : null;
            }

            // Helper function to restore polygons from backup
            restorePolygonsFromBackup(backup) {
                this.polygons = backup.map(p => {
                    const poly = new Polygon(p.vertices, p.color);
                    poly.name = p.name;
                    poly.visible = p.visible;
                    return poly;
                });
                this.render();
            }

            handleSplitToolClick() {
                if (this.splitMode) {
                    // Second click: Execute Split
                    this.executeSplit();
                } else {
                    // First click: Enter Split Mode
                    if (localStorage.getItem('hideSplitWarning') === 'true') {
                        this.enterSplitMode();
                    } else {
                        this.showSplitModal();
                    }
                }
            }

            showSplitModal() {
                const modal = document.getElementById('splitModal');
                const continueBtn = document.getElementById('splitContinueBtn');
                const checkbox = document.getElementById('splitDontShowAgain');

                modal.style.display = 'flex';

                // One-time listener setup
                continueBtn.onclick = () => {
                    if (checkbox.checked) {
                        localStorage.setItem('hideSplitWarning', 'true');
                    }
                    modal.style.display = 'none';
                    this.enterSplitMode();
                };
            }

            enterSplitMode() {
                this.splitMode = true;
                this.splitStep = 0; // 0: Select Polygon
                this.splitLineStart = null;
                this.splitLineEnd = null;
                this.splitLineType = 'free';
                this.setTool('split');
                this.selectedPolygon = null; // Clear selection on entry

                // Update button text
                const btn = document.querySelector('[data-tool="split"]');
                if (btn) {
                    btn.textContent = 'Execute Split';
                    btn.classList.add('active');
                    btn.style.background = 'linear-gradient(135deg, #f6ad55 0%, #ed8936 100%)';
                    btn.style.color = 'white';
                    btn.style.display = 'none'; // Only show when line is ready
                }

                const cancelBtn = document.getElementById('cancelSplitBtn');
                if (cancelBtn) cancelBtn.style.display = 'flex';

                this.updateSplitPrompt("Step 1: Click on the polygon you want to split.");
                this.selectedVertex = null;

                // Removed visual controls (Free, Horizontal, etc) as per user request
                // Defaulting to free split which is already set by this.splitLineType = 'free';

                this.render();
            }

            exitSplitMode() {
                this.splitMode = false;
                this.splitStep = 0;
                this.splitLineStart = null;
                this.splitLineEnd = null;

                const btn = document.querySelector('[data-tool="split"]');
                if (btn) {
                    btn.textContent = 'Split';
                    btn.classList.remove('active');
                    btn.style.background = '';
                    btn.style.color = '';
                    btn.style.display = 'flex';
                }

                const confirmBtn = document.getElementById('splitConfirmSelectionBtn');
                if (confirmBtn) confirmBtn.style.display = 'none';

                const cancelBtn = document.getElementById('cancelSplitBtn');
                if (cancelBtn) cancelBtn.style.display = 'none';

                // No longer handling splitControls as they are not created

                const prompt = document.getElementById('splitPrompt');
                if (prompt) prompt.remove();

                this.render();
            }

            updateSplitPrompt(text) {
                let prompt = document.getElementById('splitPrompt');
                if (!prompt) {
                    prompt = document.createElement('div');
                    prompt.id = 'splitPrompt';
                    prompt.style.cssText = `
                        position: absolute;
                        top: 130px; /* Moved down to avoid toolbar overlap */
                        left: 50%;
                        transform: translateX(-50%);
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        color: white;
                        padding: 10px 20px;
                        border-radius: 20px;
                        font-size: 14px;
                        font-weight: 600;
                        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                        z-index: 1000;
                        pointer-events: none;
                        white-space: nowrap;
                        animation: fadeIn 0.3s ease-out;
                        max-width: 90%;
                        overflow: hidden;
                        text-overflow: ellipsis;
                        text-align: center;
                    `;
                    document.querySelector('.canvas-container').appendChild(prompt);
                }
                prompt.textContent = text;
            }

            executeSplit() {
                if (!this.splitLineStart || !this.splitLineEnd) {
                    alert('Please draw a line to split polygons.');
                    return;
                }

                let splitHappened = false;
                const newPolygons = [];
                const toRemove = [];

                // If a polygon is selected, target it specifically
                // Otherwise, split any polygon intersected by the line
                const targetList = this.selectedPolygon ? [this.selectedPolygon] : this.polygons;

                for (let poly of targetList) {
                    if (!poly.visible) continue;

                    const pieces = PolygonBoolean.split(poly, this.splitLineStart, this.splitLineEnd);
                    if (pieces && pieces.length > 1) {
                        splitHappened = true;
                        toRemove.push(poly);

                        pieces.forEach((pts, idx) => {
                            const newPoly = new Polygon(pts, poly.color);
                            newPoly.name = `${poly.name} Part ${idx + 1}`;
                            newPolygons.push(newPoly);
                        });
                    }
                }

                if (splitHappened) {
                    this.polygons = this.polygons.filter(p => !toRemove.includes(p));
                    this.polygons.push(...newPolygons);

                    // Deselect the target polygon to avoid stale references
                    this.selectedPolygon = null;
                    this.selectedVertex = null;

                    this.saveHistory();
                    this.updateProperties();
                    this.updateLayers();
                    this.exitSplitMode();
                    this.setTool('select');
                } else {
                    alert('No polygons were intersected by the split line.');
                }
            }

            updateSplitLineConstraint(pos) {
                if (!this.splitLineStart) return;

                let newEnd = { ...pos };

                if (this.splitLineType === 'horizontal') {
                    newEnd.y = this.splitLineStart.y;
                } else if (this.splitLineType === 'vertical') {
                    newEnd.x = this.splitLineStart.x;
                } else if (this.splitLineType === 'diagonal') { // Optional: 45 degree snap? Or simply free/diagonal as requested
                    // If "Diagonal" implies 45 degrees specifically:
                    const dx = pos.x - this.splitLineStart.x;
                    const dy = pos.y - this.splitLineStart.y;
                    const absDx = Math.abs(dx);
                    const absDy = Math.abs(dy);

                    // Snap to nearest 45
                    if (absDx > absDy) {
                        // Closer to horizontal, but force diagonal?
                        // Or just force 1:1 aspect ratio
                        newEnd.y = this.splitLineStart.y + Math.sign(dy) * absDx;
                    } else {
                        newEnd.x = this.splitLineStart.x + Math.sign(dx) * absDy;
                    }
                }

                this.splitLineEnd = newEnd;
            }

            // Canvas coordinate helpers
            screenToWorld(x, y) {
                // Use CSS dimensions for coordinate conversion
                const rect = this.canvas.getBoundingClientRect();
                const cssWidth = rect.width;
                const cssHeight = rect.height;
                return {
                    x: (x - cssWidth / 2 - this.pan.x) / this.zoom,
                    y: (y - cssHeight / 2 - this.pan.y) / this.zoom
                };
            }

            worldToScreen(x, y) {
                // Use CSS dimensions for coordinate conversion
                const rect = this.canvas.getBoundingClientRect();
                const cssWidth = rect.width;
                const cssHeight = rect.height;
                return {
                    x: x * this.zoom + cssWidth / 2 + this.pan.x,
                    y: y * this.zoom + cssHeight / 2 + this.pan.y
                };
            }

            snapToGrid(point) {
                if (!this.gridSnap || !point) return point;

                // Validate gridSize
                if (!this.gridSize || this.gridSize <= 0 || !isFinite(this.gridSize)) {
                    return point;
                }

                // Use epsilon for floating point precision to avoid rounding errors
                const epsilon = 1e-10;
                const gridSizeInv = 1 / this.gridSize;

                // Optimized snapping calculation
                const snappedX = Math.round((point.x + epsilon) * gridSizeInv) * this.gridSize;
                const snappedY = Math.round((point.y + epsilon) * gridSizeInv) * this.gridSize;

                // Round to avoid floating point artifacts (higher precision for better accuracy)
                return {
                    x: Math.round(snappedX * 10000) / 10000,
                    y: Math.round(snappedY * 10000) / 10000
                };
            }

            // Helper function to mark grid for redraw when state changes
            markGridForRedraw() {
                this.gridNeedsRedraw = true;
                this.lastGridState = null;
            }

            // Get the center of the current viewport in world coordinates, snapped to grid
            getViewportCenter() {
                // Get CSS dimensions (not device pixel dimensions)
                const rect = this.canvas.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;

                // Convert to world coordinates
                const worldCenter = this.screenToWorld(centerX, centerY);

                // Snap to grid
                return this.snapToGrid(worldCenter);
            }

            // Mouse/Touch handlers
            handleMouseDown(e) {
                // Prevent mouse events from firing immediately after touch events
                // This avoids double handling on touch devices
                const timeSinceLastTouch = Date.now() - this.lastTouchTime;
                if (timeSinceLastTouch < 500) {
                    return; // Ignore mouse event if it happened shortly after touch
                }

                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const worldPos = this.screenToWorld(x, y);
                const snappedPos = this.snapToGrid(worldPos);

                // Store initial click position for pan detection
                this.panStartPos = { x, y };

                if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
                    // Middle button or shift+left for panning
                    this.isPanning = true;
                    this.dragStart = { x, y };
                    this.canvas.style.cursor = 'grabbing';
                    return;
                }

                // Handle Split Mode Interaction
                if (this.splitMode && e.button === 0) {
                    if (this.splitStep === 0) {
                        // Step 0: Select Polygon
                        // Iterate backwards to pick top-most polygon
                        for (let i = this.polygons.length - 1; i >= 0; i--) {
                            const poly = this.polygons[i];
                            if (poly.visible && poly.containsPoint(snappedPos)) {
                                this.selectedPolygon = poly;
                                this.updateProperties();
                                this.updateLayers();
                                this.render();

                                // Show confirmation pop-up
                                const confirmModal = document.getElementById('splitConfirmSelectionModal');
                                if (confirmModal) {
                                    confirmModal.style.display = 'flex';
                                }
                                return;
                            }
                        }
                    } else if (this.splitStep === 1) {
                        // Step 1: Start drawing line
                        this.isDragging = true;
                        this.dragStart = { x, y };
                        this.splitLineStart = snappedPos;
                        this.splitLineEnd = snappedPos;

                        // Show Execute button once drawing starts
                        const btn = document.querySelector('[data-tool="split"]');
                        if (btn) btn.style.display = 'flex';
                    }
                    return;
                }

                // Handle Combine Mode Selection
                if (this.combineMode && e.button === 0) {
                    // Find all polygons under the click point
                    const polygonsAtPoint = [];
                    for (let i = this.polygons.length - 1; i >= 0; i--) {
                        const poly = this.polygons[i];
                        if (!poly.visible) continue;
                        if (poly.containsPoint(snappedPos)) {
                            polygonsAtPoint.push({ poly, index: i });
                        }
                    }

                    if (polygonsAtPoint.length > 0) {
                        const now = Date.now();
                        const CLICK_THRESHOLD = 500; // ms - time window for cycling
                        const DISTANCE_THRESHOLD = 20; // pixels - tolerance for same location

                        // Check if clicking same location within time window
                        let isSameLocation = false;
                        if (this.combineLastClickPos) {
                            const dx = snappedPos.x - this.combineLastClickPos.x;
                            const dy = snappedPos.y - this.combineLastClickPos.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            isSameLocation = distance < DISTANCE_THRESHOLD;
                        }

                        const isWithinTimeWindow = (now - this.combineLastClickTime) < CLICK_THRESHOLD;

                        if (isSameLocation && isWithinTimeWindow && polygonsAtPoint.length > 1) {
                            // Cycle to next polygon
                            this.combineCycleIndex = (this.combineCycleIndex + 1) % polygonsAtPoint.length;
                        } else {
                            // New location or timeout - reset to first polygon
                            this.combineCycleIndex = 0;
                        }

                        // Update tracking for next click
                        this.combineLastClickPos = { x: snappedPos.x, y: snappedPos.y };
                        this.combineLastClickTime = now;

                        // Get the polygon at current cycle index
                        const targetPoly = polygonsAtPoint[this.combineCycleIndex].poly;

                        // Toggle selection for the targeted polygon
                        if (this.combineSelection.has(targetPoly)) {
                            this.combineSelection.delete(targetPoly);
                        } else {
                            this.combineSelection.add(targetPoly);
                        }

                        this.render();
                        this.updateLayers(); // Update sidebar to reflect selection
                        return;
                    }
                    return; // Don't do normal selection in combine mode
                }

                // Check if click is outside any polygon (for panning)
                const clickedOnPolygon = this.isPointOnPolygon(snappedPos);

                // If clicking outside polygons and using select tool, enable pan mode
                if (!clickedOnPolygon && this.currentTool === 'select' && e.button === 0) {
                    // Set up for potential panning - will activate on mousemove if threshold is met
                    this.dragStart = { x, y };
                    this.canvas.style.cursor = 'grab';
                    return;
                }

                switch (this.currentTool) {
                    case 'select':
                        this.handleSelect(snappedPos);
                        break;
                }
            }

            // Check if a point is on any polygon or vertex
            isPointOnPolygon(pos) {
                // Check for vertex selection first (higher priority)
                for (let i = this.polygons.length - 1; i >= 0; i--) {
                    const poly = this.polygons[i];
                    if (!poly.visible) continue;
                    for (let j = 0; j < poly.vertices.length; j++) {
                        const vertex = poly.vertices[j];
                        const distance = this.distance(pos, vertex);
                        const threshold = Math.max(8, 20 / this.zoom);
                        if (distance < threshold) {
                            return true; // Clicked on a vertex
                        }
                    }
                }

                // Check for polygon selection
                for (let i = this.polygons.length - 1; i >= 0; i--) {
                    const poly = this.polygons[i];
                    if (!poly.visible) continue;
                    if (poly.containsPoint(pos)) {
                        return true; // Clicked on a polygon
                    }
                }

                return false; // Clicked on empty space
            }

            // Find polygon and vertex at a point (returns object with polygon and vertex or null)
            findPolygonAtPoint(pos) {
                // Check for vertex selection first (higher priority)
                for (let i = this.polygons.length - 1; i >= 0; i--) {
                    const poly = this.polygons[i];
                    if (!poly.visible) continue;
                    for (let j = 0; j < poly.vertices.length; j++) {
                        const vertex = poly.vertices[j];
                        const distance = this.distance(pos, vertex);
                        const threshold = Math.max(8, 20 / this.zoom);
                        if (distance < threshold) {
                            return { polygon: poly, vertex: vertex }; // Clicked on a vertex
                        }
                    }
                }

                // Check for polygon selection
                for (let i = this.polygons.length - 1; i >= 0; i--) {
                    const poly = this.polygons[i];
                    if (!poly.visible) continue;
                    if (poly.containsPoint(pos)) {
                        return { polygon: poly, vertex: null }; // Clicked on a polygon
                    }
                }

                return null; // Clicked on empty space
            }

            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const worldPos = this.screenToWorld(x, y);
                const snappedPos = this.snapToGrid(worldPos);

                // Update coordinate display (throttled for performance)
                const coordDisplay = document.getElementById('coordDisplay');
                if (coordDisplay) {
                    coordDisplay.textContent = `X: ${Math.round(snappedPos.x)}, Y: ${Math.round(snappedPos.y)}`;
                }

                // Handle Split Line Dragging
                if (this.splitMode && this.isDragging && this.splitStep === 1) {
                    if (this.splitLineStart) {
                        this.updateSplitLineConstraint(snappedPos);
                        this.render(true); // Force render during drag
                    }
                    return;
                }

                // Handle active panning (with early return)
                if (this.isPanning && this.dragStart) {
                    this.pan.x += x - this.dragStart.x;
                    this.pan.y += y - this.dragStart.y;
                    this.dragStart = { x, y };
                    this.canvas.style.cursor = 'grabbing';
                    // Mark grid for redraw on pan
                    this.gridNeedsRedraw = true;
                    this.render(true); // Force render during pan
                    return;
                }

                // Check if we should start panning from empty space click
                if (this.panStartPos && this.dragStart && !this.isDragging && !this.isPanning &&
                    this.currentTool === 'select' && !this.selectedPolygon) {
                    const moveDistance = Math.sqrt(
                        Math.pow(x - this.panStartPos.x, 2) +
                        Math.pow(y - this.panStartPos.y, 2)
                    );

                    // If moved beyond threshold, start panning
                    if (moveDistance > this.panThreshold) {
                        this.isPanning = true;
                        this.canvas.style.cursor = 'grabbing';
                    }
                }

                // Check if we should start dragging a selected polygon/vertex
                if (this.potentialDragStart && this.selectedPolygon && !this.isDragging && !this.isPanning) {
                    const worldMoveDistance = this.distance(snappedPos, this.potentialDragStart);

                    // Only start dragging after moving beyond threshold (in world units)
                    if (worldMoveDistance > this.dragThreshold) {
                        this.isDragging = true;
                        // Update dragStart to current position to prevent initial jump
                        this.dragStart = snappedPos;
                    }
                }


                if (this.isDragging && this.selectedVertex) {
                    // Update the vertex position directly
                    this.selectedVertex.x = snappedPos.x;
                    this.selectedVertex.y = snappedPos.y;
                    this.updateProperties();
                    this.render(true); // Force render during drag for responsiveness
                } else if (this.isDragging && this.selectedPolygon && !this.selectedVertex) {
                    const dx = snappedPos.x - this.dragStart.x;
                    const dy = snappedPos.y - this.dragStart.y;
                    this.selectedPolygon.move(dx, dy);
                    this.dragStart = snappedPos;
                    this.updateProperties();
                    this.render(true); // Force render during drag for responsiveness
                }
            }

            handleMouseUp(e) {
                // If we were panning, stop it
                if (this.isPanning) {
                    this.isPanning = false;
                    this.canvas.style.cursor = '';
                    this.updateCursor();
                }

                // If we clicked but didn't pan (clicked on empty space without dragging)
                if (this.panStartPos && !this.isPanning && !this.isDragging && this.currentTool === 'select') {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const moveDistance = Math.sqrt(
                        Math.pow(x - this.panStartPos.x, 2) +
                        Math.pow(y - this.panStartPos.y, 2)
                    );

                    // If we didn't move much, treat as a click to deselect
                    if (moveDistance <= this.panThreshold) {
                        const worldPos = this.screenToWorld(x, y);
                        const snappedPos = this.snapToGrid(worldPos);

                        // Only deselect if clicking on empty space
                        if (!this.isPointOnPolygon(snappedPos)) {
                            this.selectedPolygon = null;
                            this.selectedVertex = null;
                            this.updateProperties();
                            this.updateLayers();
                            this.render();
                        }
                    }
                }

                if (this.isDragging && (this.selectedVertex || this.selectedPolygon)) {
                    this.saveHistory();
                }

                this.isDragging = false;
                this.isPanning = false;
                this.dragStart = null;
                this.panStartPos = null;
                this.potentialDragStart = null;
            }

            handleWheel(e) {
                e.preventDefault();
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const worldBefore = this.screenToWorld(x, y);

                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                this.zoom = Math.max(0.1, Math.min(5, this.zoom * delta));

                const worldAfter = this.screenToWorld(x, y);

                this.pan.x += (worldAfter.x - worldBefore.x) * this.zoom;
                this.pan.y += (worldAfter.y - worldBefore.y) * this.zoom;

                // Mark grid for redraw on zoom/pan change
                this.gridNeedsRedraw = true;
                this.lastGridState = null; // Force grid state recalculation
                this.render(true); // Force render during zoom for smooth experience
            }

            handleDoubleClick(e) {
                // No double click actions
            }

            handleTouchStart(e) {
                e.preventDefault();
                e.stopPropagation();

                // Update last touch time to prevent mouse event conflicts
                this.lastTouchTime = Date.now();

                // COMPLETELY RESET all touch-related state for new touch
                // This prevents coordinate system confusion from previous touches
                this.isDragging = false;
                this.isPanning = false;
                this.touchGestureLocked = false;
                this.touchVelocity = { x: 0, y: 0 };
                this.touchLastMoveTime = Date.now();
                this.dragStart = null;
                this.panStartPos = null;
                this.touchStartPos = null;
                this.potentialDragStart = null;

                // Handle multi-touch for pan/zoom
                if (e.touches.length === 2) {
                    this.isPinching = true;
                    this.touchGestureLocked = true; // Lock to pinch gesture
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    this.pinchDistance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );
                    this.pinchZoom = this.zoom;
                    // Clear any selection when pinching
                    this.selectedPolygon = null;
                    this.selectedVertex = null;
                    return;
                }

                // Single touch
                const touch = e.touches[0];
                if (!touch) return;

                const rect = this.canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                const worldPos = this.screenToWorld(x, y);
                const snappedPos = this.snapToGrid(worldPos);

                // Store initial touch position for gesture detection
                // ALWAYS use screen coordinates for these initial positions
                this.panStartPos = { x, y }; // Screen coordinates - for panning
                this.touchStartTime = Date.now();
                this.touchStartPos = { x, y }; // Screen coordinates - for movement detection
                this.touchLastMoveTime = Date.now();

                // Handle Split Mode Interaction
                if (this.splitMode) {
                    if (this.splitStep === 0) {
                        // Step 0: Select Polygon
                        for (let i = this.polygons.length - 1; i >= 0; i--) {
                            const poly = this.polygons[i];
                            if (poly.visible && poly.containsPoint(snappedPos)) {
                                this.selectedPolygon = poly;
                                this.updateProperties();
                                this.updateLayers();
                                this.render();
                                const confirmModal = document.getElementById('splitConfirmSelectionModal');
                                if (confirmModal) {
                                    confirmModal.style.display = 'flex';
                                }
                                return;
                            }
                        }
                    } else if (this.splitStep === 1) {
                        // Step 1: Start drawing line
                        this.isDragging = true;
                        this.dragStart = { x, y };
                        this.splitLineStart = snappedPos;
                        this.splitLineEnd = snappedPos;
                        const btn = document.querySelector('[data-tool="split"]');
                        if (btn) btn.style.display = 'flex';
                    }
                    return;
                }

                // Handle Combine Mode Selection
                if (this.combineMode) {
                    for (let i = this.polygons.length - 1; i >= 0; i--) {
                        const poly = this.polygons[i];
                        if (!poly.visible) continue;
                        if (poly.containsPoint(snappedPos)) {
                            if (this.combineSelection.has(poly)) {
                                this.combineSelection.delete(poly);
                            } else {
                                this.combineSelection.add(poly);
                            }
                            this.render();
                            this.updateLayers();
                            return;
                        }
                    }
                    return;
                }

                // For select tool, immediately check if we hit a polygon
                if (this.currentTool === 'select') {
                    // Check if touch is directly on a polygon or vertex
                    const polygonHit = this.findPolygonAtPoint(snappedPos);

                    if (polygonHit) {
                        // Immediately select the polygon for instant feedback
                        this.selectedPolygon = polygonHit.polygon;
                        if (polygonHit.vertex) {
                            this.selectedVertex = polygonHit.vertex;
                            // Lock to drag gesture when touching vertex
                            this.touchGestureLocked = true;
                            // Immediately enable dragging for vertices - no threshold needed
                            this.isDragging = true;
                            // Use world coordinates for vertex dragging
                            this.dragStart = snappedPos; // World coordinates for vertex drag
                            this.potentialDragStart = snappedPos;
                            // panStartPos already set to screen coordinates above
                        } else {
                            this.selectedVertex = null;
                            // Prepare for potential drag, but wait for movement threshold
                            // Use world coordinates for polygon dragging
                            this.dragStart = snappedPos; // World coordinates for polygon drag
                            this.potentialDragStart = snappedPos;
                            // panStartPos already set to screen coordinates above
                            // Don't lock gesture yet - allow panning if moved far enough
                        }
                        this.updateProperties();
                        this.updateLayers();
                        this.render();
                        return;
                    } else {
                        // Touching empty space - prepare for panning, but allow quick tap to deselect
                        // Don't set dragStart here - it will be set when panning actually starts
                        // panStartPos already set to screen coordinates above
                        this.canvas.style.cursor = 'grab';
                        // Don't lock gesture - will determine based on movement
                        // Don't deselect immediately - wait for touch end to see if it's a tap
                    }
                }
            }

            handleTouchMove(e) {
                e.preventDefault();
                e.stopPropagation();

                // Handle pinch-to-zoom
                if (e.touches.length === 2 && this.isPinching) {
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    const distance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );

                    if (this.pinchDistance > 0) {
                        const scale = distance / this.pinchDistance;
                        this.zoom = Math.max(0.1, Math.min(5, this.pinchZoom * scale));
                        // Mark grid for redraw on zoom
                        this.gridNeedsRedraw = true;
                        this.lastGridState = null;
                        this.render(true); // Force render during pinch zoom for smooth experience
                    }
                    return;
                }

                // Single touch move
                const touch = e.touches[0];
                if (!touch) return;

                const rect = this.canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                const worldPos = this.screenToWorld(x, y);
                const snappedPos = this.snapToGrid(worldPos);

                // Calculate velocity for gesture detection
                // ALWAYS use screen coordinates (touchStartPos) for velocity calculation
                // Never use dragStart as it might be in world coordinates
                const now = Date.now();
                const timeDelta = Math.max(1, now - this.touchLastMoveTime);
                if (this.touchStartPos && timeDelta > 0) {
                    // Use touchStartPos which is always in screen coordinates
                    this.touchVelocity.x = (x - this.touchStartPos.x) / timeDelta;
                    this.touchVelocity.y = (y - this.touchStartPos.y) / timeDelta;
                }
                this.touchLastMoveTime = now;

                // Update coordinate display (throttled)
                const coordDisplay = document.getElementById('coordDisplay');
                if (coordDisplay) {
                    coordDisplay.textContent = `X: ${Math.round(snappedPos.x)}, Y: ${Math.round(snappedPos.y)}`;
                }

                // Calculate movement distance from touch start
                let moveDistance = 0;
                if (this.touchStartPos) {
                    moveDistance = Math.sqrt(
                        Math.pow(x - this.touchStartPos.x, 2) +
                        Math.pow(y - this.touchStartPos.y, 2)
                    );
                }

                // Handle Split Line Dragging
                if (this.splitMode && this.isDragging && this.splitStep === 1) {
                    if (this.splitLineStart) {
                        this.updateSplitLineConstraint(snappedPos);
                        this.render(true); // Force render during drag
                    }
                    return;
                }

                // Determine gesture type if not locked yet
                if (!this.touchGestureLocked && this.touchStartPos && moveDistance > 5) {
                    // Check if we should lock to pan or drag
                    if (this.selectedPolygon && !this.selectedVertex) {
                        // If touching a polygon (not vertex), allow both drag and pan
                        // Lock to drag if movement is small and consistent
                        if (moveDistance > this.touchDragThreshold && moveDistance < this.touchPanThreshold) {
                            this.touchGestureLocked = true;
                            this.isDragging = true;
                            // Ensure panStartPos is set for potential pan fallback
                            if (!this.panStartPos) {
                                this.panStartPos = { x, y };
                            }
                        } else if (moveDistance > this.touchPanThreshold) {
                            // Large movement - prefer panning unless clearly dragging polygon
                            const velocity = Math.sqrt(this.touchVelocity.x ** 2 + this.touchVelocity.y ** 2);
                            if (velocity < 0.5) { // Slow movement - likely dragging polygon
                                this.touchGestureLocked = true;
                                this.isDragging = true;
                                // Ensure panStartPos is set for potential pan fallback
                                if (!this.panStartPos) {
                                    this.panStartPos = { x, y };
                                }
                            } else {
                                // Fast movement - likely panning
                                this.touchGestureLocked = true;
                                this.isPanning = true;
                                this.isDragging = false;
                                // Clear polygon selection when switching to pan
                                this.selectedPolygon = null;
                                this.selectedVertex = null;
                                // Reset dragStart since we're switching to pan (different coordinate system)
                                this.dragStart = null;
                                // CRITICAL: Reset panStartPos to initial touch position to prevent jump
                                // This ensures smooth panning from the start point, not from current position
                                if (this.touchStartPos) {
                                    this.panStartPos = { x: this.touchStartPos.x, y: this.touchStartPos.y };
                                } else {
                                    // Fallback: use current position if touchStartPos somehow missing
                                    this.panStartPos = { x, y };
                                }
                                this.canvas.style.cursor = 'grabbing';
                            }
                        }
                    } else if (!this.selectedPolygon) {
                        // Empty space - lock to pan if moved enough
                        if (moveDistance > this.touchPanThreshold) {
                            this.touchGestureLocked = true;
                            this.isPanning = true;
                            // Clear any polygon-related drag state
                            this.dragStart = null;
                            // CRITICAL: Reset panStartPos to initial touch position to prevent jump
                            // This ensures smooth panning from the start point
                            if (this.touchStartPos) {
                                this.panStartPos = { x: this.touchStartPos.x, y: this.touchStartPos.y };
                            } else {
                                // Fallback: use current position if touchStartPos somehow missing
                                this.panStartPos = { x, y };
                            }
                            this.canvas.style.cursor = 'grabbing';
                        }
                    }
                }

                // Continue panning if active
                if (this.isPanning && this.panStartPos) {
                    // Use panStartPos which is always in screen coordinates
                    const dx = x - this.panStartPos.x;
                    const dy = y - this.panStartPos.y;

                    // Safety check: prevent huge jumps that indicate coordinate system error
                    // If delta is too large (>500px), something is wrong - reset panStartPos
                    const deltaMagnitude = Math.sqrt(dx * dx + dy * dy);
                    if (deltaMagnitude > 500) {
                        // Reset to current position to prevent jump
                        this.panStartPos = { x, y };
                        this.render(true);
                        return;
                    }

                    // Prevent extreme pan values that could cause viewport jumping
                    const maxPan = 10000; // Reasonable maximum pan value
                    const newPanX = this.pan.x + dx;
                    const newPanY = this.pan.y + dy;

                    // Clamp pan values to prevent viewport jumping
                    if (Math.abs(newPanX) < maxPan && Math.abs(newPanY) < maxPan) {
                        this.pan.x = newPanX;
                        this.pan.y = newPanY;
                    }

                    // Update panStartPos for next frame (screen coordinates)
                    this.panStartPos = { x, y };
                    // Mark grid for redraw on pan
                    this.gridNeedsRedraw = true;
                    this.render(true); // Force render during pan
                    return;
                }

                // Handle dragging selected polygon or vertex
                // For vertices, start dragging immediately when touched (no threshold)
                if (this.selectedVertex && this.touchGestureLocked) {
                    // Vertex dragging - update position directly
                    this.selectedVertex.x = snappedPos.x;
                    this.selectedVertex.y = snappedPos.y;
                    this.updateProperties();
                    this.render(true); // Force render during drag
                } else if (this.isDragging) {
                    if (this.selectedVertex) {
                        // Drag vertex (fallback - should be handled above)
                        this.selectedVertex.x = snappedPos.x;
                        this.selectedVertex.y = snappedPos.y;
                        this.updateProperties();
                        this.render(true); // Force render during drag
                    } else if (this.selectedPolygon && this.dragStart) {
                        // Drag polygon
                        const dx = snappedPos.x - this.dragStart.x;
                        const dy = snappedPos.y - this.dragStart.y;
                        this.selectedPolygon.move(dx, dy);
                        this.dragStart = snappedPos;
                        this.render(true); // Force render during drag
                    }
                }
            }

            handleTouchEnd(e) {
                e.preventDefault();
                e.stopPropagation();

                // Update last touch time
                this.lastTouchTime = Date.now();
                this.isPinching = false;

                // Handle touch end similar to mouse up
                if (this.isPanning) {
                    this.isPanning = false;
                    this.canvas.style.cursor = '';
                    this.updateCursor();
                }

                // Save history if we dragged something
                if (this.isDragging && (this.selectedVertex || this.selectedPolygon)) {
                    this.saveHistory();
                }

                // Calculate final movement distance
                let finalMoveDistance = 0;
                if (this.touchStartPos && e.changedTouches[0]) {
                    const touch = e.changedTouches[0];
                    const rect = this.canvas.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    finalMoveDistance = Math.sqrt(
                        Math.pow(x - this.touchStartPos.x, 2) +
                        Math.pow(y - this.touchStartPos.y, 2)
                    );
                }

                // If we tapped (didn't pan or drag), handle tap for deselection
                if (this.touchStartPos && !this.isPanning && !this.isDragging &&
                    this.currentTool === 'select' && finalMoveDistance <= this.touchTapThreshold) {
                    const touch = e.changedTouches[0];
                    if (touch) {
                        const rect = this.canvas.getBoundingClientRect();
                        const x = touch.clientX - rect.left;
                        const y = touch.clientY - rect.top;
                        const worldPos = this.screenToWorld(x, y);
                        const snappedPos = this.snapToGrid(worldPos);

                        // Check if tapping on empty space - if so, deselect and show grid clearly
                        const polygonHit = this.findPolygonAtPoint(snappedPos);
                        if (!polygonHit) {
                            // Tapped empty space - deselect everything and show grid
                            // IMPORTANT: Clear all drag/pan state before deselecting to prevent coordinate issues
                            this.isDragging = false;
                            this.isPanning = false;
                            this.dragStart = null;
                            this.panStartPos = null;
                            this.selectedPolygon = null;
                            this.selectedVertex = null;
                            this.updateProperties();
                            this.updateLayers();
                            this.render();
                            // Grid will automatically be visible since nothing is selected
                        }
                    }
                }

                // COMPLETELY RESET all touch state to prevent any residual state
                // This is critical to prevent coordinate system confusion on next touch
                this.isDragging = false;
                this.isPanning = false;
                this.dragStart = null;
                this.panStartPos = null;
                this.touchStartTime = null;
                this.touchStartPos = null;
                this.touchGestureLocked = false;
                this.touchVelocity = { x: 0, y: 0 };
                this.touchLastMoveTime = 0;
                this.potentialDragStart = null;
            }

            handleKeyDown(e) {
                // Handle F11 for fullscreen toggle
                if (e.key === 'F11') {
                    e.preventDefault(); // Prevent browser default and use our handler for consistency
                    this.toggleFullscreen();
                    return;
                }
                // Quick shape creation shortcuts when menu is open
                if (this.shapeMenuOpen) {
                    const shortcutMap = {
                        't': 'triangle',
                        's': 'square',
                        'r': 'rectangle',
                        'p': 'pentagon',
                        'h': 'hexagon',
                        '7': 'heptagon',
                        'o': 'octagon'
                    };

                    const key = e.key.toLowerCase();
                    if (shortcutMap[key]) {
                        e.preventDefault();
                        const option = document.querySelector(`[data-shape="${shortcutMap[key]}"]`);
                        if (option) this.selectShape(option);
                        return;
                    }
                }

                switch (e.key.toLowerCase()) {
                    case 's':
                        if (!e.ctrlKey && !this.shapeMenuOpen) this.setTool('select');
                        break;
                    case 'z':
                        if (e.ctrlKey) this.undo();
                        break;
                    case 'y':
                        if (e.ctrlKey) this.redo();
                        break;
                    case 'delete':
                        this.deleteSelected();
                        break;
                    case 'escape':
                        this.cancelCurrentAction();
                        break;
                    case ' ':
                        e.preventDefault();
                        this.isPanning = true;
                        this.canvas.style.cursor = 'grab';
                        break;
                }
            }

            handleKeyUp(e) {
                if (e.key === ' ') {
                    this.isPanning = false;
                    this.updateCursor();
                }
            }

            handleSelect(pos) {
                this.selectedVertex = null;
                this.selectedPolygon = null;

                // Check for vertex selection first (higher priority)
                // Iterate backwards to select from top-most polygons first
                for (let i = this.polygons.length - 1; i >= 0; i--) {
                    const poly = this.polygons[i];
                    if (!poly.visible) continue; // Skip invisible polygons
                    for (let j = 0; j < poly.vertices.length; j++) {
                        const vertex = poly.vertices[j];
                        const distance = this.distance(pos, vertex);

                        // Make sure we're using a reasonable threshold that works at all zoom levels
                        // Use a dynamic threshold that's large enough to be easily clickable
                        const threshold = Math.max(8, 20 / this.zoom);

                        if (distance < threshold) {
                            this.selectedPolygon = poly;
                            this.selectedVertex = vertex;
                            // Don't set isDragging=true yet - wait for actual mouse movement
                            this.potentialDragStart = pos;
                            this.dragStart = pos;
                            this.updateProperties();
                            this.updateLayers();
                            this.render();
                            return;
                        }
                    }
                }

                // Check for polygon selection
                // Iterate backwards to select top-most polygon first
                for (let i = this.polygons.length - 1; i >= 0; i--) {
                    const poly = this.polygons[i];
                    if (!poly.visible) continue; // Skip invisible polygons
                    if (poly.containsPoint(pos)) {
                        this.selectedPolygon = poly;
                        // Don't set isDragging=true yet - wait for actual mouse movement
                        this.potentialDragStart = pos;
                        this.dragStart = pos;
                        this.updateProperties();
                        this.updateLayers();
                        this.render();
                        return;
                    }
                }

                this.updateProperties();
                this.updateLayers();
                this.render();
            }

            // Geometry calculations
            distance(p1, p2) {
                return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
            }

            // UI Updates
            updateCursor() {
                // Don't override grab/grabbing cursors during panning
                if (this.isPanning) {
                    this.canvas.style.cursor = 'grabbing';
                    return;
                }

                const cursors = {
                    'select': 'default',
                };
                this.canvas.style.cursor = cursors[this.currentTool] || 'default';
            }

            updateProperties() {
                const panel = document.getElementById('propertiesPanelContent');

                if (!this.selectedPolygon) {
                    panel.innerHTML = '<div class="property-row" style="justify-content: center; padding: 12px;"><span class="property-label" style="color: #94a3b8; font-style: italic;">Select a polygon to view properties</span></div>';
                    return;
                }

                const areaPx = Math.abs(this.selectedPolygon.getArea());
                const perimeterPx = this.selectedPolygon.getPerimeter();

                const area = areaPx / (this.gridSize * this.gridSize);
                const perimeter = perimeterPx / this.gridSize;
                const vertices = this.selectedPolygon.vertices.length;

                let html = `
            <div class="property-row">
                <span class="property-label">Name:</span>
                <span class="property-value">${this.selectedPolygon.name}</span>
            </div>
            <div class="property-row">
                <span class="property-label">Vertices:</span>
                <span class="property-value">${vertices}</span>
            </div>
            <div class="property-row">
                <span class="property-label">Perimeter:</span>
                <span class="property-value">${perimeter.toFixed(2)} units</span>
            </div>
            <div class="property-row">
                <span class="property-label">Area:</span>
                <span class="property-value">${area.toFixed(2)} sq units</span>
            </div>
        `;

                // Add triangle classifier if it's a triangle
                if (vertices === 3) {
                    const classification = this.classifyTriangle(this.selectedPolygon);
                    html += `
                <div class="triangle-classifier">
                    <div class="triangle-classifier-title">Triangle Type:</div>
                    <span class="classifier-badge">${classification.sides}</span>
                    <span class="classifier-badge">${classification.angles}</span>
                </div>
            `;
                }

                panel.innerHTML = html;
            }

            updateLayers() {
                const list = document.getElementById('layersList');
                document.getElementById('layerCount').textContent = this.polygons.length;

                list.innerHTML = '';
                this.polygons.forEach((poly, index) => {
                    const item = document.createElement('div');
                    item.className = 'layer-item';
                    if ((this.combineMode && this.combineSelection.has(poly)) ||
                        (!this.combineMode && poly === this.selectedPolygon)) {
                        item.classList.add('selected');
                    }

                    item.innerHTML = `
                <div class="layer-color" style="background: ${poly.color}"></div>
                <div class="layer-name">${poly.name}</div>
                <div class="layer-actions">
                    <button class="layer-action-btn" onclick="app.togglePolygonVisibility(${index})" title="${poly.visible ? 'Hide' : 'Show'}">
                        ${poly.visible
                            ? 'ðŸ‘ï¸'
                            : '<div style="position:relative; display:inline-block;">ðŸ‘ï¸<div style="position:absolute; top:50%; left:-2px; right:-2px; height:2px; background:red; transform:rotate(-45deg); pointer-events:none;"></div></div>'}
                    </button>
                    <button class="layer-action-btn" onclick="app.deletePolygon(${index})" title="Delete">ðŸ—‘ï¸</button>
                </div>
            `;

                    item.addEventListener('click', (e) => {
                        if (!e.target.classList.contains('layer-action-btn')) {
                            if (this.combineMode) {
                                if (this.combineSelection.has(poly)) {
                                    this.combineSelection.delete(poly);
                                } else {
                                    this.combineSelection.add(poly);
                                }
                                this.render();
                                this.updateLayers();
                            } else {
                                this.selectedPolygon = poly;
                                this.updateProperties();
                                this.updateLayers();
                                this.render();
                            }
                        }
                    });

                    list.appendChild(item);
                });
            }

            classifyTriangle(polygon) {
                const v = polygon.vertices;
                if (v.length !== 3) return null;

                // Calculate side lengths
                const sides = [
                    this.distance(v[0], v[1]),
                    this.distance(v[1], v[2]),
                    this.distance(v[2], v[0])
                ];

                // Classify by sides
                let sideType;
                const tolerance = 1;
                if (Math.abs(sides[0] - sides[1]) < tolerance &&
                    Math.abs(sides[1] - sides[2]) < tolerance) {
                    sideType = 'Equilateral';
                } else if (Math.abs(sides[0] - sides[1]) < tolerance ||
                    Math.abs(sides[1] - sides[2]) < tolerance ||
                    Math.abs(sides[0] - sides[2]) < tolerance) {
                    sideType = 'Isosceles';
                } else {
                    sideType = 'Scalene';
                }

                // Calculate angles
                const angles = [];
                for (let i = 0; i < 3; i++) {
                    const v1 = v[i];
                    const v2 = v[(i + 1) % 3];
                    const v3 = v[(i + 2) % 3];

                    const a = this.distance(v2, v3);
                    const b = this.distance(v1, v3);
                    const c = this.distance(v1, v2);

                    const angle = Math.acos((b * b + c * c - a * a) / (2 * b * c)) * 180 / Math.PI;
                    angles.push(angle);
                }

                // Classify by angles
                let angleType;
                if (angles.some(a => Math.abs(a - 90) < 1)) {
                    angleType = 'Right';
                } else if (angles.some(a => a > 90)) {
                    angleType = 'Obtuse';
                } else {
                    angleType = 'Acute';
                }

                return { sides: sideType, angles: angleType };
            }

            // Rendering
            render(force = false) {
                // Throttle render calls for better performance
                const now = performance.now();

                // Cancel any pending render if a new one is requested
                if (this.renderAnimationFrameId !== null) {
                    cancelAnimationFrame(this.renderAnimationFrameId);
                    this.renderAnimationFrameId = null;
                }

                if (!force && this.renderScheduled) {
                    return;
                }

                if (!force && (now - this.lastRenderTime) < this.renderThrottleMs) {
                    if (!this.renderScheduled) {
                        this.renderScheduled = true;
                        this.renderAnimationFrameId = requestAnimationFrame(() => {
                            this.renderScheduled = false;
                            this.renderAnimationFrameId = null;
                            this.render(true);
                        });
                    }
                    return;
                }

                this.lastRenderTime = now;
                this.renderScheduled = false;

                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Save context state
                this.ctx.save();

                // Get CSS dimensions for coordinate calculations (context is already scaled by DPR)
                const rect = this.canvas.getBoundingClientRect();
                const cssWidth = rect.width;
                const cssHeight = rect.height;

                // Apply transformations
                this.ctx.translate(cssWidth / 2 + this.pan.x, cssHeight / 2 + this.pan.y);
                this.ctx.scale(this.zoom, this.zoom);

                // Draw grid FIRST before any other operations
                // This ensures grid is always drawn and not affected by other drawing operations
                this.drawGrid();

                // Draw visualizers
                if (this.visualizers.size > 0 && this.selectedPolygon) {
                    this.drawVisualizers();
                }

                // Draw polygons
                for (let poly of this.polygons) {
                    // Ensure polygon is visible (default to true if property doesn't exist)
                    if (poly.visible === false) continue;
                    let isSelected = poly === this.selectedPolygon;

                    // Highlight polygons selected for combination OR the primary selection in Split mode
                    if ((this.combineMode && this.combineSelection.has(poly)) ||
                        (this.splitMode && poly === this.selectedPolygon)) {
                        this.ctx.save();
                        this.ctx.shadowColor = '#ed8936'; // Orange/Gold glow
                        this.ctx.shadowBlur = 15;
                        this.drawPolygon(poly, true);
                        this.ctx.restore();
                    } else {
                        this.drawPolygon(poly, isSelected);
                    }
                }

                // Draw Split Line
                if (this.splitMode && this.splitLineStart && this.splitLineEnd) {
                    this.ctx.save();
                    this.ctx.strokeStyle = '#e53e3e';
                    this.ctx.lineWidth = 2 / this.zoom;
                    this.ctx.setLineDash([5 / this.zoom, 5 / this.zoom]);

                    // Calculate extended line for visualization if needed, or just segment
                    // Let's draw the segment for now as the "vector"
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.splitLineStart.x, this.splitLineStart.y);
                    this.ctx.lineTo(this.splitLineEnd.x, this.splitLineEnd.y);
                    this.ctx.stroke();

                    // Draw endpoints
                    this.ctx.fillStyle = '#e53e3e';
                    this.ctx.beginPath();
                    this.ctx.arc(this.splitLineStart.x, this.splitLineStart.y, 4 / this.zoom, 0, Math.PI * 2);
                    this.ctx.arc(this.splitLineEnd.x, this.splitLineEnd.y, 4 / this.zoom, 0, Math.PI * 2);
                    this.ctx.fill();

                    this.ctx.restore();
                }

                this.ctx.restore();
            }

            drawGrid() {
                // Safety check: ensure gridSize is valid
                if (!this.gridSize || this.gridSize <= 0 || !isFinite(this.gridSize)) {
                    return;
                }

                // Save context state BEFORE any grid operations
                // This preserves the current transformation matrix (translate/scale)
                this.ctx.save();

                // Get CSS dimensions for coordinate calculations
                const rect = this.canvas.getBoundingClientRect();
                const cssWidth = rect.width;
                const cssHeight = rect.height;

                // Safety check: ensure dimensions are valid
                if (!cssWidth || !cssHeight || !isFinite(cssWidth) || !isFinite(cssHeight)) {
                    this.ctx.restore(); // Restore context before returning
                    return;
                }

                // Calculate view bounds with improved precision
                const halfWidth = cssWidth / 2;
                const halfHeight = cssHeight / 2;
                const zoomInv = 1 / this.zoom;
                const panXZoom = this.pan.x * zoomInv;
                const panYZoom = this.pan.y * zoomInv;

                const viewBounds = {
                    left: -halfWidth * zoomInv - panXZoom,
                    right: halfWidth * zoomInv - panXZoom,
                    top: -halfHeight * zoomInv - panYZoom,
                    bottom: halfHeight * zoomInv - panYZoom
                };

                // Check if grid state changed (for caching optimization)
                // Note: We don't track selectedPolygon anymore since grid color is consistent
                const currentGridState = {
                    gridSize: this.gridSize,
                    zoom: this.zoom,
                    panX: Math.round(this.pan.x * 100) / 100,
                    panY: Math.round(this.pan.y * 100) / 100,
                    cssWidth: Math.round(cssWidth),
                    cssHeight: Math.round(cssHeight)
                };

                // ALWAYS draw the grid - disable aggressive caching that was causing issues
                // The grid must be drawn every frame to ensure it's always visible
                // Performance is acceptable since grid drawing is already optimized

                // Update state tracking (for potential future optimizations)
                // But never skip drawing based on this
                this.lastGridState = currentGridState;
                this.gridViewBounds = viewBounds;
                this.gridNeedsRedraw = false;

                // Calculate effective grid size in screen pixels for adaptive rendering
                const gridSizeScreen = this.gridSize * this.zoom;

                // Adaptive grid density: optimize rendering based on zoom level
                // Skip if grid lines are less than 2 pixels apart (too dense)
                if (gridSizeScreen < 2) {
                    // Draw major grid lines only with adaptive spacing
                    let majorGridMultiplier;
                    if (gridSizeScreen < 0.3) {
                        majorGridMultiplier = 50; // Very zoomed out - show every 50th line
                    } else if (gridSizeScreen < 0.5) {
                        majorGridMultiplier = 20; // Zoomed out - show every 20th line
                    } else if (gridSizeScreen < 1) {
                        majorGridMultiplier = 10; // Moderately zoomed out - show every 10th line
                    } else {
                        majorGridMultiplier = 5; // Slightly zoomed out - show every 5th line
                    }
                    this.drawGridLines(viewBounds, this.gridSize * majorGridMultiplier, true);
                    this.ctx.restore(); // Restore context before returning
                    return;
                }

                // Skip if grid lines are more than 200 pixels apart (too sparse)
                if (gridSizeScreen > 200) {
                    // Draw sub-grid lines for better visibility when zoomed in
                    const subGridSize = this.gridSize / 5;
                    // Only draw sub-grid if it's visible (not too small)
                    if (subGridSize * this.zoom > 1) {
                        this.drawGridLines(viewBounds, subGridSize, false);
                    }
                    this.drawGridLines(viewBounds, this.gridSize, true);
                    this.ctx.restore(); // Restore context before returning
                    return;
                }

                // Normal grid rendering - optimized batch drawing
                // For optimal visibility, always draw the main grid
                this.drawGridLines(viewBounds, this.gridSize, false);

                // Restore context state after drawing grid
                this.ctx.restore();
            }

            drawGridLines(viewBounds, gridSize, isMajor = false) {
                // Safety check: ensure gridSize is valid
                if (!gridSize || gridSize <= 0 || !isFinite(gridSize)) {
                    return;
                }

                // Consistent grid colors - ALWAYS use these exact colors
                // Never change based on selection or any other state
                const gridColor = isMajor ? '#c0c0c0' : '#d8d8d8';

                // Optimize line width calculation - consistent line widths
                const zoomInv = 1 / this.zoom;
                const baseLineWidth = isMajor ? 1.2 : 0.9;
                const lineWidth = baseLineWidth * zoomInv;

                // Clamp line width to reasonable bounds for performance and visibility
                const clampedLineWidth = Math.max(0.5, Math.min(2.0, lineWidth));

                // CRITICAL: Explicitly set all stroke properties to ensure consistency
                // Reset any previous state that might affect grid rendering
                this.ctx.strokeStyle = gridColor;
                this.ctx.lineWidth = clampedLineWidth;
                this.ctx.lineCap = 'butt';
                this.ctx.lineJoin = 'miter';
                this.ctx.setLineDash([]); // Ensure no dash pattern
                this.ctx.globalAlpha = 1.0; // Ensure full opacity
                this.ctx.globalCompositeOperation = 'source-over'; // Ensure normal blending

                // Calculate grid line bounds with improved precision and safety checks
                // Use epsilon to handle edge cases near zero
                const epsilon = 1e-10;
                const startX = Math.floor((viewBounds.left - epsilon) / gridSize) * gridSize;
                const endX = Math.ceil((viewBounds.right + epsilon) / gridSize) * gridSize;
                const startY = Math.floor((viewBounds.top - epsilon) / gridSize) * gridSize;
                const endY = Math.ceil((viewBounds.bottom + epsilon) / gridSize) * gridSize;

                // Safety check: ensure bounds are valid
                if (!isFinite(startX) || !isFinite(endX) || !isFinite(startY) || !isFinite(endY)) {
                    return;
                }

                // Limit number of lines to prevent performance issues (increased limit for better quality)
                const maxLines = 800; // Increased from 500 for better grid visibility
                const numVerticalLines = Math.floor((endX - startX) / gridSize) + 1;
                const numHorizontalLines = Math.floor((endY - startY) / gridSize) + 1;

                if (numVerticalLines > maxLines || numHorizontalLines > maxLines ||
                    numVerticalLines < 0 || numHorizontalLines < 0) {
                    // Too many lines or invalid count - skip drawing to prevent lag
                    // Draw only major lines in this case
                    if (isMajor) {
                        const majorSpacing = Math.max(gridSize * 5, (endX - startX) / 50);
                        this.drawGridLines(viewBounds, majorSpacing, true);
                    }
                    return;
                }

                // Optimize: Batch draw vertical lines for better performance
                this.ctx.beginPath();
                // Pre-calculate rounded positions to avoid repeated calculations
                const verticalLineCount = Math.floor((endX - startX) / gridSize) + 1;
                if (verticalLineCount > 0 && verticalLineCount <= maxLines) {
                    for (let i = 0; i <= verticalLineCount; i++) {
                        const x = startX + i * gridSize;
                        // Use precise rounding to avoid floating point artifacts
                        const xPos = Math.round(x * 10000) / 10000;
                        this.ctx.moveTo(xPos, viewBounds.top);
                        this.ctx.lineTo(xPos, viewBounds.bottom);
                    }
                }
                this.ctx.stroke();

                // Batch draw horizontal lines for better performance
                this.ctx.beginPath();
                const horizontalLineCount = Math.floor((endY - startY) / gridSize) + 1;
                if (horizontalLineCount > 0 && horizontalLineCount <= maxLines) {
                    for (let i = 0; i <= horizontalLineCount; i++) {
                        const y = startY + i * gridSize;
                        // Use precise rounding to avoid floating point artifacts
                        const yPos = Math.round(y * 10000) / 10000;
                        this.ctx.moveTo(viewBounds.left, yPos);
                        this.ctx.lineTo(viewBounds.right, yPos);
                    }
                }
                this.ctx.stroke();

                // Draw axes only for major grid with consistent visibility
                if (isMajor && Math.abs(gridSize - this.gridSize) < 0.01) {
                    // Explicitly set axis properties to ensure consistency
                    this.ctx.strokeStyle = '#999';
                    this.ctx.lineWidth = Math.max(1.5, Math.min(3.0, 2 * zoomInv));
                    this.ctx.lineCap = 'butt';
                    this.ctx.setLineDash([]); // Ensure solid lines for axes
                    this.ctx.globalAlpha = 1.0;

                    // X-axis
                    this.ctx.beginPath();
                    this.ctx.moveTo(viewBounds.left, 0);
                    this.ctx.lineTo(viewBounds.right, 0);
                    this.ctx.stroke();

                    // Y-axis
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, viewBounds.top);
                    this.ctx.lineTo(0, viewBounds.bottom);
                    this.ctx.stroke();
                }
            }

            drawPolygon(polygon, selected = false) {
                // Save context state before drawing polygon to ensure grid isn't affected
                this.ctx.save();

                const vertices = polygon.vertices;
                if (vertices.length < 2) {
                    this.ctx.restore();
                    return;
                }

                // Draw fill
                this.ctx.fillStyle = polygon.color + '33';
                this.ctx.beginPath();
                this.ctx.moveTo(vertices[0].x, vertices[0].y);
                for (let i = 1; i < vertices.length; i++) {
                    this.ctx.lineTo(vertices[i].x, vertices[i].y);
                }
                this.ctx.closePath();
                this.ctx.fill();

                // Draw stroke
                this.ctx.strokeStyle = selected ? '#333' : polygon.color;
                this.ctx.lineWidth = (selected ? 3 : 2) / this.zoom;
                this.ctx.stroke();

                // Draw vertices
                for (let i = 0; i < vertices.length; i++) {
                    const v = vertices[i];

                    // Normal vertex rendering - enhanced for better dragging visibility
                    let vertexSize = selected ? 8 : 4;
                    let vertexFill = selected ? '#fff' : polygon.color;
                    let vertexStroke = selected ? '#333' : polygon.color;

                    // Make vertex larger when it's being dragged
                    if (this.selectedVertex === v) {
                        vertexSize = selected ? 10 : 6;
                    }

                    this.ctx.fillStyle = vertexFill;
                    this.ctx.strokeStyle = vertexStroke;
                    this.ctx.lineWidth = 2 / this.zoom;

                    this.ctx.beginPath();
                    this.ctx.arc(v.x, v.y, vertexSize / this.zoom, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.stroke();
                }

                // Restore context state after drawing polygon
                this.ctx.restore();
            }

            drawVisualizers() {
                const poly = this.selectedPolygon;
                if (!poly || poly.vertices.length < 3) return;

                this.ctx.save();

                // Angles
                if (this.visualizers.has('angles')) {
                    this.ctx.font = `bold ${14 / this.zoom}px Arial`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';

                    for (let i = 0; i < poly.vertices.length; i++) {
                        const v1 = poly.vertices[i];
                        const v2 = poly.vertices[(i + 1) % poly.vertices.length];
                        const v3 = poly.vertices[(i + 2) % poly.vertices.length];

                        const a = this.distance(v2, v3); // Side from v2 to v3 (Adjacent 1)
                        const b = this.distance(v1, v3); // Side from v1 to v3 (Opposite to v2)
                        const c = this.distance(v1, v2); // Side from v1 to v2 (Adjacent 2)

                        // Law of Cosines for Angle at v2: bÂ² = aÂ² + cÂ² - 2ac cos(Angle)
                        // cos(Angle) = (aÂ² + cÂ² - bÂ²) / (2ac)
                        let numerator = a * a + c * c - b * b;
                        let denominator = 2 * a * c;

                        // Avoid division by zero
                        if (denominator === 0) continue;

                        let cosAngle = numerator / denominator;
                        // Clamp to [-1, 1] to handle float precision issues
                        cosAngle = Math.max(-1, Math.min(1, cosAngle));

                        const angle = Math.acos(cosAngle) * 180 / Math.PI;

                        // Calculate Bisector Vector for positioning
                        // Vector v2->v1
                        let dx1 = v1.x - v2.x;
                        let dy1 = v1.y - v2.y;
                        const len1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
                        if (len1 > 0) { dx1 /= len1; dy1 /= len1; }

                        // Vector v2->v3
                        let dx3 = v3.x - v2.x;
                        let dy3 = v3.y - v2.y;
                        const len3 = Math.sqrt(dx3 * dx3 + dy3 * dy3);
                        if (len3 > 0) { dx3 /= len3; dy3 /= len3; }

                        // Bisector (Approximate inward direction for angle <= 180)
                        let bx = dx1 + dx3;
                        let by = dy1 + dy3;
                        const bLen = Math.sqrt(bx * bx + by * by);
                        if (bLen > 0) { bx /= bLen; by /= bLen; }

                        // Offset distance (Inward)
                        const offset = 35 / this.zoom;
                        const labelX = v2.x + bx * offset;
                        const labelY = v2.y + by * offset;

                        // Draw Badge
                        const text = `${angle.toFixed(0)}Â°`;
                        // Fixed radius circle usually fits 2-3 digits well enough at this font size
                        // Radius 12 fits nicely
                        this.ctx.beginPath();
                        this.ctx.arc(labelX, labelY, 13 / this.zoom, 0, Math.PI * 2);
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                        this.ctx.fill();
                        this.ctx.lineWidth = 1 / this.zoom;
                        this.ctx.strokeStyle = '#ff6b6b';
                        this.ctx.stroke();

                        this.ctx.fillStyle = '#ff6b6b';
                        this.ctx.fillText(text, labelX, labelY);
                    }
                }

                // Medians & Centroid (for triangles)
                if (this.visualizers.has('medians') && poly.vertices.length === 3) {
                    this.ctx.strokeStyle = '#3b82f6';
                    this.ctx.lineWidth = 1 / this.zoom;
                    this.ctx.setLineDash([4 / this.zoom, 4 / this.zoom]);

                    const centroid = {
                        x: (poly.vertices[0].x + poly.vertices[1].x + poly.vertices[2].x) / 3,
                        y: (poly.vertices[0].y + poly.vertices[1].y + poly.vertices[2].y) / 3
                    };

                    for (let i = 0; i < 3; i++) {
                        const v = poly.vertices[i];
                        const opposite1 = poly.vertices[(i + 1) % 3];
                        const opposite2 = poly.vertices[(i + 2) % 3];
                        const midpoint = {
                            x: (opposite1.x + opposite2.x) / 2,
                            y: (opposite1.y + opposite2.y) / 2
                        };

                        this.ctx.beginPath();
                        this.ctx.moveTo(v.x, v.y);
                        this.ctx.lineTo(midpoint.x, midpoint.y);
                        this.ctx.stroke();
                    }

                    this.ctx.setLineDash([]);
                    this.ctx.fillStyle = '#3b82f6';
                    this.ctx.beginPath();
                    this.ctx.arc(centroid.x, centroid.y, 5 / this.zoom, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // Altitudes & Orthocenter (for triangles only)
                if (this.visualizers.has('altitudes') && poly.vertices.length === 3) {
                    this.ctx.strokeStyle = '#ef4444'; // Red
                    this.ctx.lineWidth = 1.5 / this.zoom;
                    this.ctx.setLineDash([5 / this.zoom, 3 / this.zoom]);

                    const altitudes = [];
                    const vertices = poly.vertices;

                    // Safety check: ensure we have exactly 3 valid vertices
                    if (vertices.length !== 3) {
                        this.ctx.setLineDash([]);
                        this.ctx.restore();
                        return;
                    }

                    // Calculate all three altitudes
                    for (let i = 0; i < 3; i++) {
                        const vertex = vertices[i];
                        const opposite1 = vertices[(i + 1) % 3];
                        const opposite2 = vertices[(i + 2) % 3];

                        // Safety checks
                        if (!vertex || !opposite1 || !opposite2) continue;
                        if (!isFinite(vertex.x) || !isFinite(vertex.y) ||
                            !isFinite(opposite1.x) || !isFinite(opposite1.y) ||
                            !isFinite(opposite2.x) || !isFinite(opposite2.y)) continue;

                        // Line from opposite1 to opposite2
                        const dx = opposite2.x - opposite1.x;
                        const dy = opposite2.y - opposite1.y;
                        const lineLength = Math.sqrt(dx * dx + dy * dy);

                        if (lineLength < 1e-10) continue; // Avoid division by zero

                        // Calculate projection of vertex onto the opposite side
                        const t = ((vertex.x - opposite1.x) * dx + (vertex.y - opposite1.y) * dy) / (lineLength * lineLength);
                        const foot = {
                            x: opposite1.x + t * dx,
                            y: opposite1.y + t * dy
                        };

                        // Draw altitude line from vertex to foot
                        this.ctx.beginPath();
                        this.ctx.moveTo(vertex.x, vertex.y);
                        this.ctx.lineTo(foot.x, foot.y);
                        this.ctx.stroke();

                        altitudes.push({ vertex, foot });
                    }

                    // Calculate orthocenter (intersection of altitudes)
                    // For triangle with vertices A, B, C:
                    // Orthocenter is intersection of altitudes from A and B
                    if (altitudes.length >= 2) {
                        const alt1 = altitudes[0];
                        const alt2 = altitudes[1];

                        // Line 1: from alt1.vertex to alt1.foot
                        const dx1 = alt1.foot.x - alt1.vertex.x;
                        const dy1 = alt1.foot.y - alt1.vertex.y;
                        const m1 = dx1 !== 0 ? dy1 / dx1 : Infinity;
                        const b1 = m1 !== Infinity ? alt1.vertex.y - m1 * alt1.vertex.x : alt1.vertex.x;

                        // Line 2: from alt2.vertex to alt2.foot
                        const dx2 = alt2.foot.x - alt2.vertex.x;
                        const dy2 = alt2.foot.y - alt2.vertex.y;
                        const m2 = dx2 !== 0 ? dy2 / dx2 : Infinity;
                        const b2 = m2 !== Infinity ? alt2.vertex.y - m2 * alt2.vertex.x : alt2.vertex.x;

                        let orthocenter = null;

                        if (m1 === Infinity && m2 === Infinity) {
                            // Both vertical - parallel, no intersection
                            orthocenter = null;
                        } else if (m1 === Infinity) {
                            // Line 1 is vertical
                            const x = b1;
                            const y = m2 * x + b2;
                            orthocenter = { x, y };
                        } else if (m2 === Infinity) {
                            // Line 2 is vertical
                            const x = b2;
                            const y = m1 * x + b1;
                            orthocenter = { x, y };
                        } else {
                            // Both have slopes
                            const x = (b2 - b1) / (m1 - m2);
                            const y = m1 * x + b1;
                            orthocenter = { x, y };
                        }

                        // Draw orthocenter point
                        if (orthocenter && isFinite(orthocenter.x) && isFinite(orthocenter.y)) {
                            this.ctx.setLineDash([]);
                            this.ctx.fillStyle = '#ef4444';
                            this.ctx.beginPath();
                            this.ctx.arc(orthocenter.x, orthocenter.y, 6 / this.zoom, 0, Math.PI * 2);
                            this.ctx.fill();
                            this.ctx.strokeStyle = '#ffffff';
                            this.ctx.lineWidth = 1.5 / this.zoom;
                            this.ctx.stroke();
                        }
                    }

                    this.ctx.setLineDash([]);
                }

                // Perpendicular Bisectors (for triangles and other polygons)
                if (this.visualizers.has('bisectors')) {
                    this.ctx.strokeStyle = '#10b981'; // Green
                    this.ctx.lineWidth = 1.5 / this.zoom;
                    this.ctx.setLineDash([5 / this.zoom, 3 / this.zoom]);

                    const vertices = poly.vertices;
                    const bisectors = [];

                    // Safety check: need at least 3 vertices
                    if (vertices.length < 3) {
                        this.ctx.setLineDash([]);
                        this.ctx.restore();
                        return;
                    }

                    // Calculate perpendicular bisector for each side
                    for (let i = 0; i < vertices.length; i++) {
                        const v1 = vertices[i];
                        const v2 = vertices[(i + 1) % vertices.length];

                        // Safety checks
                        if (!v1 || !v2) continue;
                        if (!isFinite(v1.x) || !isFinite(v1.y) ||
                            !isFinite(v2.x) || !isFinite(v2.y)) continue;

                        // Midpoint of the side
                        const midpoint = {
                            x: (v1.x + v2.x) / 2,
                            y: (v1.y + v2.y) / 2
                        };

                        // Direction vector of the side
                        const dx = v2.x - v1.x;
                        const dy = v2.y - v1.y;
                        const sideLength = Math.sqrt(dx * dx + dy * dy);

                        if (sideLength < 1e-10) continue; // Avoid division by zero

                        // Perpendicular direction (rotate 90 degrees)
                        const perpDx = -dy;
                        const perpDy = dx;

                        // Normalize perpendicular vector
                        const perpLength = Math.sqrt(perpDx * perpDx + perpDy * perpDy);
                        if (perpLength === 0) continue;

                        const perpNormX = perpDx / perpLength;
                        const perpNormY = perpDy / perpLength;

                        // Calculate centroid to determine which direction to extend
                        let cx = 0, cy = 0;
                        for (let v of vertices) {
                            cx += v.x;
                            cy += v.y;
                        }
                        cx /= vertices.length;
                        cy /= vertices.length;

                        // Extend bisector in both directions (long enough to be visible)
                        const extendLength = Math.max(200, sideLength * 2) / this.zoom;
                        const startX = midpoint.x - perpNormX * extendLength;
                        const startY = midpoint.y - perpNormY * extendLength;
                        const endX = midpoint.x + perpNormX * extendLength;
                        const endY = midpoint.y + perpNormY * extendLength;

                        // Draw bisector line
                        this.ctx.beginPath();
                        this.ctx.moveTo(startX, startY);
                        this.ctx.lineTo(endX, endY);
                        this.ctx.stroke();

                        bisectors.push({ midpoint, perpNormX, perpNormY });
                    }

                    // For triangles, find and draw circumcenter (intersection of perpendicular bisectors)
                    if (vertices.length === 3 && bisectors.length >= 2) {
                        const bis1 = bisectors[0];
                        const bis2 = bisectors[1];

                        // Line 1: through bis1.midpoint with direction bis1.perpNormX, bis1.perpNormY
                        // Parametric: p = bis1.midpoint + t * (bis1.perpNormX, bis1.perpNormY)
                        // Convert to ax + by = c form
                        const a1 = -bis1.perpNormY;
                        const b1 = bis1.perpNormX;
                        const c1 = a1 * bis1.midpoint.x + b1 * bis1.midpoint.y;

                        // Line 2: through bis2.midpoint with direction bis2.perpNormX, bis2.perpNormY
                        const a2 = -bis2.perpNormY;
                        const b2 = bis2.perpNormX;
                        const c2 = a2 * bis2.midpoint.x + b2 * bis2.midpoint.y;

                        // Solve system: a1*x + b1*y = c1, a2*x + b2*y = c2
                        const det = a1 * b2 - a2 * b1;

                        if (Math.abs(det) > 1e-10) {
                            const circumcenterX = (c1 * b2 - c2 * b1) / det;
                            const circumcenterY = (a1 * c2 - a2 * c1) / det;

                            if (isFinite(circumcenterX) && isFinite(circumcenterY)) {
                                // Draw circumcenter
                                this.ctx.setLineDash([]);
                                this.ctx.fillStyle = '#10b981';
                                this.ctx.beginPath();
                                this.ctx.arc(circumcenterX, circumcenterY, 6 / this.zoom, 0, Math.PI * 2);
                                this.ctx.fill();
                                this.ctx.strokeStyle = '#ffffff';
                                this.ctx.lineWidth = 1.5 / this.zoom;
                                this.ctx.stroke();
                            }
                        }
                    }

                    this.ctx.setLineDash([]);
                }

                // Diagonals (for polygons with more than 3 vertices)
                if (this.visualizers.has('diagonals') && poly.vertices.length > 3) {
                    this.ctx.strokeStyle = '#a855f7'; // Purple
                    this.ctx.lineWidth = 1 / this.zoom;
                    this.ctx.setLineDash([4 / this.zoom, 4 / this.zoom]);

                    const vertices = poly.vertices;

                    // Draw all diagonals: connect vertex i to vertex j where j is at least 2 positions away
                    // This ensures we don't draw edges (adjacent vertices)
                    for (let i = 0; i < vertices.length; i++) {
                        for (let j = i + 2; j < vertices.length; j++) {
                            // Skip the edge case where last vertex connects to first (that's an edge, not a diagonal)
                            if (j === vertices.length - 1 && i === 0) continue;

                            // Safety check: ensure vertices are valid
                            if (!vertices[i] || !vertices[j]) continue;
                            if (!isFinite(vertices[i].x) || !isFinite(vertices[i].y) ||
                                !isFinite(vertices[j].x) || !isFinite(vertices[j].y)) continue;

                            this.ctx.beginPath();
                            this.ctx.moveTo(vertices[i].x, vertices[i].y);
                            this.ctx.lineTo(vertices[j].x, vertices[j].y);
                            this.ctx.stroke();
                        }
                    }

                    this.ctx.setLineDash([]);
                }

                // Show Vertices (ABC points)
                if (this.visualizers.has('vertices')) {
                    this.ctx.font = `bold ${16 / this.zoom}px Arial`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';

                    // Calculate centroid
                    let cx = 0, cy = 0;
                    if (poly.vertices.length > 0) {
                        for (let v of poly.vertices) { cx += v.x; cy += v.y; }
                        cx /= poly.vertices.length;
                        cy /= poly.vertices.length;
                    }

                    const letters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'];
                    for (let i = 0; i < poly.vertices.length; i++) {
                        const v = poly.vertices[i];
                        const letter = letters[i % letters.length];

                        // Calculate outward direction
                        let dx = v.x - cx;
                        let dy = v.y - cy;
                        const len = Math.sqrt(dx * dx + dy * dy);
                        if (len > 0) {
                            dx /= len;
                            dy /= len;
                        }

                        // Offset: Vertex Radius (approx 5) + padding
                        const dist = 20 / this.zoom;
                        const labelX = v.x + dx * dist;
                        const labelY = v.y + dy * dist;

                        // Draw Background Badge (White Circle)
                        this.ctx.beginPath();
                        this.ctx.arc(labelX, labelY, 10 / this.zoom, 0, Math.PI * 2);
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                        this.ctx.fill();
                        this.ctx.lineWidth = 1 / this.zoom;
                        this.ctx.strokeStyle = '#10b981';
                        this.ctx.stroke();

                        // Draw Letter
                        this.ctx.fillStyle = '#10b981';
                        this.ctx.fillText(letter, labelX, labelY);
                    }
                }

                // Show Perimeters
                if (this.visualizers.has('perimeters')) {
                    this.ctx.font = `${14 / this.zoom}px Arial`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.lineWidth = 1.5 / this.zoom;
                    this.ctx.strokeStyle = '#0d9488'; // Teal
                    this.ctx.fillStyle = '#0d9488'; // Teal

                    // Calculate centroid for outward direction check
                    let cx = 0, cy = 0;
                    for (let v of poly.vertices) { cx += v.x; cy += v.y; }
                    cx /= poly.vertices.length;
                    cy /= poly.vertices.length;

                    for (let i = 0; i < poly.vertices.length; i++) {
                        const v1 = poly.vertices[i];
                        const v2 = poly.vertices[(i + 1) % poly.vertices.length];

                        // Calculate grid length
                        const dx = v2.x - v1.x;
                        const dy = v2.y - v1.y;
                        const len = Math.sqrt(dx * dx + dy * dy);
                        const distance = len / this.gridSize;

                        // Calculate offset vector (perpendicular to edge)
                        const angle = Math.atan2(dy, dx);
                        const offsetX = Math.sin(angle) * (15 / this.zoom);
                        const offsetY = -Math.cos(angle) * (15 / this.zoom);

                        const midX = (v1.x + v2.x) / 2;
                        const midY = (v1.y + v2.y) / 2;

                        // Check if offset is outward or inward compared to centroid
                        const distOut = (midX + offsetX - cx) ** 2 + (midY + offsetY - cy) ** 2;
                        const distIn = (midX - offsetX - cx) ** 2 + (midY - offsetY - cy) ** 2;

                        const actualOffsetX = distOut > distIn ? offsetX : -offsetX;
                        const actualOffsetY = distOut > distIn ? offsetY : -offsetY;

                        // Draw Bracket
                        this.ctx.beginPath();
                        // Main line
                        this.ctx.moveTo(v1.x + actualOffsetX, v1.y + actualOffsetY);
                        this.ctx.lineTo(v2.x + actualOffsetX, v2.y + actualOffsetY);

                        // End caps (small ticks)
                        const tickX = Math.cos(angle) * (4 / this.zoom);
                        const tickY = Math.sin(angle) * (4 / this.zoom);

                        this.ctx.moveTo(v1.x + actualOffsetX + tickX, v1.y + actualOffsetY + tickY);
                        this.ctx.lineTo(v1.x + actualOffsetX - tickX, v1.y + actualOffsetY - tickY);

                        this.ctx.moveTo(v2.x + actualOffsetX + tickX, v2.y + actualOffsetY + tickY);
                        this.ctx.lineTo(v2.x + actualOffsetX - tickX, v2.y + actualOffsetY - tickY);

                        this.ctx.stroke();

                        // Label
                        this.ctx.fillText(`${distance.toFixed(1)}`, midX + actualOffsetX * 1.8, midY + actualOffsetY * 1.8);
                    }
                }

                // Show Base & Height
                if (this.visualizers.has('baseHeight')) {
                    this.ctx.font = `${14 / this.zoom}px Arial`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.lineWidth = 1.5 / this.zoom;

                    const vertices = poly.vertices;

                    if (vertices.length === 3) {
                        // Triangle Logic: Find the "best" base (closest to horizontal bottom)
                        let bestSideIndex = -1;
                        let maxHorizontalScore = -Infinity;

                        for (let i = 0; i < 3; i++) {
                            const v1 = vertices[i];
                            const v2 = vertices[(i + 1) % 3];
                            const dx = Math.abs(v2.x - v1.x);
                            const dy = Math.abs(v2.y - v1.y);
                            const length = Math.sqrt(dx * dx + dy * dy);

                            // Score: Prefer horizontal (small dy) and lower (large y)
                            // We weigh horizontal alignment heavily
                            const horizontalness = dx / (length + 0.001); // 0 to 1
                            const avgY = (v1.y + v2.y) / 2;

                            // Simple heuristic: Horizontalness is king, then lower Y
                            const score = horizontalness * 1000 + avgY;

                            if (score > maxHorizontalScore) {
                                maxHorizontalScore = score;
                                bestSideIndex = i;
                            }
                        }

                        const i = bestSideIndex;
                        const baseV1 = vertices[i];
                        const baseV2 = vertices[(i + 1) % 3];
                        const apex = vertices[(i + 2) % 3];

                        // Calculate geometric base length
                        const baseLength = this.distance(baseV1, baseV2) / this.gridSize;

                        // Calculate geometric height (distance from apex to base line)
                        // Area = 0.5 * base * height => Height = 2 * Area / Base
                        // Use signed area formula for polygon area
                        const area = Math.abs(poly.getArea());
                        // Wait, poly.getArea() returns area in square grid units (roughly), 
                        // let's trust geometric calculation

                        // Recalculate physical area using coordinates for precision
                        const physicalArea = Math.abs((baseV1.x * (baseV2.y - apex.y) + baseV2.x * (apex.y - baseV1.y) + apex.x * (baseV1.y - baseV2.y)) / 2);
                        const physicalBase = this.distance(baseV1, baseV2);
                        const physicalHeight = (2 * physicalArea) / physicalBase;
                        const heightLength = physicalHeight / this.gridSize;

                        // Draw Base Bracket
                        this.ctx.strokeStyle = '#2563eb'; // Blue for Base
                        this.ctx.fillStyle = '#2563eb';

                        // Offset for bracket
                        const angle = Math.atan2(baseV2.y - baseV1.y, baseV2.x - baseV1.x);
                        const offsetX = Math.sin(angle) * (20 / this.zoom);
                        const offsetY = -Math.cos(angle) * (20 / this.zoom);

                        // If offset points *into* the triangle, flip it
                        // Check midpoint + offset vs centroid
                        const midX = (baseV1.x + baseV2.x) / 2;
                        const midY = (baseV1.y + baseV2.y) / 2;
                        const centroidX = (baseV1.x + baseV2.x + apex.x) / 3;
                        const centroidY = (baseV1.y + baseV2.y + apex.y) / 3;

                        const valOriginal = (midX + offsetX - centroidX) ** 2 + (midY + offsetY - centroidY) ** 2;
                        const valFlipped = (midX - offsetX - centroidX) ** 2 + (midY - offsetY - centroidY) ** 2;

                        const actualOffsetX = valOriginal > valFlipped ? offsetX : -offsetX;
                        const actualOffsetY = valOriginal > valFlipped ? offsetY : -offsetY;

                        // Draw Bracket Line
                        this.ctx.beginPath();
                        this.ctx.moveTo(baseV1.x + actualOffsetX, baseV1.y + actualOffsetY);
                        this.ctx.lineTo(baseV2.x + actualOffsetX, baseV2.y + actualOffsetY);
                        this.ctx.stroke();

                        // Label Base
                        this.ctx.fillText(`b = ${baseLength.toFixed(1)}`, midX + actualOffsetX * 1.5, midY + actualOffsetY * 1.5);


                        // Draw Height Line
                        this.ctx.strokeStyle = '#dc2626'; // Red for Height
                        this.ctx.fillStyle = '#dc2626';
                        this.ctx.setLineDash([5 / this.zoom, 3 / this.zoom]);

                        // Project apex onto base line
                        // Line defined by baseV1 + t * (baseV2 - baseV1)
                        const dx = baseV2.x - baseV1.x;
                        const dy = baseV2.y - baseV1.y;
                        const t = ((apex.x - baseV1.x) * dx + (apex.y - baseV1.y) * dy) / (dx * dx + dy * dy);

                        const projX = baseV1.x + t * dx;
                        const projY = baseV1.y + t * dy;

                        this.ctx.beginPath();
                        this.ctx.moveTo(apex.x, apex.y);
                        this.ctx.lineTo(projX, projY);
                        this.ctx.stroke();
                        this.ctx.setLineDash([]);

                        // Label Height
                        const hMidX = (apex.x + projX) / 2;
                        const hMidY = (apex.y + projY) / 2;
                        this.ctx.fillText(`h = ${heightLength.toFixed(1)}`, hMidX + 10 / this.zoom, hMidY);

                        // Draw Right Angle mark at projection
                        const size = 10 / this.zoom;
                        // Need vector along base line
                        const baseLen = Math.sqrt(dx * dx + dy * dy);
                        const ux = dx / baseLen;
                        const uy = dy / baseLen;
                        // Vector along height line
                        const hx = apex.x - projX;
                        const hy = apex.y - projY;
                        // Perpendicular check not strictly needed for drawing box, just use base direction

                        // We draw a small box at projX,projY aligned with base
                        // This is tricky on general angles, skipping for simplicity or just drawing a dot
                        this.ctx.beginPath();
                        this.ctx.arc(projX, projY, 3 / this.zoom, 0, Math.PI * 2);
                        this.ctx.fill();

                    } else {
                        // Bounding Box Logic for other polygons
                        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                        vertices.forEach(v => {
                            minX = Math.min(minX, v.x);
                            maxX = Math.max(maxX, v.x);
                            minY = Math.min(minY, v.y);
                            maxY = Math.max(maxY, v.y);
                        });

                        const width = (maxX - minX) / this.gridSize;
                        const height = (maxY - minY) / this.gridSize;

                        this.ctx.strokeStyle = '#2563eb';
                        this.ctx.fillStyle = '#2563eb';

                        // Width label (Bottom)
                        this.ctx.beginPath();
                        this.ctx.moveTo(minX, maxY + 20 / this.zoom);
                        this.ctx.lineTo(maxX, maxY + 20 / this.zoom);
                        this.ctx.stroke();
                        this.ctx.fillText(`w = ${width.toFixed(1)}`, (minX + maxX) / 2, maxY + 35 / this.zoom);

                        this.ctx.strokeStyle = '#dc2626';
                        this.ctx.fillStyle = '#dc2626';

                        // Height label (Right)
                        this.ctx.beginPath();
                        this.ctx.moveTo(maxX + 20 / this.zoom, minY);
                        this.ctx.lineTo(maxX + 20 / this.zoom, maxY);
                        this.ctx.stroke();
                        this.ctx.fillText(`h = ${height.toFixed(1)}`, maxX + 35 / this.zoom, (minY + maxY) / 2);
                    }
                }

                this.ctx.restore();
            }

            getMouseWorldPos() {
                // Get current mouse position in world coordinates
                // This is a simplified version - would need actual mouse tracking
                return null;
            }

            // Utility functions
            setTool(tool) {

                document.querySelectorAll('[data-tool]').forEach(btn => {
                    if (btn.dataset.tool === tool) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                });
                this.currentTool = tool;
                this.updateCursor();
                this.render();
            }



            togglePolygonVisibility(index) {
                if (this.polygons[index]) {
                    this.polygons[index].visible = !this.polygons[index].visible;
                    this.saveHistory();
                    this.render();
                    this.updateLayers();
                }
            }

            deletePolygon(index) {
                if (this.polygons[index]) {
                    if (this.selectedPolygon === this.polygons[index]) {
                        this.selectedPolygon = null;
                    }
                    this.polygons.splice(index, 1);
                    this.saveHistory();
                    this.updateProperties();
                    this.updateLayers();
                    this.render();
                }
            }

            deleteSelected() {
                if (this.selectedPolygon) {
                    const index = this.polygons.indexOf(this.selectedPolygon);
                    if (index !== -1) {
                        this.deletePolygon(index);
                    }
                }
            }

            cancelCurrentAction() {
                this.isDragging = false;
                this.selectedVertex = null;
                this.dragStart = null;
                this.render();
            }

            // History management
            saveHistory() {
                const state = JSON.stringify(this.polygons.map(p => ({
                    vertices: p.vertices,
                    color: p.color,
                    name: p.name,
                    visible: p.visible
                })));

                // Avoid redundant saves if state hasn't changed
                if (this.historyIndex >= 0 && state === this.history[this.historyIndex]) {
                    return;
                }

                this.history = this.history.slice(0, this.historyIndex + 1);
                this.history.push(state);
                this.historyIndex++;

                // Limit history size
                if (this.history.length > 50) {
                    this.history.shift();
                    this.historyIndex--;
                }
            }

            undo() {
                if (this.historyIndex > 0) {
                    this.cancelCurrentAction();
                    this.historyIndex--;
                    this.loadState(this.history[this.historyIndex]);

                    // Update UI to reflect undo
                    this.updateProperties();
                    this.updateLayers();
                    this.markGridForRedraw();
                    // CRITICAL: Force render to ensure canvas reflects the undone state
                    this.render(true);
                } else {
                    console.log('Nothing to undo');
                }
            }

            redo() {
                if (this.historyIndex < this.history.length - 1) {
                    this.cancelCurrentAction();
                    this.historyIndex++;
                    this.loadState(this.history[this.historyIndex]);

                    // Update UI to reflect redo
                    this.updateProperties();
                    this.updateLayers();
                    this.markGridForRedraw();
                    // CRITICAL: Force render to ensure canvas reflects the redone state
                    this.render(true);
                } else {
                    console.log('Nothing to redo');
                }
            }

            loadState(state) {
                try {
                    // Store current selection info to restore it if possible
                    const selectedName = this.selectedPolygon ? this.selectedPolygon.name : null;
                    const selectedIndex = this.selectedPolygon ? this.polygons.indexOf(this.selectedPolygon) : -1;

                    const data = JSON.parse(state);

                    // Validate parsed data
                    if (!Array.isArray(data)) {
                        console.error('Invalid state data - not an array');
                        return;
                    }

                    // Recreate polygons from state
                    this.polygons = data.map(p => {
                        if (!p || !p.vertices || !Array.isArray(p.vertices) || p.vertices.length < 3) {
                            console.warn('Invalid polygon in state, skipping', p);
                            return null;
                        }
                        const poly = new Polygon(p.vertices, p.color || '#667eea');
                        poly.name = p.name || 'Polygon';
                        poly.visible = p.visible !== false; // Default to visible
                        return poly;
                    }).filter(p => p !== null); // Remove any null entries

                    // Restore selection by name first (more reliable), then by index
                    if (selectedName) {
                        const polyByName = this.polygons.find(p => p.name === selectedName);
                        if (polyByName) {
                            this.selectedPolygon = polyByName;
                        } else if (selectedIndex >= 0 && selectedIndex < this.polygons.length) {
                            this.selectedPolygon = this.polygons[selectedIndex];
                        } else {
                            this.selectedPolygon = null;
                        }
                    } else if (selectedIndex >= 0 && selectedIndex < this.polygons.length) {
                        this.selectedPolygon = this.polygons[selectedIndex];
                    } else {
                        this.selectedPolygon = null;
                    }

                    // Clear any invalid selections
                    if (this.selectedPolygon && !this.polygons.includes(this.selectedPolygon)) {
                        this.selectedPolygon = null;
                        this.selectedVertex = null;
                    }

                    this.updateProperties();
                    this.updateLayers();
                    this.markGridForRedraw();
                    // Force render to ensure canvas is updated immediately
                    this.render(true);
                } catch (e) {
                    console.error('Error loading state:', e);
                    // Don't crash - just log the error
                }
            }

            // Zoom functions
            zoomIn() {
                this.zoom = Math.min(5, this.zoom * 1.2);
                this.gridNeedsRedraw = true;
                this.lastGridState = null; // Force grid state recalculation
                this.render();
            }

            zoomOut() {
                this.zoom = Math.max(0.1, this.zoom / 1.2);
                this.gridNeedsRedraw = true;
                this.lastGridState = null; // Force grid state recalculation
                this.render();
            }

            zoomReset() {
                this.zoom = 1;
                this.pan = { x: 0, y: 0 };
                this.gridNeedsRedraw = true;
                this.lastGridState = null; // Force grid state recalculation
                this.render();
            }

            // Fullscreen functionality
            toggleFullscreen() {
                const element = document.documentElement;
                const fullscreenBtn = document.getElementById('fullscreenToggle');

                // Check if currently in fullscreen
                const isFullscreen = !!(document.fullscreenElement ||
                    document.webkitFullscreenElement ||
                    document.mozFullScreenElement ||
                    document.msFullscreenElement);

                if (!isFullscreen) {
                    // Enter fullscreen
                    if (element.requestFullscreen) {
                        element.requestFullscreen().catch(err => {
                            console.error('Error entering fullscreen:', err);
                        });
                    } else if (element.webkitRequestFullscreen) {
                        element.webkitRequestFullscreen();
                    } else if (element.mozRequestFullScreen) {
                        element.mozRequestFullScreen();
                    } else if (element.msRequestFullscreen) {
                        element.msRequestFullscreen();
                    }
                } else {
                    // Exit fullscreen
                    if (document.exitFullscreen) {
                        document.exitFullscreen().catch(err => {
                            console.error('Error exiting fullscreen:', err);
                        });
                    } else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen();
                    } else if (document.mozCancelFullScreen) {
                        document.mozCancelFullScreen();
                    } else if (document.msExitFullscreen) {
                        document.msExitFullscreen();
                    }
                }
            }

            handleFullscreenChange() {
                const fullscreenBtn = document.getElementById('fullscreenToggle');
                const isFullscreen = !!(document.fullscreenElement ||
                    document.webkitFullscreenElement ||
                    document.mozFullScreenElement ||
                    document.msFullscreenElement);

                if (fullscreenBtn) {
                    if (isFullscreen) {
                        fullscreenBtn.classList.add('active');
                        fullscreenBtn.textContent = 'â¤¡'; // Exit fullscreen icon
                        fullscreenBtn.title = 'Exit Fullscreen';
                        document.body.classList.add('fullscreen-active');
                    } else {
                        fullscreenBtn.classList.remove('active');
                        fullscreenBtn.textContent = 'â¤¢'; // Enter fullscreen icon
                        fullscreenBtn.title = 'Enter Fullscreen';
                        document.body.classList.remove('fullscreen-active');
                    }
                }

                // Resize canvas after a short delay to ensure dimensions are updated
                setTimeout(() => {
                    this.resizeCanvas();
                    // Re-center view on triangle if it exists
                    if (this.polygons.length > 0 && this.polygons[0].name === 'Triangle 1') {
                        const triangleCenter = this.getPolygonCenter(this.polygons[0]);
                        this.centerViewOn(triangleCenter.x, triangleCenter.y);
                    }
                    this.render();
                }, 100);
            }

            // Save/Load
            save() {
                const data = {
                    polygons: this.polygons.map(p => ({
                        vertices: p.vertices,
                        color: p.color,
                        name: p.name
                    }))
                };

                const json = JSON.stringify(data, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = 'geometry-playground.json';
                a.click();

                URL.revokeObjectURL(url);
            }

            load() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';

                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const data = JSON.parse(event.target.result);
                            this.polygons = data.polygons.map(p => {
                                const poly = new Polygon(p.vertices, p.color);
                                poly.name = p.name;
                                return poly;
                            });

                            this.selectedPolygon = null;
                            this.saveHistory();
                            this.updateProperties();
                            this.updateLayers();
                            this.render();
                        } catch (error) {
                            alert('Error loading file: ' + error.message);
                        }
                    };

                    reader.readAsText(file);
                };

                input.click();
            }

            reset() {
                const modal = document.getElementById('resetModal');
                if (modal) {
                    modal.style.display = 'flex';
                }
            }

            executeReset() {
                // Exit any active modes
                if (this.combineMode) this.exitCombineMode();
                if (this.splitMode) this.exitSplitMode();

                // switch to select tool to ensure UI is consistent
                this.setTool('select');

                this.polygons = [];
                this.selectedPolygon = null;
                this.selectedVertex = null;
                this.history = [];
                this.historyIndex = -1;
                this.zoom = 1;
                this.pan = { x: 0, y: 0 };

                this.createSamplePolygon();
                this.updateProperties(); // Clear properties panel
                this.updateLayers();
                this.render();
            }

            highlightConcept(concept) {
                // Visual feedback when learning concepts are clicked
                // Could be expanded to show specific examples on canvas
                console.log('Highlighting concept:', concept);
            }
        }

        // Polygon class
        class Polygon {
            constructor(vertices = [], color = '#667eea') {
                // Always create new point objects to ensure independence from other polygons
                this.vertices = vertices.map(v => ({ x: v.x, y: v.y }));
                this.color = color;
                this.name = 'Polygon';
                this.visible = true;
            }

            containsPoint(point) {
                let inside = false;
                const vertices = this.vertices;

                for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
                    const xi = vertices[i].x, yi = vertices[i].y;
                    const xj = vertices[j].x, yj = vertices[j].y;

                    const intersect = ((yi > point.y) !== (yj > point.y)) &&
                        (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);

                    if (intersect) inside = !inside;
                }

                return inside;
            }

            getArea() {
                // Shoelace formula
                let area = 0;
                const n = this.vertices.length;

                for (let i = 0; i < n; i++) {
                    const j = (i + 1) % n;
                    area += this.vertices[i].x * this.vertices[j].y;
                    area -= this.vertices[j].x * this.vertices[i].y;
                }

                return Math.abs(area / 2);
            }

            getPerimeter() {
                let perimeter = 0;
                const n = this.vertices.length;

                for (let i = 0; i < n; i++) {
                    const j = (i + 1) % n;
                    const dx = this.vertices[j].x - this.vertices[i].x;
                    const dy = this.vertices[j].y - this.vertices[i].y;
                    perimeter += Math.sqrt(dx * dx + dy * dy);
                }

                return perimeter;
            }

            move(dx, dy) {
                // Create new objects for vertices to break any shared references
                this.vertices = this.vertices.map(v => ({
                    x: v.x + dx,
                    y: v.y + dy
                }));
            }
        }

        // Mobile and Tablet menu toggle functionality
        function toggleMobileSidebar(sidebar) {
            const deviceInfo = deviceDetector ? deviceDetector.getInfo() : { isMobile: false, isTablet: false };
            const isMobile = deviceInfo.isMobile || window.innerWidth <= 768;
            const isTablet = deviceInfo.isTablet || (window.innerWidth > 768 && window.innerWidth <= 1024);

            // Enable for mobile and tablet devices
            if (isMobile || isTablet) {
                const wasOpen = sidebar.classList.contains('mobile-open');
                sidebar.classList.toggle('mobile-open');

                // Update backdrop - show only when sidebar is open as overlay
                const backdrop = document.getElementById('sidebarBackdrop');
                if (backdrop) {
                    if (sidebar.classList.contains('mobile-open')) {
                        // Sidebar is now open as overlay
                        backdrop.classList.add('active');
                        backdrop.addEventListener('click', closeMobileSidebars);
                    } else {
                        // Sidebar is now closed/visible normally
                        // Check if any other sidebar is open as overlay
                        const hasOpenSidebar = document.querySelector('.sidebar.mobile-open');
                        if (!hasOpenSidebar) {
                            backdrop.classList.remove('active');
                            backdrop.removeEventListener('click', closeMobileSidebars);
                        }
                    }
                }

                // On mobile, close other sidebars when opening one
                if (isMobile) {
                    document.querySelectorAll('.sidebar').forEach(s => {
                        if (s !== sidebar) {
                            s.classList.remove('mobile-open');
                        }
                    });
                }
            }
        }

        function closeMobileSidebars() {
            document.querySelectorAll('.sidebar').forEach(s => {
                s.classList.remove('mobile-open');
            });
            const backdrop = document.getElementById('sidebarBackdrop');
            if (backdrop) {
                backdrop.classList.remove('active');
                backdrop.removeEventListener('click', closeMobileSidebars);
            }
        }


        // Setup back button handlers for panels
        function setupPanelBackButtons() {
            // Layers panel back button
            const layersBackBtn = document.getElementById('layersBackBtn');
            if (layersBackBtn) {
                // Remove any existing listeners to prevent duplicates
                const newLayersBtn = layersBackBtn.cloneNode(true);
                layersBackBtn.parentNode.replaceChild(newLayersBtn, layersBackBtn);

                newLayersBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    const layersSidebar = document.querySelector('.sidebar:not(.sidebar-right)');
                    if (layersSidebar) {
                        const deviceInfo = deviceDetector ? deviceDetector.getInfo() : { isMobile: false, isTablet: false };
                        const isMobile = deviceInfo.isMobile || window.innerWidth <= 768;
                        const isTablet = deviceInfo.isTablet || (window.innerWidth > 768 && window.innerWidth <= 1024);

                        if (isMobile) {
                            // On mobile, close the overlay
                            closeMobileSidebars();
                        } else if (isTablet) {
                            // On tablet, toggle sidebar visibility (hide/show)
                            toggleMobileSidebar(layersSidebar);
                        }
                    }
                });
            }

            // Visualizers panel back button
            const visualizersBackBtn = document.getElementById('visualizersBackBtn');
            if (visualizersBackBtn) {
                // Remove any existing listeners to prevent duplicates
                const newVisualizersBtn = visualizersBackBtn.cloneNode(true);
                visualizersBackBtn.parentNode.replaceChild(newVisualizersBtn, visualizersBackBtn);

                newVisualizersBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    const visualizersSidebar = document.querySelector('.sidebar-right');
                    if (visualizersSidebar) {
                        const deviceInfo = deviceDetector ? deviceDetector.getInfo() : { isMobile: false, isTablet: false };
                        const isMobile = deviceInfo.isMobile || window.innerWidth <= 768;
                        const isTablet = deviceInfo.isTablet || (window.innerWidth > 768 && window.innerWidth <= 1024);

                        if (isMobile) {
                            // On mobile, close the overlay
                            closeMobileSidebars();
                        } else if (isTablet) {
                            // On tablet, toggle sidebar visibility (hide/show)
                            toggleMobileSidebar(visualizersSidebar);
                        }
                    }
                });
            }
        }

        // Add mobile menu buttons if needed (tablets show sidebars by default, but buttons available for toggling)
        function setupMobileMenus() {
            const deviceInfo = deviceDetector ? deviceDetector.getInfo() : { isMobile: false, isTablet: false };
            const isMobile = deviceInfo.isMobile || window.innerWidth <= 768;
            const isTablet = deviceInfo.isTablet || (window.innerWidth > 768 && window.innerWidth <= 1024);

            // Show toggle buttons on mobile (required) and optionally on tablets (for overlay mode)
            if (isMobile || isTablet) {
                // Add menu toggle buttons to canvas container
                const canvasContainer = document.getElementById('canvasContainer');

                // Calculate position below toolbar
                // Top tools bar height + Toolbar height + small gap
                const topToolsBar = document.querySelector('.top-tools-bar');
                const toolbar = document.querySelector('.toolbar');
                let topOffset = 12; // Default gap

                if (topToolsBar && toolbar) {
                    const topToolsBarHeight = topToolsBar.getBoundingClientRect().height;
                    const toolbarHeight = toolbar.getBoundingClientRect().height;
                    topOffset = topToolsBarHeight + toolbarHeight + 8; // 8px gap below toolbar
                } else {
                    // Fallback calculation based on CSS values
                    // Top tools bar: clamp(48px, 6vw, 56px) + mobile offset clamp(10px, 2vw, 15px)
                    // Toolbar: clamp(48px, 6vw, 56px) to clamp(60px, 8vw, 70px)
                    const viewportWidth = window.innerWidth;
                    const topBarHeight = Math.max(48, Math.min(56, viewportWidth * 0.06)) +
                        (viewportWidth <= 768 ? Math.max(10, Math.min(15, viewportWidth * 0.02)) : 0);
                    const toolbarHeight = Math.max(48, Math.min(70, viewportWidth * 0.08));
                    topOffset = topBarHeight + toolbarHeight + 8;
                }

                // Left sidebar toggle (Layers)
                let leftToggle = document.getElementById('mobileMenuLeft');
                if (!leftToggle) {
                    leftToggle = document.createElement('button');
                    leftToggle.id = 'mobileMenuLeft';
                    leftToggle.className = 'mobile-menu-toggle';
                    leftToggle.innerHTML = '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><rect x="7" y="7" width="10" height="10" rx="1" ry="1"/><rect x="11" y="11" width="6" height="6" rx="0.5" ry="0.5"/></svg>';
                    leftToggle.setAttribute('aria-label', 'Toggle Layers Panel');
                    leftToggle.style.left = '12px';
                    leftToggle.addEventListener('click', (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        const sidebar = document.querySelector('.sidebar:not(.sidebar-right)');
                        if (sidebar) toggleMobileSidebar(sidebar);
                    });
                    canvasContainer.appendChild(leftToggle);
                }
                // Update position
                leftToggle.style.top = `${topOffset}px`;

                // Right sidebar toggle (Visualizers)
                let rightToggle = document.getElementById('mobileMenuRight');
                if (!rightToggle) {
                    rightToggle = document.createElement('button');
                    rightToggle.id = 'mobileMenuRight';
                    rightToggle.className = 'mobile-menu-toggle';
                    rightToggle.innerHTML = 'ðŸ‘ï¸';
                    rightToggle.setAttribute('aria-label', 'Toggle Visualizers Panel');
                    rightToggle.style.right = '12px';
                    rightToggle.addEventListener('click', (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        const sidebar = document.querySelector('.sidebar-right');
                        if (sidebar) toggleMobileSidebar(sidebar);
                    });
                    canvasContainer.appendChild(rightToggle);
                }
                // Update position
                rightToggle.style.top = `${topOffset}px`;
            } else {
                // Remove mobile menu buttons on desktop
                const leftToggle = document.getElementById('mobileMenuLeft');
                const rightToggle = document.getElementById('mobileMenuRight');
                if (leftToggle) leftToggle.remove();
                if (rightToggle) rightToggle.remove();
            }
        }

        // Initialize application
        let app;
        window.addEventListener('load', () => {
            // Initialize device detector first
            deviceDetector = new DeviceDetector();

            // Setup panel back buttons
            setupPanelBackButtons();

            app = new PolygonPlayground();

            // Setup mobile menus
            setupMobileMenus();

            // Update mobile menus on resize and orientation change
            window.addEventListener('deviceResize', setupMobileMenus);
            window.addEventListener('resize', () => {
                // Debounce resize to avoid too many calls
                clearTimeout(window.mobileMenuResizeTimeout);
                window.mobileMenuResizeTimeout = setTimeout(() => {
                    setupMobileMenus();
                }, 100);
            });
            window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                    setupMobileMenus();
                }, 200);
            });

            // Example: Set up telemetry callbacks
            app.setTelemetryCallbacks({
                onShapeMenuOpen: () => {
                    console.log('Shape menu opened');
                    // Track analytics event
                },
                onShapeMenuClose: () => {
                    console.log('Shape menu closed');
                    // Track analytics event
                },
                onShapeSelect: (data) => {
                    console.log('Shape selected:', data);
                    // Track shape creation: data.type, data.sides, data.polygon
                }
            });
        });

        function closeTutorial() {
            document.getElementById('tutorialOverlay').style.display = 'none';
        }

        // Example component usage for integration
        class CreatePolygonButton {
            constructor(container, options = {}) {
                this.container = container;
                this.options = {
                    onOpen: options.onOpen || (() => { }),
                    onClose: options.onClose || (() => { }),
                    onSelect: options.onSelect || (() => { }),
                    keyboard: options.keyboard || 'Ctrl+N',
                    shapes: options.shapes || [
                        { type: 'triangle', sides: 3, hint: '3 sides', icon: 'â–²' },
                        { type: 'square', sides: 4, hint: '4 equal sides', icon: 'â– ' },
                        { type: 'rectangle', sides: 4, hint: '4 sides', icon: 'â–¬' },
                        { type: 'pentagon', sides: 5, hint: '5 sides', icon: 'â¬Ÿ' },
                        { type: 'hexagon', sides: 6, hint: '6 sides', icon: 'â¬¢' },
                        { type: 'heptagon', sides: 7, hint: '7 sides (Septagon)', icon: 'â¬ ' },
                        { type: 'octagon', sides: 8, hint: '8 sides', icon: 'â¬¡' }
                    ]
                };
            }

            // Component methods for external integration
            open() { if (app) app.openShapeMenu(); }
            close() { if (app) app.closeShapeMenu(); }
            toggle() { if (app) app.toggleShapeMenu(); }
            createShape(type) {
                if (app) {
                    const option = document.querySelector(`[data-shape="${type}"]`);
                    if (option) app.selectShape(option);
                }
            }
        }

        // Geometry Utilities for Polygon Boolean Operations (Union & Split)
        class PolygonBoolean {
            // ... [Union Methods from previous implementation] ...

            // NEW: Split Method
            static split(polygon, lineStart, lineEnd) {
                const vertices = polygon.vertices;
                const intersections = [];
                const cutLine = { p1: lineStart, p2: lineEnd };

                for (let i = 0; i < vertices.length; i++) {
                    const current = vertices[i];
                    const next = vertices[(i + 1) % vertices.length];
                    const seg = { p1: current, p2: next };

                    const inter = this.getIntersectionInfiniteLine(seg, cutLine);
                    if (inter) {
                        intersections.push({
                            point: inter,
                            edgeIndex: i,
                            dist: this.distSq(current, inter)
                        });
                    }
                }

                if (intersections.length < 2) return null;

                // Sort intersections by edge index then distance
                intersections.sort((a, b) => {
                    if (a.edgeIndex !== b.edgeIndex) return a.edgeIndex - b.edgeIndex;
                    return a.dist - b.dist;
                });

                // Deduplicate intersections (esp. at vertices) per edge
                const uniqueInts = [];
                intersections.forEach(i => {
                    if (!uniqueInts.some(ui => ui.edgeIndex === i.edgeIndex && this.distSq(ui.point, i.point) < 0.0001)) {
                        uniqueInts.push(i);
                    }
                });

                const newSegs = [];
                let intIdx = 0;

                // 1. Build boundary segments with inserted intersection points
                for (let i = 0; i < vertices.length; i++) {
                    let lastP = vertices[i];
                    while (intIdx < uniqueInts.length && uniqueInts[intIdx].edgeIndex === i) {
                        const midP = uniqueInts[intIdx].point;
                        if (this.distSq(lastP, midP) > 0.0001) {
                            newSegs.push({ p1: { ...lastP }, p2: { ...midP } });
                        }
                        lastP = midP;
                        intIdx++;
                    }
                    if (this.distSq(lastP, vertices[(i + 1) % vertices.length]) > 0.0001) {
                        newSegs.push({ p1: { ...lastP }, p2: { ...vertices[(i + 1) % vertices.length] } });
                    }
                }

                // 2. Identify and add bridge segments (internal cut line segments)
                const bridgePoints = [];
                uniqueInts.forEach(ui => {
                    if (!bridgePoints.some(bp => this.distSq(bp, ui.point) < 0.0001)) {
                        bridgePoints.push(ui.point);
                    }
                });

                const proj = (p) => {
                    const dx = lineEnd.x - lineStart.x;
                    const dy = lineEnd.y - lineStart.y;
                    return ((p.x - lineStart.x) * dx + (p.y - lineStart.y) * dy);
                };
                bridgePoints.sort((a, b) => proj(a) - proj(b));

                for (let i = 0; i < bridgePoints.length - 1; i++) {
                    const mid = {
                        x: (bridgePoints[i].x + bridgePoints[i + 1].x) / 2,
                        y: (bridgePoints[i].y + bridgePoints[i + 1].y) / 2
                    };
                    // midpoint must be inside the original polygon
                    if (this.pointRelation(mid, vertices) === -1) {
                        newSegs.push({ p1: { ...bridgePoints[i] }, p2: { ...bridgePoints[i + 1] } });
                    }
                }

                const pieces = this.linkSegments(newSegs);
                return (pieces && pieces.length >= 2) ? pieces : null;
            }

            static isPointInside(p, vertices) {
                return this.pointRelation(p, vertices) === -1;
            }

            static getIntersectionInfiniteLine(seg, line) {
                // Line: p1, p2. Seg: p3, p4
                const x1 = line.p1.x, y1 = line.p1.y;
                const x2 = line.p2.x, y2 = line.p2.y;
                const x3 = seg.p1.x, y3 = seg.p1.y;
                const x4 = seg.p2.x, y4 = seg.p2.y;

                const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
                if (Math.abs(denom) < 1e-10) return null; // Parallel

                const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
                const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;

                // ub must be between 0 and 1 (segment) with a small epsilon
                const EPS = 1e-8;
                if (ub >= -EPS && ub <= 1 + EPS) {
                    return {
                        x: x1 + ua * (x2 - x1),
                        y: y1 + ua * (y2 - y1)
                    };
                }
                return null;
            }

            static isPointInside(p, vertices) {
                return this.pointRelation(p, vertices) === -1;
            }
            static union(polygons) {
                if (!polygons || polygons.length < 2) {
                    console.warn('Union requires at least 2 polygons');
                    return null;
                }

                // Validate all input polygons have valid vertices
                for (let i = 0; i < polygons.length; i++) {
                    if (!polygons[i] || !polygons[i].vertices || polygons[i].vertices.length < 3) {
                        console.warn(`Polygon ${i} is invalid for union`, polygons[i]);
                        return null;
                    }
                }

                let result = this.cleanPolygon(polygons[0].vertices);
                if (!result || result.length < 3) {
                    console.warn('First polygon cleaning failed');
                    return null;
                }

                for (let i = 1; i < polygons.length; i++) {
                    const clip = this.cleanPolygon(polygons[i].vertices);
                    if (!clip || clip.length < 3) continue;

                    const combinedCycles = this.unionTwoPolygons(result, clip);

                    if (combinedCycles && Array.isArray(combinedCycles) && combinedCycles.length > 0) {
                        // Get only the outer boundary cycle (largest area, containing all others)
                        const outerBoundary = this.getOuterBoundary(combinedCycles);
                        if (outerBoundary && Array.isArray(outerBoundary) && outerBoundary.length >= 3) {
                            // Validate the outer boundary has valid vertices
                            const hasValidVertices = outerBoundary.every(v =>
                                v && typeof v.x === 'number' && typeof v.y === 'number' &&
                                isFinite(v.x) && isFinite(v.y)
                            );
                            if (hasValidVertices) {
                                result = outerBoundary;
                            } else {
                                console.warn('Union failed: outer boundary has invalid vertices');
                                return null;
                            }
                        } else {
                            // If getOuterBoundary fails, the union operation failed
                            console.warn('Union failed: could not determine outer boundary', {
                                cyclesCount: combinedCycles.length,
                                outerBoundary: outerBoundary ? outerBoundary.length : 'null'
                            });
                            return null;
                        }
                    } else {
                        // If no cycles returned, check what happened
                        // This could mean:
                        // 1. Polygons are completely disjoint (no overlap)
                        // 2. One polygon is completely inside the other (should have been handled)
                        // 3. Union algorithm failed due to edge case

                        console.warn('Union returned no cycles', {
                            resultLength: result.length,
                            clipLength: clip.length
                        });

                        // Check if polygons overlap or touch
                        let hasOverlap = false;
                        let areTouching = false;

                        // Check vertex overlap
                        for (let v of clip) {
                            const rel = this.pointRelation(v, result);
                            if (rel !== 1) { // Inside or on boundary
                                hasOverlap = true;
                                break;
                            }
                        }
                        if (!hasOverlap) {
                            for (let v of result) {
                                const rel = this.pointRelation(v, clip);
                                if (rel !== 1) { // Inside or on boundary
                                    hasOverlap = true;
                                    break;
                                }
                            }
                        }

                        // Check if polygons are touching (edges intersect or share vertices)
                        if (!hasOverlap) {
                            const segsResult = this.getSegments(result);
                            const segsClip = this.getSegments(clip);
                            for (let s1 of segsResult) {
                                for (let s2 of segsClip) {
                                    const inter = this.getIntersection(s1.p1, s1.p2, s2.p1, s2.p2);
                                    if (inter) {
                                        areTouching = true;
                                        break;
                                    }
                                    // Check if segments share endpoints
                                    if (this.distSq(s1.p1, s2.p1) < 1e-6 || this.distSq(s1.p1, s2.p2) < 1e-6 ||
                                        this.distSq(s1.p2, s2.p1) < 1e-6 || this.distSq(s1.p2, s2.p2) < 1e-6) {
                                        areTouching = true;
                                        break;
                                    }
                                }
                                if (areTouching) break;
                            }
                        }

                        if (!hasOverlap && !areTouching) {
                            // Return empty array instead of null for clearer handling
                            // This specifically indicates disjoint polygons (can't be combined)
                            console.warn('Polygons are disjoint - cannot combine');
                            return [];
                        } else {
                            // Polygons overlap or touch but union failed
                            // Try to create a bounding polygon as fallback
                            const allVertices = [...result, ...clip];
                            const boundingPoly = this.createBoundingPolygon(allVertices);
                            if (boundingPoly && boundingPoly.length >= 3) {
                                console.warn('Using bounding polygon fallback for union');
                                return boundingPoly;
                            }
                            console.warn('Union failed: polygons overlap but could not create result');
                            return [];
                        }
                    }
                }

                // Final validation of result
                if (result && Array.isArray(result) && result.length >= 3) {
                    // Validate all vertices are valid
                    const hasValidVertices = result.every(v =>
                        v && typeof v.x === 'number' && typeof v.y === 'number' &&
                        isFinite(v.x) && isFinite(v.y)
                    );
                    return hasValidVertices ? result : null;
                }
                return null;
            }

            // Get the outer boundary cycle from multiple cycles, discarding internal ones
            static getOuterBoundary(cycles) {
                if (!cycles || cycles.length === 0) return null;
                if (cycles.length === 1) return cycles[0];

                // Calculate area for each cycle and check containment
                const cyclesWithInfo = cycles.map(cycle => ({
                    cycle: cycle,
                    area: Math.abs(this.getArea(cycle))
                }));

                // Sort by area (largest first)
                cyclesWithInfo.sort((a, b) => b.area - a.area);

                // Find the outermost cycle (not contained by any other)
                for (let i = 0; i < cyclesWithInfo.length; i++) {
                    const candidate = cyclesWithInfo[i].cycle;
                    let isContained = false;

                    // Check if this cycle is contained by any larger cycle
                    for (let j = 0; j < i; j++) {
                        const largerCycle = cyclesWithInfo[j].cycle;
                        // Test a point from candidate cycle
                        const testPoint = candidate[0];
                        if (this.pointRelation(testPoint, largerCycle) === -1) {
                            isContained = true;
                            break;
                        }
                    }

                    // If not contained, this is an outer boundary
                    if (!isContained) {
                        return candidate;
                    }
                }

                // Fallback: return the largest cycle
                return cyclesWithInfo[0].cycle;
            }

            // New static method to merge multiple disjoint cycles into a single path
            static mergeCycles(cycles) {
                if (!cycles || cycles.length === 0) return [];
                if (cycles.length === 1) return cycles[0];

                // Start with the first cycle
                let result = [...cycles[0]];
                const remaining = cycles.slice(1);

                while (remaining.length > 0) {
                    let bestDist = Infinity;
                    let bridgeFrom = -1;
                    let bridgeToCycleIdx = -1;
                    let bridgeToVertexIdx = -1;

                    // Find the closest pair of vertices between the current result and any remaining cycle
                    for (let i = 0; i < result.length; i++) {
                        const p1 = result[i];
                        for (let c = 0; c < remaining.length; c++) {
                            const cycle = remaining[c];
                            for (let j = 0; j < cycle.length; j++) {
                                const p2 = cycle[j];
                                const d = this.distSq(p1, p2);
                                if (d < bestDist) {
                                    bestDist = d;
                                    bridgeFrom = i;
                                    bridgeToCycleIdx = c;
                                    bridgeToVertexIdx = j;
                                }
                            }
                        }
                    }

                    if (bridgeToCycleIdx !== -1) {
                        const targetCycle = remaining[bridgeToCycleIdx];

                        // Reorder target cycle to start from the bridge vertex
                        const reordered = [
                            ...targetCycle.slice(bridgeToVertexIdx),
                            ...targetCycle.slice(0, bridgeToVertexIdx)
                        ];

                        // Insert the new cycle into the result at the bridge point
                        // Path: ... -> From -> To -> ...targetCycle... -> To -> From -> ...
                        const bridgePointFrom = result[bridgeFrom];
                        const bridgePointTo = reordered[0];

                        const newPart = [
                            bridgePointFrom,
                            ...reordered,
                            bridgePointTo,
                            bridgePointFrom
                        ];

                        result.splice(bridgeFrom + 1, 0, ...newPart);
                        remaining.splice(bridgeToCycleIdx, 1);
                    } else {
                        break;
                    }
                }

                return result;
            }

            static cleanPolygon(vertices) {
                let clean = [];
                for (let i = 0; i < vertices.length; i++) {
                    const current = vertices[i];
                    const next = vertices[(i + 1) % vertices.length];
                    if (this.distSq(current, next) > 0.0001) {
                        clean.push({ x: current.x, y: current.y });
                    }
                }
                if (clean.length < 3) return clean;
                return this.ensureClockwise(clean);
            }

            static unionTwoPolygons(polyA, polyB) {
                let segsA = this.getSegments(polyA);
                let segsB = this.getSegments(polyB);
                const allSegs = this.fragmentSegments(segsA, segsB);
                const keptSegs = [];
                const EPSILON = 1e-4;

                // Check if one polygon is completely inside the other
                // Test center points and a few vertices
                const testPointsA = [
                    this.getPolygonCenter(polyA),
                    polyA[0],
                    polyA[Math.floor(polyA.length / 2)]
                ].filter(p => p);

                const testPointsB = [
                    this.getPolygonCenter(polyB),
                    polyB[0],
                    polyB[Math.floor(polyB.length / 2)]
                ].filter(p => p);

                let aCompletelyInB = true;
                let bCompletelyInA = true;

                for (let p of testPointsA) {
                    if (this.pointRelation(p, polyB) === 1) {
                        aCompletelyInB = false;
                        break;
                    }
                }

                for (let p of testPointsB) {
                    if (this.pointRelation(p, polyA) === 1) {
                        bCompletelyInA = false;
                        break;
                    }
                }

                // If one is completely inside the other, return the outer one
                // This is correct union behavior - the union of A inside B is just B
                // However, we need to ensure this is properly handled in executeCombine
                if (aCompletelyInB && !bCompletelyInA) {
                    // A is completely inside B - union is B
                    return [polyB];
                } else if (bCompletelyInA && !aCompletelyInB) {
                    // B is completely inside A - union is A
                    return [polyA];
                }
                // If both are inside each other (shouldn't happen for valid polygons), proceed with normal union

                for (let seg of allSegs) {
                    const otherPoly = seg.origin === 'A' ? polyB : polyA;

                    // Check multiple points along the segment, not just the midpoint
                    // This is crucial for overlapping triangles where midpoint might be inside
                    // but the segment is partially outside
                    const testPoints = [
                        seg.p1,
                        this.getMidpoint(seg),
                        seg.p2,
                        { x: seg.p1.x + (seg.p2.x - seg.p1.x) * 0.25, y: seg.p1.y + (seg.p2.y - seg.p1.y) * 0.25 },
                        { x: seg.p1.x + (seg.p2.x - seg.p1.x) * 0.75, y: seg.p1.y + (seg.p2.y - seg.p1.y) * 0.75 }
                    ];

                    let allInside = true;
                    let allOutside = true;
                    let anyOnBoundary = false;

                    for (let testPoint of testPoints) {
                        const relation = this.pointRelation(testPoint, otherPoly);
                        if (relation === 0) {
                            anyOnBoundary = true;
                            allInside = false;
                            allOutside = false;
                        } else if (relation === 1) {
                            allInside = false;
                        } else if (relation === -1) {
                            allOutside = false;
                        }
                    }

                    if (allOutside) {
                        // All points outside - always keep
                        keptSegs.push(seg);
                    } else if (allInside && !anyOnBoundary) {
                        // All points strictly inside - discard
                        continue;
                    } else {
                        // Segment is partially inside/outside or on boundary
                        // Check for shared/overlapping segments
                        const otherSegs = allSegs.filter(s => s.origin !== seg.origin);
                        const matching = otherSegs.find(s =>
                            (this.distSq(s.p1, seg.p1) < EPSILON && this.distSq(s.p2, seg.p2) < EPSILON) ||
                            (this.distSq(s.p1, seg.p2) < EPSILON && this.distSq(s.p2, seg.p1) < EPSILON)
                        );

                        if (matching) {
                            // It's a shared edge
                            const isSameDirection = this.distSq(seg.p1, matching.p1) < EPSILON;

                            if (isSameDirection) {
                                // Same direction - keep one (from polygon A) to avoid duplication
                                if (seg.origin === 'A') {
                                    keptSegs.push(seg);
                                }
                            } else {
                                // Opposite direction - check if it's truly internal
                                // Test a point slightly offset from the segment to see if it's inside both
                                const offsetDir = {
                                    x: (seg.p2.y - seg.p1.y) * 0.0001,
                                    y: -(seg.p2.x - seg.p1.x) * 0.0001
                                };
                                const offsetPoint = {
                                    x: this.getMidpoint(seg).x + offsetDir.x,
                                    y: this.getMidpoint(seg).y + offsetDir.y
                                };
                                const offsetInA = this.pointRelation(offsetPoint, polyA);
                                const offsetInB = this.pointRelation(offsetPoint, polyB);

                                // If offset is inside both, it's truly internal - discard
                                // Otherwise, it's on the boundary - keep one
                                if (offsetInA === -1 && offsetInB === -1) {
                                    // Truly internal, discard
                                } else {
                                    // On boundary, keep one
                                    if (seg.origin === 'A') {
                                        keptSegs.push(seg);
                                    }
                                }
                            }
                            continue;
                        } else {
                            // Not shared - must be part of the union boundary
                            keptSegs.push(seg);
                        }
                    }
                }

                // If no segments kept, one polygon might be completely inside the other
                // This should have been caught above, but as a fallback:
                if (keptSegs.length === 0) {
                    console.warn('No segments kept in union - one polygon may be inside another', {
                        polyALength: polyA.length,
                        polyBLength: polyB.length,
                        aInB: aCompletelyInB,
                        bInA: bCompletelyInA
                    });
                    // Return the larger polygon as union
                    const areaA = Math.abs(this.getArea(polyA));
                    const areaB = Math.abs(this.getArea(polyB));
                    return areaA >= areaB ? [polyA] : [polyB];
                }

                const cycles = this.linkSegments(keptSegs);

                // If linkSegments fails but we had segments, log warning
                if (!cycles || cycles.length === 0) {
                    console.warn('linkSegments returned no cycles despite having segments', {
                        keptSegsCount: keptSegs.length,
                        polyALength: polyA.length,
                        polyBLength: polyB.length
                    });
                    // Return null to indicate failure - let the calling code handle it
                    return null;
                }

                return cycles;
            }

            static getPolygonCenter(vertices) {
                if (!vertices || vertices.length === 0) return null;
                const sum = vertices.reduce((acc, v) => ({ x: acc.x + v.x, y: acc.y + v.y }), { x: 0, y: 0 });
                return { x: sum.x / vertices.length, y: sum.y / vertices.length };
            }

            static createBoundingPolygon(vertices) {
                if (!vertices || vertices.length < 3) return null;

                // Remove duplicate vertices first
                const unique = [];
                const seen = new Set();
                for (let v of vertices) {
                    const key = `${Math.round(v.x * 1000)},${Math.round(v.y * 1000)}`;
                    if (!seen.has(key)) {
                        seen.add(key);
                        unique.push({ x: v.x, y: v.y });
                    }
                }

                if (unique.length < 3) return null;

                // Find convex hull using Graham scan
                // First, find the bottom-most point (or leftmost in case of tie)
                let start = 0;
                for (let i = 1; i < unique.length; i++) {
                    if (unique[i].y < unique[start].y ||
                        (unique[i].y === unique[start].y && unique[i].x < unique[start].x)) {
                        start = i;
                    }
                }

                // Sort points by polar angle with respect to start point
                const sorted = unique.map((v, i) => ({ ...v, idx: i }))
                    .filter((v, i) => i !== start)
                    .sort((a, b) => {
                        const angleA = Math.atan2(a.y - unique[start].y, a.x - unique[start].x);
                        const angleB = Math.atan2(b.y - unique[start].y, b.x - unique[start].x);
                        if (Math.abs(angleA - angleB) < 1e-6) {
                            const distA = this.distSq(a, unique[start]);
                            const distB = this.distSq(b, unique[start]);
                            return distA - distB;
                        }
                        return angleA - angleB;
                    });

                const hull = [{ x: unique[start].x, y: unique[start].y }];
                for (let point of sorted) {
                    while (hull.length > 1) {
                        const p1 = hull[hull.length - 2];
                        const p2 = hull[hull.length - 1];
                        const cross = (p2.x - p1.x) * (point.y - p1.y) - (p2.y - p1.y) * (point.x - p1.x);
                        if (cross <= 0) break;
                        hull.pop();
                    }
                    hull.push({ x: point.x, y: point.y });
                }

                // Ensure we have at least 3 points and close the hull
                if (hull.length >= 3) {
                    // Make sure it's closed (first and last should be same, or close enough)
                    const first = hull[0];
                    const last = hull[hull.length - 1];
                    if (this.distSq(first, last) > 1e-6) {
                        hull.push({ x: first.x, y: first.y });
                    }
                    return this.ensureClockwise(hull);
                }

                return null;
            }

            static getSegments(vertices) {
                const segs = [];
                for (let i = 0; i < vertices.length; i++) {
                    segs.push({
                        p1: { ...vertices[i] },
                        p2: { ...vertices[(i + 1) % vertices.length] },
                        origin: null
                    });
                }
                return segs;
            }

            static fragmentSegments(segsA, segsB) {
                segsA.forEach(s => s.origin = 'A');
                segsB.forEach(s => s.origin = 'B');

                const all = [...segsA, ...segsB];
                const cuts = new Map();
                for (let i = 0; i < all.length; i++) {
                    cuts.set(i, [0, 1]);
                }

                for (let i = 0; i < all.length; i++) {
                    for (let j = i + 1; j < all.length; j++) {
                        const s1 = all[i];
                        const s2 = all[j];

                        if (Math.min(s1.p1.x, s1.p2.x) > Math.max(s2.p1.x, s2.p2.x) ||
                            Math.max(s1.p1.x, s1.p2.x) < Math.min(s2.p1.x, s2.p2.x) ||
                            Math.min(s1.p1.y, s1.p2.y) > Math.max(s2.p1.y, s2.p2.y) ||
                            Math.max(s1.p1.y, s1.p2.y) < Math.min(s2.p1.y, s2.p2.y)) continue;

                        const inter = this.getIntersection(s1.p1, s1.p2, s2.p1, s2.p2);
                        if (inter) {
                            const getT = (seg, p) => {
                                const dx = seg.p2.x - seg.p1.x;
                                const dy = seg.p2.y - seg.p1.y;
                                if (Math.abs(dx) > Math.abs(dy)) {
                                    return (p.x - seg.p1.x) / dx;
                                } else {
                                    return (p.y - seg.p1.y) / dy;
                                }
                            };

                            const t1 = getT(s1, inter);
                            const t2 = getT(s2, inter);

                            const T_EPS = 1e-5;
                            if (t1 > T_EPS && t1 < 1 - T_EPS) cuts.get(i).push(t1);
                            if (t2 > T_EPS && t2 < 1 - T_EPS) cuts.get(j).push(t2);
                        }
                    }
                }

                const result = [];
                for (let i = 0; i < all.length; i++) {
                    const seg = all[i];
                    const ts = cuts.get(i).sort((a, b) => a - b);
                    const uniqueTs = [];
                    let last = -1;
                    ts.forEach(t => {
                        if (Math.abs(t - last) > 1e-5) {
                            uniqueTs.push(t);
                            last = t;
                        }
                    });

                    for (let k = 0; k < uniqueTs.length - 1; k++) {
                        const tStart = uniqueTs[k];
                        const tEnd = uniqueTs[k + 1];

                        const pStart = {
                            x: seg.p1.x + (seg.p2.x - seg.p1.x) * tStart,
                            y: seg.p1.y + (seg.p2.y - seg.p1.y) * tStart
                        };
                        const pEnd = {
                            x: seg.p1.x + (seg.p2.x - seg.p1.x) * tEnd,
                            y: seg.p1.y + (seg.p2.y - seg.p1.y) * tEnd
                        };

                        result.push({
                            p1: pStart,
                            p2: pEnd,
                            origin: seg.origin
                        });
                    }
                }
                return result;
            }

            static linkSegments(segments) {
                if (segments.length === 0) return null;

                const verts = [];
                const EPSILON = 0.001;
                const getVertIdx = (p) => {
                    for (let i = 0; i < verts.length; i++) {
                        if (this.distSq(verts[i], p) < EPSILON) return i;
                    }
                    verts.push(p);
                    return verts.length - 1;
                };

                const adj = new Map();
                const addEdge = (u, v) => {
                    if (u === v) return;
                    if (!adj.has(u)) adj.set(u, []);
                    if (!adj.get(u).includes(v)) adj.get(u).push(v);
                };

                segments.forEach(seg => {
                    const u = getVertIdx(seg.p1);
                    const v = getVertIdx(seg.p2);
                    addEdge(u, v);
                    addEdge(v, u); // Make it bidirectional for full face traversal
                });

                if (adj.size === 0) return null;

                const cycles = [];
                const visitedDir = new Set();

                // Trace all cycles in the planar graph
                for (let u of adj.keys()) {
                    const neighbors = adj.get(u);
                    for (let v of neighbors) {
                        const key = `${u},${v}`;
                        if (visitedDir.has(key)) continue;

                        const path = [verts[u]];
                        let curr = v;
                        let prev = u;
                        visitedDir.add(key);

                        let closed = false;
                        let steps = 0;
                        while (steps < segments.length * 4) {
                            if (curr === u) {
                                closed = true;
                                break;
                            }
                            path.push(verts[curr]);

                            const nList = adj.get(curr);
                            const angleIn = Math.atan2(verts[curr].y - verts[prev].y, verts[curr].x - verts[prev].x);
                            const backRay = angleIn + Math.PI;

                            let bestNext = -1;
                            let maxTurn = -Infinity;

                            for (let next of nList) {
                                if (next === prev && nList.length > 1) continue;

                                let angleOut = Math.atan2(verts[next].y - verts[curr].y, verts[next].x - verts[curr].x);
                                let relAngle = angleOut - backRay;
                                while (relAngle < 0) relAngle += Math.PI * 2;
                                while (relAngle >= Math.PI * 2) relAngle -= Math.PI * 2;

                                // Maximize relAngle for Rightmost turn (interior faces in CW winding)
                                if (bestNext === -1 || relAngle > maxTurn) {
                                    maxTurn = relAngle;
                                    bestNext = next;
                                }
                            }

                            if (bestNext !== -1) {
                                visitedDir.add(`${curr},${bestNext}`);
                                prev = curr;
                                curr = bestNext;
                                steps++;
                            } else {
                                break;
                            }
                        }

                        if (closed && path.length >= 3) {
                            // Keep cycles with positive area
                            // Reduced threshold to handle small triangles and thin overlapping regions
                            const area = Math.abs(this.getArea(path));
                            if (area > 1e-6) { // Very small threshold to keep valid cycles
                                cycles.push(path);
                            }
                        }
                    }
                }

                return cycles.length > 0 ? cycles : null;
            }

            static getMidpoint(seg) {
                return {
                    x: (seg.p1.x + seg.p2.x) / 2,
                    y: (seg.p1.y + seg.p2.y) / 2
                };
            }

            static getIntersection(p1, p2, p3, p4) {
                const d = (p2.x - p1.x) * (p4.y - p3.y) - (p2.y - p1.y) * (p4.x - p3.x);
                if (Math.abs(d) < 1e-9) return null;

                const u = ((p3.x - p1.x) * (p4.y - p3.y) - (p3.y - p1.y) * (p4.x - p3.x)) / d;
                const v = ((p3.x - p1.x) * (p2.y - p1.y) - (p3.y - p1.y) * (p2.x - p1.x)) / d;

                if (u > 1e-6 && u < 1 - 1e-6 && v > 1e-6 && v < 1 - 1e-6) {
                    return {
                        x: p1.x + u * (p2.x - p1.x),
                        y: p1.y + u * (p2.y - p1.y)
                    };
                }
                return null;
            }

            static pointRelation(p, vertices) {
                const EPSILON = 1e-6;
                let inside = false;

                for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
                    const A = vertices[i];
                    const B = vertices[j];

                    // Check if point is on vertex
                    if (this.distSq(p, A) < EPSILON || this.distSq(p, B) < EPSILON) return 0;

                    // Check if point is on edge
                    if (this.isPointOnSegmentBlock(p, A, B)) return 0;

                    // Ray casting with floating point robustness
                    if (((A.y > p.y) !== (B.y > p.y)) &&
                        (p.x < (B.x - A.x) * (p.y - A.y) / (B.y - A.y) + A.x + 1e-9)) {
                        inside = !inside;
                    }
                }
                return inside ? -1 : 1;
            }

            static isPointOnSegmentBlock(p, a, b) {
                const cp = (p.y - a.y) * (b.x - a.x) - (p.x - a.x) * (b.y - a.y);
                if (Math.abs(cp) > 1e-3) return false;

                const dp = (p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y);
                if (dp < 0) return false;

                const lenSq = (b.x - a.x) ** 2 + (b.y - a.y) ** 2;
                if (dp > lenSq) return false;

                return true;
            }

            static ensureClockwise(vertices) {
                const area = this.getArea(vertices);
                return area > 0 ? vertices : vertices.reverse();
            }

            static getArea(vertices) {
                let area = 0;
                for (let i = 0; i < vertices.length; i++) {
                    const j = (i + 1) % vertices.length;
                    area += vertices[i].x * vertices[j].y;
                    area -= vertices[j].x * vertices[i].y;
                }
                return area / 2;
            }

            static distSq(p1, p2) {
                return (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2;
            }
        }

        // Setup back buttons when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', setupPanelBackButtons);
        } else {
            // DOM already loaded
            setupPanelBackButtons();
        }
    </script>
</body>

</html>