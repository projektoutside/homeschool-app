<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Explorer: Fun with Graphs!</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üìä</text></svg>">
    <style>
        /* CSS Reset & Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Comic Sans MS', 'Chalkboard SE', 'Arial Rounded MT Bold', sans-serif;
        }

        :root {
            --primary: #4a6fa5;
            --primary-light: #6b8cc6;
            --secondary: #ff9e5d;
            --accent: #ff6b8b;
            --success: #5dbb63;
            --warning: #ffcc00;
            --background: #f7f9fc;
            --card: #ffffff;
            --text: #333333;
            --text-light: #666666;
            --border: #dde5f0;
            --shadow: 0 6px 16px rgba(0, 0, 0, 0.08);
            --border-radius: 16px;
            --transition: all 0.3s ease;
        }

        .dark-theme {
            --primary: #6b8cc6;
            --primary-light: #8aa8e6;
            --secondary: #ffb07c;
            --accent: #ff8fa3;
            --background: #1a2332;
            --card: #253142;
            --text: #f0f4f8;
            --text-light: #b0bac5;
            --border: #3a4556;
            --shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
        }

        body {
            background-color: var(--background);
            color: var(--text);
            min-height: 100vh;
            transition: var(--transition);
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0 25px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-icon {
            font-size: 2.8rem;
            background: linear-gradient(135deg, var(--primary), var(--accent));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        .logo-text {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--primary);
        }

        .header-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        /* Buttons */
        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            box-sizing: border-box;
            max-width: 100%;
            white-space: nowrap;
        }

        .btn-primary {
            background-color: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background-color: var(--primary-light);
            transform: translateY(-3px);
        }

        .btn-secondary {
            background-color: var(--secondary);
            color: #333;
        }

        .btn-secondary:hover {
            background-color: #ffb07c;
            transform: translateY(-3px);
        }

        .btn-accent {
            background-color: var(--accent);
            color: white;
        }

        .btn-accent:hover {
            background-color: #ff8fa3;
            transform: translateY(-3px);
        }

        .btn-outline {
            background-color: transparent;
            color: var(--primary);
            border: 2px solid var(--primary);
        }

        .btn-outline:hover {
            background-color: var(--primary);
            color: white;
            transform: translateY(-3px);
        }

        .btn-sm {
            padding: 8px 15px;
            font-size: 0.9rem;
        }

        .btn-lg {
            padding: 16px 28px;
            font-size: 1.2rem;
        }

        .btn-icon {
            font-size: 1.2rem;
        }

        /* Home Screen */
        .home-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 30px 0;
            flex: 1;
        }

        .welcome-title {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-align: center;
            color: var(--primary);
        }

        .welcome-subtitle {
            font-size: 1.2rem;
            margin-bottom: 40px;
            text-align: center;
            color: var(--text-light);
            max-width: 600px;
        }

        .graph-selection {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 25px;
            width: 100%;
            max-width: 1200px;
            margin: 20px 0 40px;
        }

        .graph-card {
            background-color: var(--card);
            border-radius: var(--border-radius);
            padding: 25px;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            box-shadow: var(--shadow);
            transition: var(--transition);
            border: 2px solid transparent;
            height: 100%;
        }

        .graph-card:hover {
            transform: translateY(-10px);
            border-color: var(--primary);
        }

        .graph-icon {
            font-size: 3.5rem;
            margin-bottom: 15px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .graph-name {
            font-size: 1.5rem;
            margin-bottom: 10px;
            color: var(--primary);
        }

        .graph-description {
            color: var(--text-light);
            margin-bottom: 20px;
            flex-grow: 1;
        }

        /* Graph Builder Screen */
        .graph-builder-screen {
            display: none;
            flex: 1;
            flex-direction: column;
            padding-top: 20px;
            width: 100%;
            max-width: 100%;
            overflow-x: hidden;
        }

        .screen-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            flex-wrap: wrap;
            gap: 15px;
            width: 100%;
            max-width: 100%;
        }

        .screen-title {
            font-size: 2rem;
            color: var(--primary);
        }

        .graph-container {
            display: flex;
            flex-direction: column;
            gap: 25px;
            width: 100%;
            max-width: 100%;
            overflow-x: hidden;
        }

        @media (min-width: 992px) {
            .graph-container {
                flex-direction: row;
            }
        }

        /* Tablet Optimization (768px - 991px) */
        @media (min-width: 768px) {
            .input-panel {
                padding: 10px;
            }
            
            .panel-title {
                font-size: 1.05rem;
                margin-bottom: 7px;
                gap: 7px;
            }
            
            .panel-title-icon {
                font-size: 1.2rem;
            }
            
            label {
                font-size: 0.8rem;
            }
            
            input, select {
                padding: 6px 9px;
                font-size: 0.9rem;
            }
            
            .data-form {
                gap: 7px;
            }
            
            .form-group {
                gap: 2px;
            }
            
            .data-rows {
                gap: 5px;
                margin: 5px 0;
            }
            
            .data-row {
                gap: 4px;
                padding: 5px;
            }
            
            .row-btn {
                width: 28px;
                height: 28px;
                font-size: 0.9rem;
            }
            
            .input-controls {
                flex-direction: row;
                gap: 5px;
                margin-top: 8px;
            }
            
            .input-controls .btn {
                flex: 1;
                padding: 10px;
                font-size: 0.9rem;
            }
        }

        /* Desktop Optimization (1200px+) */
        @media (min-width: 1200px) {
            .input-panel {
                padding: 12px;
            }
            
            .panel-title {
                font-size: 1.15rem;
                margin-bottom: 8px;
                gap: 8px;
            }
            
            .panel-title-icon {
                font-size: 1.3rem;
            }
            
            label {
                font-size: 0.85rem;
            }
            
            input, select {
                padding: 6px 10px;
                font-size: 0.95rem;
            }
            
            .data-form {
                gap: 8px;
            }
            
            .form-group {
                gap: 3px;
            }
            
            .data-rows {
                gap: 6px;
                margin: 6px 0;
            }
            
            .data-row {
                gap: 5px;
                padding: 6px;
            }
            
            .row-btn {
                width: 30px;
                height: 30px;
                font-size: 0.95rem;
            }
            
            .input-controls {
                gap: 6px;
                margin-top: 10px;
            }
            
            .input-controls .btn {
                padding: 12px 15px;
                font-size: 1rem;
            }
        }

        .input-panel {
            background-color: var(--card);
            border-radius: var(--border-radius);
            padding: 8px;
            box-shadow: var(--shadow);
            flex: 1;
            min-width: 300px;
            max-width: 100%;
            overflow-x: hidden;
            overflow-y: auto;
            order: 2;
            display: flex;
            flex-direction: column;
        }

        .graph-display {
            background-color: var(--card);
            border-radius: var(--border-radius);
            padding: 25px;
            box-shadow: var(--shadow);
            flex: 2;
            display: flex;
            flex-direction: column;
            min-height: 500px;
            width: 100%;
            max-width: 100%;
            overflow-x: hidden;
            overflow-y: auto;
            order: 1;
        }

        .panel-title {
            font-size: 1rem;
            margin-bottom: 6px;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 600;
            line-height: 1.1;
        }

        .panel-title-icon {
            font-size: 1.1rem;
            flex-shrink: 0;
        }

        /* Tutorial */
        .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .tutorial-box {
            background-color: var(--card);
            border-radius: var(--border-radius);
            padding: 30px;
            max-width: 500px;
            width: 90%;
            box-shadow: var(--shadow);
            position: relative;
        }

        .tutorial-title {
            font-size: 1.8rem;
            margin-bottom: 15px;
            color: var(--primary);
        }

        .tutorial-content {
            margin-bottom: 25px;
            line-height: 1.6;
        }

        .tutorial-step {
            font-weight: bold;
            color: var(--accent);
            margin-bottom: 5px;
        }

        .tutorial-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }

        .tutorial-dots {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-top: 15px;
        }

        .tutorial-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: var(--border);
            cursor: pointer;
        }

        .tutorial-dot.active {
            background-color: var(--primary);
        }

        /* Data Input */
        .data-form {
            display: flex;
            flex-direction: column;
            gap: 6px;
            width: 100%;
            max-width: 100%;
            overflow-x: hidden;
            flex: 1;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 2px;
            width: 100%;
            max-width: 100%;
            min-width: 0;
        }

        label {
            font-weight: 600;
            color: var(--text);
            font-size: 0.75rem;
            line-height: 1.1;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        input {
            padding: 5px 8px;
            border-radius: 4px;
            border: 2px solid var(--border);
            background-color: var(--background);
            color: var(--text);
            font-size: 0.85rem;
            transition: var(--transition);
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.3;
        }

        input:focus {
            outline: none;
            border-color: var(--primary);
        }

        select {
            padding: 5px 8px;
            border-radius: 4px;
            border: 2px solid var(--border);
            background-color: var(--background);
            color: var(--text);
            font-size: 0.85rem;
            transition: var(--transition);
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            cursor: pointer;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.3;
        }

        select:focus {
            outline: none;
            border-color: var(--primary);
        }

        .data-rows {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin: 4px 0;
            width: 100%;
            max-width: 100%;
            overflow-x: hidden;
            flex: 1;
            min-height: 0;
            overflow-y: auto;
        }

        .data-row {
            display: flex;
            gap: 3px;
            align-items: center;
            width: 100%;
            max-width: 100%;
            min-width: 0;
            flex-wrap: nowrap;
            background-color: var(--background);
            padding: 4px;
            border-radius: 4px;
            border: 1px solid var(--border);
        }

        .data-row input {
            flex: 1;
            min-width: 0;
            max-width: 100%;
            padding: 4px 6px !important;
            font-size: 0.8rem;
        }

        .data-row .data-label {
            flex: 2;
            min-width: 0;
            max-width: 100%;
        }

        .data-row .data-value {
            flex: 1;
            min-width: 0;
            max-width: 100%;
        }

        .data-row .data-icon {
            flex: 0 0 auto;
            min-width: auto;
            max-width: 60px;
            width: auto;
            font-size: 1rem;
        }

        .row-controls {
            display: flex;
            gap: 1px;
        }

        .row-btn {
            width: 26px;
            height: 26px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            cursor: pointer;
            font-size: 0.85rem;
            transition: var(--transition);
            padding: 0;
        }

        .add-row-btn {
            background-color: var(--success);
            color: white;
        }

        .remove-row-btn {
            background-color: var(--accent);
            color: white;
        }

        .input-controls {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-top: 6px;
            flex-wrap: nowrap;
            width: 100%;
            max-width: 100%;
        }

        .input-controls .btn {
            flex: 1 1 auto;
            min-width: 0;
            padding: 8px 12px;
            font-size: 0.85rem;
            width: 100%;
        }

        /* Graph Visualization */
        .graph-visualization {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .graph-svg {
            width: 100%;
            height: 100%;
            max-height: 400px;
        }

        .pictograph-container {
            display: flex;
            flex-direction: column;
            gap: 25px;
            padding: 25px;
            align-items: center;
            width: 100%;
            max-width: 100%;
        }

        .pictograph-item {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 20px;
            width: 100%;
            max-width: 700px;
            padding: 15px 20px;
            background-color: var(--background);
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .pictograph-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .pictograph-icons {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 4px;
            flex: 1;
            align-items: center;
            min-width: 0;
            max-width: 100%;
        }

        @media (max-width: 768px) {
            .pictograph-icons {
                grid-template-columns: repeat(8, 1fr);
            }
        }

        @media (max-width: 480px) {
            .pictograph-icons {
                grid-template-columns: repeat(6, 1fr);
            }
        }

        .pictograph-icon {
            font-size: 1.6rem;
            line-height: 1;
            transition: transform 0.2s;
            display: inline-block;
        }

        .pictograph-icon:hover {
            transform: scale(1.2);
        }

        .pictograph-label {
            min-width: 140px;
            max-width: 140px;
            text-align: right;
            font-size: 1rem;
            line-height: 1.4;
            flex-shrink: 0;
        }

        .pictograph-label strong {
            display: block;
            margin-bottom: 4px;
            color: var(--primary);
            font-size: 1.1rem;
            font-weight: 600;
        }

        @media (max-width: 768px) {
            .pictograph-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 12px;
            }

            .pictograph-label {
                min-width: 100%;
                max-width: 100%;
                text-align: left;
            }
        }

        .graph-summary {
            margin-top: 25px;
            padding-top: 20px;
            border-top: 2px dashed var(--border);
        }

        .summary-title {
            font-size: 1.3rem;
            margin-bottom: 10px;
            color: var(--primary);
        }

        .summary-text {
            line-height: 1.6;
        }

        /* Challenge Modal Overlay */
        .challenge-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 10px;
            overflow-y: auto;
        }

        .challenge-panel {
            background-color: var(--card);
            border-radius: var(--border-radius);
            padding: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            width: 100%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            animation: slideUp 0.3s ease;
        }

        .challenge-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.2rem;
            margin-bottom: 12px;
            color: var(--secondary);
        }

        .challenge-question {
            margin-bottom: 12px;
            font-size: 1rem;
            line-height: 1.4;
        }

        .challenge-answers {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 12px;
        }

        .challenge-answer {
            padding: 10px 12px;
            background-color: var(--background);
            border-radius: 8px;
            cursor: pointer;
            transition: var(--transition);
            border: 2px solid transparent;
            font-size: 0.95rem;
            text-align: left;
        }

        .challenge-answer:hover {
            background-color: var(--primary-light);
            color: white;
        }

        .challenge-feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 30px;
            border-radius: 15px;
            display: none;
            font-weight: bold;
            font-size: 1.3rem;
            z-index: 2000;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            animation: popIn 0.3s ease;
            text-align: center;
            min-width: 250px;
        }

        @keyframes popIn {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .feedback-correct {
            background-color: #5DBB63;
            color: white;
            border: 3px solid #4a9f50;
        }

        .feedback-incorrect {
            background-color: #FF6B8B;
            color: white;
            border: 3px solid #e55a7a;
        }

        .challenge-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            flex-wrap: wrap;
            gap: 8px;
        }

        .challenge-timer {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 1rem;
            font-weight: bold;
            color: var(--accent);
            background-color: rgba(255, 107, 139, 0.1);
            padding: 6px 12px;
            border-radius: 8px;
        }

        .timer-icon {
            font-size: 1.3rem;
        }

        .challenge-stats {
            display: flex;
            gap: 15px;
            margin-bottom: 12px;
            padding: 8px;
            background-color: var(--background);
            border-radius: 8px;
            justify-content: center;
        }

        .challenge-graph-display {
            width: 100%;
            max-width: 100%;
            margin-bottom: 15px;
            padding: 10px;
            background-color: var(--background);
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 200px;
            max-height: 300px;
        }

        .challenge-graph-display .graph-svg {
            width: 100%;
            height: auto;
            max-width: 100%;
            max-height: 280px;
        }

        .challenge-graph-display .pictograph-container {
            width: 100%;
            max-width: 100%;
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 10px;
        }

        .challenge-graph-display .pictograph-item {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 12px;
            padding: 10px;
            background-color: var(--card);
            border-radius: 8px;
            width: 100%;
        }

        .challenge-graph-display .pictograph-icons {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 3px;
            flex: 1;
            align-items: center;
        }

        @media (max-width: 480px) {
            .challenge-graph-display .pictograph-icons {
                grid-template-columns: repeat(6, 1fr);
            }
        }

        .challenge-graph-display .pictograph-icon {
            font-size: 1.2rem;
            line-height: 1;
        }

        .challenge-graph-display .pictograph-label {
            font-size: 0.85rem;
            min-width: 70px;
            text-align: right;
        }

        .challenge-graph-display .pictograph-label strong {
            display: block;
            font-size: 0.9rem;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stat-label {
            font-weight: bold;
            color: var(--text-light);
        }

        .stat-value {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--primary);
        }

        .challenge-results {
            text-align: center;
            padding: 15px;
            background-color: var(--background);
            border-radius: 8px;
            margin-top: 15px;
        }

        .results-title {
            font-size: 1.3rem;
            color: var(--primary);
            margin-bottom: 15px;
        }

        .results-stats {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }

        .result-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background-color: var(--card);
            border-radius: 8px;
        }

        .result-label {
            font-weight: bold;
            color: var(--text);
        }

        .result-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--primary);
        }

        .result-points {
            font-size: 0.9rem;
            color: var(--text-light);
            margin-left: 5px;
        }

        /* Save/Load */
        .save-load-panel {
            background-color: var(--card);
            border-radius: var(--border-radius);
            padding: 20px;
            margin-top: 20px;
            box-shadow: var(--shadow);
        }

        .save-options {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }

        .saved-graphs {
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 10px;
        }

        .saved-graph-item {
            padding: 10px;
            margin-bottom: 8px;
            background-color: var(--background);
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: var(--transition);
        }

        .saved-graph-item:hover {
            background-color: var(--primary-light);
            color: white;
        }

        .saved-graph-name {
            font-weight: bold;
        }

        .saved-graph-type {
            font-size: 0.9rem;
            color: var(--text-light);
        }

        .dark-theme .saved-graph-type {
            color: #d0d0d0;
        }

        /* Fullscreen */
        .fullscreen-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 100;
        }

        /* Responsive */
        /* Responsive */
        @media (max-width: 768px) {
            /* Challenge Modal Responsive */
            .challenge-panel {
                max-width: 95%;
                padding: 12px;
                max-height: 85vh;
            }
            
            .challenge-title {
                font-size: 1.1rem;
            }
            
            .challenge-question {
                font-size: 0.95rem;
            }
            
            .challenge-answer {
                padding: 8px 10px;
                font-size: 0.9rem;
            }
            
            .challenge-timer {
                font-size: 0.9rem;
                padding: 5px 10px;
            }
            
            .challenge-stats {
                gap: 10px;
                padding: 6px;
            }
            
            .stat-value {
                font-size: 0.95rem;
            }
            
            .challenge-feedback {
                font-size: 1.1rem;
                padding: 15px 25px;
                min-width: 200px;
            }
            
            .challenge-graph-display {
                min-height: 180px;
                max-height: 250px;
            }
            
            .challenge-graph-display .graph-svg {
                max-height: 230px;
            }
            
            /* General Responsive */
            .welcome-title {
                font-size: 2rem;
            }
            
            .screen-title {
                font-size: 1.7rem;
            }
            
            .graph-selection {
                grid-template-columns: 1fr;
            }
            
            .header-controls {
                justify-content: center;
                width: 100%;
            }
            
            .input-panel {
                min-width: 0;
                padding: 20px;
            }
            
            .data-row {
                flex-wrap: wrap;
            }
            
            .data-row .data-label {
                flex: 1 1 100%;
                min-width: 0;
            }
            
            .data-row .data-value {
                flex: 1 1 auto;
                min-width: 100px;
            }
            
            .data-row .data-icon {
                flex: 0 0 auto;
                min-width: 70px;
            }
            
            .input-controls {
                justify-content: center;
            }
            
            .tutorial-buttons {
                flex-direction: column;
                gap: 10px;
            }
            
            .tutorial-buttons .btn {
                width: 100%;
            }
        }

        @media (max-width: 480px) {
            /* Challenge Modal Responsive */
            .challenge-panel {
                max-width: 98%;
                padding: 10px;
                max-height: 90vh;
            }
            
            .challenge-title {
                font-size: 1rem;
            }
            
            .challenge-question {
                font-size: 0.9rem;
            }
            
            .challenge-answer {
                padding: 8px;
                font-size: 0.85rem;
            }
            
            .challenge-timer {
                font-size: 0.85rem;
                padding: 4px 8px;
            }
            
            .challenge-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .challenge-stats {
                flex-direction: column;
                gap: 8px;
            }
            
            .results-title {
                font-size: 1.1rem;
            }
            
            .result-value {
                font-size: 1.1rem;
            }
            
            .challenge-feedback {
                font-size: 1rem;
                padding: 12px 20px;
                min-width: 180px;
            }
            
            .challenge-graph-display {
                min-height: 150px;
                max-height: 200px;
                padding: 8px;
            }
            
            .challenge-graph-display .graph-svg {
                max-height: 180px;
            }
            
            .challenge-graph-display .pictograph-icon {
                font-size: 0.9rem;
            }
            
            .challenge-graph-display .pictograph-label {
                font-size: 0.75rem;
                min-width: 60px;
            }
            
            /* General Responsive */
            .container {
                padding: 15px;
            }
            
            .btn {
                padding: 10px 15px;
                font-size: 0.9rem;
            }
            
            .input-panel {
                padding: 15px;
            }
            
            .data-row {
                flex-direction: column;
                gap: 8px;
                align-items: stretch;
            }
            
            .data-row input,
            .data-row select {
                width: 100%;
                max-width: 100%;
            }
            
            .data-row .data-label,
            .data-row .data-value,
            .data-row .data-icon {
                flex: 1 1 100%;
                min-width: 0;
                max-width: 100%;
            }
            
            .row-controls {
                align-self: flex-end;
                width: 100%;
                justify-content: flex-end;
            }
        }

        /* Accessibility */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Focus styles */
        button:focus, input:focus {
            outline: 3px solid var(--secondary);
            outline-offset: 2px;
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .fade-in {
            animation: fadeIn 0.5s ease;
        }

        .slide-up {
            animation: slideUp 0.4s ease;
        }

        /* Pictograph Icons */
        .icon-pet { color: #FF9E5D; }
        .icon-snack { color: #5DBB63; }
        .icon-sport { color: #4A6FA5; }
        .icon-color { color: #FF6B8B; }
        .icon-toy { color: #9D65C9; }
        .icon-fruit { color: #FFCC00; }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header>
            <div class="logo">
                <div class="logo-icon">üìä</div>
                <div class="logo-text">Graph Explorer</div>
            </div>
            <div class="header-controls">
                <button id="themeToggle" class="btn btn-outline" aria-label="Toggle theme">
                    <span class="btn-icon">üåô</span> Theme
                </button>
                <button id="tutorialBtn" class="btn btn-primary">
                    <span class="btn-icon">‚ùì</span> Tutorial
                </button>
                <button id="challengeBtn" class="btn btn-secondary">
                    <span class="btn-icon">üéØ</span> Challenge
                </button>
            </div>
        </header>

        <!-- Home Screen -->
        <section id="homeScreen" class="home-screen">
            <h1 class="welcome-title">Welcome to Graph Explorer!</h1>
            <p class="welcome-subtitle">Learn about graphs in a fun, interactive way. Pick a graph type to start exploring!</p>
            
            <div class="graph-selection">
                <div class="graph-card" data-graph-type="pictograph">
                    <div class="graph-icon">üñºÔ∏è</div>
                    <h2 class="graph-name">Pictograph</h2>
                    <p class="graph-description">Use pictures to show and compare numbers. Perfect for counting fun things!</p>
                    <button class="btn btn-primary btn-lg select-graph-btn">Explore Pictograph</button>
                </div>
                
                <div class="graph-card" data-graph-type="pie">
                    <div class="graph-icon">ü•ß</div>
                    <h2 class="graph-name">Pie Chart</h2>
                    <p class="graph-description">A circular chart divided into slices to show parts of a whole.</p>
                    <button class="btn btn-primary btn-lg select-graph-btn">Explore Pie Chart</button>
                </div>
                
                <div class="graph-card" data-graph-type="line">
                    <div class="graph-icon">üìà</div>
                    <h2 class="graph-name">Line Graph</h2>
                    <p class="graph-description">Connect points with lines to show changes over time.</p>
                    <button class="btn btn-primary btn-lg select-graph-btn">Explore Line Graph</button>
                </div>
                
                <div class="graph-card" data-graph-type="bar">
                    <div class="graph-icon">üìä</div>
                    <h2 class="graph-name">Bar Graph</h2>
                    <p class="graph-description">Use bars of different heights to compare amounts.</p>
                    <button class="btn btn-primary btn-lg select-graph-btn">Explore Bar Graph</button>
                </div>
            </div>
            
            <div class="save-load-panel">
                <h3 class="panel-title"><span class="panel-title-icon">üíæ</span> Your Saved Graphs</h3>
                <div id="savedGraphsList" class="saved-graphs">
                    <!-- Saved graphs will appear here -->
                </div>
            </div>
        </section>

        <!-- Graph Builder Screen -->
        <section id="graphBuilderScreen" class="graph-builder-screen">
            <div class="screen-header">
                <h1 id="screenTitle" class="screen-title">Graph Builder</h1>
                <div class="input-controls">
                    <button id="backToHomeBtn" class="btn btn-outline">
                        <span class="btn-icon">üè†</span> Home
                    </button>
                    <button id="randomExampleBtn" class="btn btn-secondary">
                        <span class="btn-icon">üé≤</span> Random Example
                    </button>
                    <button id="resetBtn" class="btn btn-accent">
                        <span class="btn-icon">üîÑ</span> Reset
                    </button>
                </div>
            </div>
            
            <div class="graph-container">
                <!-- Graph Display -->
                <div class="graph-display">
                    <h3 class="panel-title"><span id="graphDisplayIcon" class="panel-title-icon">üìä</span> <span id="graphDisplayTitle">Graph Preview</span></h3>
                    <div id="graphVisualization" class="graph-visualization">
                        <!-- Graph will be drawn here -->
                        <div id="defaultGraphMessage" class="welcome-subtitle">
                            Add some data to see your graph here!
                        </div>
                    </div>
                    
                    <div id="graphSummary" class="graph-summary">
                        <h4 class="summary-title">What This Graph Shows:</h4>
                        <p id="summaryText" class="summary-text">Add data to see insights about your graph.</p>
                    </div>
                </div>
                
                <!-- Input Panel -->
                <div class="input-panel">
                    <h3 class="panel-title"><span class="panel-title-icon">‚úèÔ∏è</span> Graph Details</h3>
                    <div class="data-form">
                        <div class="form-group">
                            <label for="graphTitle">Graph Title</label>
                            <input type="text" id="graphTitle" placeholder="My Awesome Graph" value="My Favorite Things">
                        </div>
                        
                        <div class="form-group">
                            <label for="xLabel">Category Label</label>
                            <input type="text" id="xLabel" placeholder="Things" value="Favorite Things">
                        </div>
                        
                        <div class="form-group">
                            <label for="yLabel">Value Label</label>
                            <input type="text" id="yLabel" placeholder="Amount" value="How Many">
                        </div>
                        
                        <h4 class="panel-title">Data</h4>
                        <div id="dataRows" class="data-rows">
                            <!-- Data rows will be generated here -->
                        </div>
                        
                        <button id="addRowBtn" class="btn btn-primary">
                            <span class="btn-icon">+</span> Add Row
                        </button>
                        
                        <div class="input-controls">
                            <button id="saveGraphBtn" class="btn btn-secondary">
                                <span class="btn-icon">üíæ</span> Save Graph
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Challenge Modal Overlay -->
            <div id="challengeOverlay" class="challenge-overlay" style="display: none;">
                <div id="challengePanel" class="challenge-panel">
                    <div class="challenge-header">
                        <h3 class="challenge-title"><span class="panel-title-icon">üéØ</span> Graph Challenge</h3>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <div id="challengeTimer" class="challenge-timer" style="display: none;">
                                <span class="timer-icon">‚è±Ô∏è</span>
                                <span id="timerDisplay">2:00</span>
                            </div>
                            <button id="exitChallengeBtn" class="btn btn-accent" style="padding: 6px 12px; font-size: 0.9rem;">
                                <span class="btn-icon">üö™</span> Exit
                            </button>
                        </div>
                    </div>
                    <div id="challengeStats" class="challenge-stats" style="display: none;">
                        <div class="stat-item">
                            <span class="stat-label">Score:</span>
                            <span id="challengeScore" class="stat-value">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Answered:</span>
                            <span id="challengeAnswered" class="stat-value">0</span>
                        </div>
                    </div>
                    <div id="challengeGraphDisplay" class="challenge-graph-display">
                        <!-- Graph will be rendered here -->
                    </div>
                    <div id="challengeQuestion" class="challenge-question">Which category has the largest value?</div>
                    <div id="challengeAnswers" class="challenge-answers">
                        <!-- Challenge answers will be generated here -->
                    </div>
                    <div id="challengeFeedback" class="challenge-feedback"></div>
                    <div id="challengeResults" class="challenge-results" style="display: none;">
                        <h4 class="results-title">Challenge Complete! üéâ</h4>
                        <div class="results-stats">
                            <div class="result-item">
                                <span class="result-label">Correct Answers:</span>
                                <span id="resultsCorrect" class="result-value">0</span>
                            </div>
                            <div class="result-item">
                                <span class="result-label">Total Answered:</span>
                                <span id="resultsTotal" class="result-value">0</span>
                            </div>
                            <div class="result-item">
                                <span class="result-label">Your Score:</span>
                                <span id="resultsScore" class="result-value">0</span>
                                <span class="result-points">points</span>
                            </div>
                        </div>
                        <button id="closeChallengeBtn" class="btn btn-primary" style="margin-top: 20px; width: 100%;">
                            <span class="btn-icon">‚úÖ</span> Close Challenge
                        </button>
                    </div>
                </div>
            </div>
        </section>
        
        <!-- Tutorial Overlay -->
        <div id="tutorialOverlay" class="tutorial-overlay">
            <div class="tutorial-box slide-up">
                <h2 id="tutorialStepTitle" class="tutorial-title">Welcome to Graph Explorer!</h2>
                <div id="tutorialStepContent" class="tutorial-content">
                    <div class="tutorial-step">Step 1 of 5</div>
                    <p>Let's learn about graphs! This tutorial will guide you through creating your own graph.</p>
                </div>
                <div class="tutorial-buttons">
                    <button id="prevTutorialBtn" class="btn btn-outline">Previous</button>
                    <button id="nextTutorialBtn" class="btn btn-primary">Next</button>
                </div>
                <div class="tutorial-dots">
                    <!-- Dots will be generated here -->
                </div>
                <button id="skipTutorialBtn" class="btn btn-accent" style="margin-top: 15px; width: 100%;">Skip Tutorial</button>
            </div>
        </div>
        
        <!-- Fullscreen Button -->
        <button id="fullscreenBtn" class="btn btn-primary fullscreen-btn" aria-label="Toggle fullscreen">
            <span class="btn-icon">‚õ∂</span> Fullscreen
        </button>
    </div>

    <script>
        // ============================================================================
        // CONSTANTS & CONFIGURATION
        // ============================================================================
        
        const graphNames = {
            pictograph: "Pictograph",
            pie: "Pie Chart",
            line: "Line Graph",
            bar: "Bar Graph"
        };
        
        const graphIcons = {
            pictograph: "üñºÔ∏è",
            pie: "ü•ß",
            line: "üìà",
            bar: "üìä"
        };
        
        // Comprehensive keyword-to-emoji mapping for "Smart Icons"
        const iconMap = {
            // Animals
            "puppy": "üê∂", "puppies": "üê∂", "dog": "üê∂", "dogs": "üê∂", "cat": "üê±", "cats": "üê±", "mouse": "üê≠", "mice": "üê≠", "hamster": "üêπ", "hamsters": "üêπ", "rabbit": "üê∞", "rabbits": "üê∞", "bunny": "üê∞", "bunnies": "üê∞",
            "fox": "ü¶ä", "foxes": "ü¶ä", "bear": "üêª", "bears": "üêª", "panda": "üêº", "pandas": "üêº", "koala": "üê®", "koalas": "üê®", "tiger": "üêØ", "tigers": "üêØ", "lion": "ü¶Å", "lions": "ü¶Å",
            "cow": "üêÆ", "cows": "üêÆ", "pig": "üê∑", "pigs": "üê∑", "frog": "üê∏", "frogs": "üê∏", "monkey": "üêµ", "monkeys": "üêµ", "chicken": "üêî", "chickens": "üêî", "penguin": "üêß", "penguins": "üêß",
            "bird": "üê¶", "birds": "üê¶", "duck": "ü¶Ü", "ducks": "ü¶Ü", "eagle": "ü¶Ö", "eagles": "ü¶Ö", "owl": "ü¶â", "owls": "ü¶â", "bat": "ü¶á", "bats": "ü¶á", "wolf": "üê∫", "wolves": "üê∫",
            "horse": "üê¥", "horses": "üê¥", "unicorn": "ü¶Ñ", "unicorns": "ü¶Ñ", "bee": "üêù", "bees": "üêù", "bug": "üêõ", "bugs": "üêõ", "butterfly": "ü¶ã", "butterflies": "ü¶ã", "snail": "üêå", "snails": "üêå",
            "fish": "üêü", "fishes": "üêü", "shark": "ü¶à", "sharks": "ü¶à", "whale": "üêã", "whales": "üêã", "dolphin": "üê¨", "dolphins": "üê¨", "turtle": "üê¢", "turtles": "üê¢", "snake": "üêç", "snakes": "üêç",
            "dragon": "üêâ", "dragons": "üêâ", "dinosaur": "ü¶ñ", "dinosaurs": "ü¶ñ", "t-rex": "ü¶ñ", "deer": "ü¶å", "squirrel": "üêøÔ∏è", "squirrels": "üêøÔ∏è",
            
            // Food & Drink
            "apple": "üçé", "banana": "üçå", "orange": "üçä", "strawberry": "üçì", "grape": "üçá", "watermelon": "üçâ",
            "pineapple": "üçç", "kiwi": "ü•ù", "pear": "üçê", "peach": "üçë", "cherry": "üçí", "blueberry": "ü´ê",
            "mango": "ü•≠", "lemon": "üçã", "carrot": "ü•ï", "corn": "üåΩ", "broccoli": "ü•¶", "potato": "ü•î",
            "pizza": "üçï", "burger": "üçî", "fries": "üçü", "taco": "üåÆ", "sushi": "üç£", "pasta": "üçù", "hotdog": "üå≠", "hot dog": "üå≠",
            "bread": "üçû", "egg": "ü•ö", "cheese": "üßÄ", "ice cream": "üç¶", "cake": "üç∞", "cookie": "üç™",
            "chocolate": "üç´", "candy": "üç¨", "donut": "üç©", "popcorn": "üçø", "coffee": "‚òï", "tea": "üçµ",
            "milk": "ü•õ", "juice": "üßÉ", "water": "üíß", "soda": "ü•§",
            
            // Sports & Hobbies
            "soccer": "‚öΩ", "basketball": "üèÄ", "football": "üèà", "baseball": "‚öæ", "tennis": "üéæ", "volleyball": "üèê",
            "rugby": "üèâ", "golf": "‚õ≥", "ping pong": "üèì", "badminton": "üè∏", "boxing": "ü•ä", "karate": "ü•ã",
            "swimming": "üèä", "running": "üèÉ", "cycling": "üö≤", "bike": "üö≤", "yoga": "üßò", "dance": "üíÉ",
            "music": "üéµ", "guitar": "üé∏", "piano": "üéπ", "art": "üé®", "painting": "üé®", "reading": "üìö",
            "book": "üìñ", "gaming": "üéÆ", "video game": "üéÆ", "chess": "‚ôüÔ∏è", "puzzle": "üß©", "photography": "üì∑",
            "camera": "üì∑", "fishing": "üé£", "camping": "‚õ∫", "hiking": "ü•æ",
            
            // Objects & School
            "pencil": "‚úèÔ∏è", "pen": "üñäÔ∏è", "marker": "üñçÔ∏è", "crayon": "üñçÔ∏è", "eraser": "üßº", "ruler": "üìè",
            "notebook": "üìì", "paper": "üìÑ", "glue": "üß¥", "scissors": "‚úÇÔ∏è", "backpack": "üéí", "computer": "üíª",
            "phone": "üì±", "watch": "‚åö", "key": "üîë", "gift": "üéÅ", "balloon": "üéà", "money": "üí∞",
            "star": "‚≠ê", "heart": "‚ù§Ô∏è", "sun": "‚òÄÔ∏è", "sunny": "‚òÄÔ∏è", "moon": "üåô", "cloud": "‚òÅÔ∏è", "cloudy": "‚òÅÔ∏è", "rain": "üåßÔ∏è", "rainy": "üåßÔ∏è", "snow": "‚ùÑÔ∏è", "snowy": "‚ùÑÔ∏è",
            "wind": "üå¨Ô∏è", "windy": "üå¨Ô∏è", "storm": "‚õàÔ∏è", "stormy": "‚õàÔ∏è", "fog": "üå´Ô∏è", "foggy": "üå´Ô∏è",
            "fire": "üî•", "tree": "üå≥", "flower": "üå∏", "house": "üè†", "car": "üöó", "truck": "üõª", "bus": "üöå",
            "train": "üöÜ", "plane": "‚úàÔ∏è", "rocket": "üöÄ", "ship": "üö¢"
        };

        // Icons for pictographs (expanded)
        const pictographIcons = [
            "üê∂", "üê±", "üê≠", "üêπ", "üê∞", "ü¶ä", "üêª", "üêº", "üê®", "üêØ", "ü¶Å", "üêÆ", "üê∑", "üê∏", "üêµ",
            "üê¶", "ü¶Ü", "üê¢", "ü¶å", "üêøÔ∏è", "ü¶ã", "üêü", "ü¶à", "üêã", "üê¨", "üêç", "üêî", "üêß", "ü¶Ö", "ü¶â", "ü¶á", "üê∫",
            "üê¥", "ü¶Ñ", "üêù", "üêõ", "üêå", "üêâ", "ü¶ñ",
            "üçé", "üçå", "üçä", "üçì", "üçá", "üçâ", "üçç", "üç¶", "üç´", "üç™", "üçï", "üçî", "üçü", "üç©",
            "‚öΩ", "üèÄ", "üèà", "‚öæ", "üéæ", "üèê", "üèä", "üö¥", "üé∏", "üéπ", "üé®", "üéÆ", "üìö", "‚ôüÔ∏è",
            "‚òÄÔ∏è", "üåô", "‚≠ê", "‚òÅÔ∏è", "üåßÔ∏è", "‚ùÑÔ∏è", "üå¨Ô∏è", "‚õàÔ∏è", "üå´Ô∏è", "üî•", "üåà", "üéà", "üéÅ", "üíé", "‚ù§Ô∏è", "üçÄ", "üöÄ",
            "üöó", "üö≤", "üöå", "‚úàÔ∏è", "üö¢", "üè†", "üè¢", "üå≥", "üå∏", "üß∏", "‚úèÔ∏è", "‚úÇÔ∏è", "üï∂Ô∏è", "üëë"
        ];
        
        const pictographCategories = ["Pets", "Toys", "Fruits", "Sports", "Colors"];

        // ============================================================================
        // APPLICATION STATE
        // ============================================================================
        
        const appState = {
            currentGraphType: null,
            graphData: [],
            savedGraphs: [],
            tutorialStep: 0,
            theme: 'light',
            challenges: {
                active: false,
                timedMode: false,
                currentQuestion: null,
                questions: [],
                timer: null,
                timeRemaining: 120, // 2 minutes in seconds
                score: 0,
                correctAnswers: 0,
                totalAnswered: 0,
                challengeGraphData: null,
                challengeGraphType: null
            }
        };

        // ============================================================================
        // DOM ELEMENT REFERENCES
        // ============================================================================
        
        const homeScreen = document.getElementById('homeScreen');
        const graphBuilderScreen = document.getElementById('graphBuilderScreen');
        const tutorialOverlay = document.getElementById('tutorialOverlay');
        const challengeOverlay = document.getElementById('challengeOverlay');
        const challengePanel = document.getElementById('challengePanel');
        const challengeGraphDisplay = document.getElementById('challengeGraphDisplay');
        const challengeTimer = document.getElementById('challengeTimer');
        const timerDisplay = document.getElementById('timerDisplay');
        const challengeStats = document.getElementById('challengeStats');
        const challengeScore = document.getElementById('challengeScore');
        const challengeAnswered = document.getElementById('challengeAnswered');
        const challengeResults = document.getElementById('challengeResults');
        const resultsCorrect = document.getElementById('resultsCorrect');
        const resultsTotal = document.getElementById('resultsTotal');
        const resultsScore = document.getElementById('resultsScore');
        const closeChallengeBtn = document.getElementById('closeChallengeBtn');
        const exitChallengeBtn = document.getElementById('exitChallengeBtn');
        const savedGraphsList = document.getElementById('savedGraphsList');
        const dataRows = document.getElementById('dataRows');
        const graphVisualization = document.getElementById('graphVisualization');
        const defaultGraphMessage = document.getElementById('defaultGraphMessage');
        const summaryText = document.getElementById('summaryText');
        const graphTitleInput = document.getElementById('graphTitle');
        const xLabelInput = document.getElementById('xLabel');
        const yLabelInput = document.getElementById('yLabel');
        const screenTitle = document.getElementById('screenTitle');
        const graphDisplayTitle = document.getElementById('graphDisplayTitle');
        const graphDisplayIcon = document.getElementById('graphDisplayIcon');
        
        // Tutorial Elements
        const tutorialStepTitle = document.getElementById('tutorialStepTitle');
        const tutorialStepContent = document.getElementById('tutorialStepContent');
        const prevTutorialBtn = document.getElementById('prevTutorialBtn');
        const nextTutorialBtn = document.getElementById('nextTutorialBtn');
        const skipTutorialBtn = document.getElementById('skipTutorialBtn');
        const tutorialDots = document.querySelector('.tutorial-dots');
        
        // Buttons
        const themeToggleBtn = document.getElementById('themeToggle');
        const tutorialBtn = document.getElementById('tutorialBtn');
        const challengeBtn = document.getElementById('challengeBtn');
        const backToHomeBtn = document.getElementById('backToHomeBtn');
        const randomExampleBtn = document.getElementById('randomExampleBtn');
        const resetBtn = document.getElementById('resetBtn');
        const addRowBtn = document.getElementById('addRowBtn');
        const saveGraphBtn = document.getElementById('saveGraphBtn');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const selectGraphButtons = document.querySelectorAll('.select-graph-btn');
        
        // Kid-friendly example data
        const examples = {
            pictograph: {
                title: "Our Classroom Pets",
                xLabel: "Pet Type",
                yLabel: "Number of Pets",
                data: [
                    { label: "Fish", value: 8, icon: "üê†" },
                    { label: "Hamsters", value: 5, icon: "üêπ" },
                    { label: "Bunnies", value: 3, icon: "üê∞" },
                    { label: "Birds", value: 4, icon: "üê¶" }
                ]
            },
            pie: {
                title: "Favorite Snacks",
                xLabel: "Snack Type",
                yLabel: "Votes",
                data: [
                    { label: "Fruits", value: 12 },
                    { label: "Chips", value: 8 },
                    { label: "Cookies", value: 15 },
                    { label: "Yogurt", value: 10 },
                    { label: "Crackers", value: 5 }
                ]
            },
            line: {
                title: "Weekly Reading Time",
                xLabel: "Day of Week",
                yLabel: "Minutes Read",
                data: [
                    { label: "Mon", value: 20 },
                    { label: "Tue", value: 25 },
                    { label: "Wed", value: 30 },
                    { label: "Thu", value: 35 },
                    { label: "Fri", value: 40 },
                    { label: "Sat", value: 60 },
                    { label: "Sun", value: 45 }
                ]
            },
            bar: {
                title: "Favorite Colors",
                xLabel: "Color",
                yLabel: "Number of Votes",
                data: [
                    { label: "Red", value: 12 },
                    { label: "Blue", value: 18 },
                    { label: "Green", value: 10 },
                    { label: "Yellow", value: 8 },
                    { label: "Purple", value: 15 }
                ]
            }
        };

        const randomTopics = [
            {
                title: "Favorite Ice Cream Flavors",
                xLabel: "Flavor",
                yLabel: "Votes",
                labels: ["Vanilla", "Chocolate", "Strawberry", "Mint", "Cookie Dough", "Rocky Road", "Coffee"],
                icons: ["üç¶", "üç´", "üçì", "üçÉ", "üç™", "üç®", "‚òï"]
            },
            {
                title: "Daily Fruit Consumption",
                xLabel: "Fruit",
                yLabel: "Amount",
                labels: ["Apples", "Bananas", "Oranges", "Grapes", "Watermelon", "Pineapple", "Blueberries"],
                icons: ["üçé", "üçå", "üçä", "üçá", "üçâ", "üçç", "ü´ê"]
            },
            {
                title: "Classroom Supply Counts",
                xLabel: "Supply",
                yLabel: "Quantity",
                labels: ["Pencils", "Erasers", "Notebooks", "Markers", "Crayons", "Books", "Scissors"],
                icons: ["‚úèÔ∏è", "üßº", "üìì", "üñçÔ∏è", "üñåÔ∏è", "üìö", "‚úÇÔ∏è"]
            },
            {
                title: "Favorite Sports in Our Class",
                xLabel: "Sport",
                yLabel: "Players",
                labels: ["Soccer", "Basketball", "Baseball", "Tennis", "Swimming", "Gymnastics", "Football"],
                icons: ["‚öΩ", "üèÄ", "‚öæ", "üéæ", "üèä", "ü§∏", "üèà"]
            },
            {
                title: "Wildlife Spotted in the Park",
                xLabel: "Animal",
                yLabel: "Sightings",
                labels: ["Squirrels", "Birds", "Rabbits", "Ducks", "Turtles", "Deer", "Butterflies"],
                icons: ["üêøÔ∏è", "üê¶", "üê∞", "ü¶Ü", "üê¢", "ü¶å", "ü¶ã"]
            },
            {
                title: "Favorite Video Game Genres",
                xLabel: "Genre",
                yLabel: "Players",
                labels: ["Racing", "Puzzle", "Adventure", "Sports", "Music", "Fighting", "Space"],
                icons: ["üèéÔ∏è", "üß©", "üó∫Ô∏è", "‚öΩ", "üé∏", "ü•ä", "üöÄ"]
            },
            {
                title: "Types of Vehicles in the Parking Lot",
                xLabel: "Vehicle",
                yLabel: "Count",
                labels: ["Cars", "Trucks", "Bicycles", "Motorcycles", "Buses", "Vans", "Electric Cars"],
                icons: ["üöó", "üõª", "üö≤", "üèçÔ∏è", "üöå", "üöê", "‚ö°"]
            },
            {
                title: "Weather Observations (Monthly)",
                xLabel: "Weather",
                yLabel: "Days",
                labels: ["Sunny", "Cloudy", "Rainy", "Snowy", "Windy", "Stormy", "Foggy"],
                icons: ["‚òÄÔ∏è", "‚òÅÔ∏è", "üåßÔ∏è", "‚ùÑÔ∏è", "üå¨Ô∏è", "‚õàÔ∏è", "üå´Ô∏è"]
            }
        ];

        // Tutorial steps
        const tutorialSteps = [
            {
                title: "Welcome to Graph Explorer!",
                content: "Let's learn about graphs! This tutorial will guide you through creating your own graph."
            },
            {
                title: "Step 1: Name Your Graph",
                content: "Give your graph a fun name that tells what it's about, like 'My Favorite Snacks' or 'Classroom Pets'."
            },
            {
                title: "Step 2: Add Categories",
                content: "Categories are the things you're comparing. For example, if your graph is about pets, categories could be 'Dogs', 'Cats', 'Fish', etc."
            },
            {
                title: "Step 3: Enter Values",
                content: "Values are the numbers for each category. Make sure to use positive numbers only!"
            },
            {
                title: "Step 4: Generate Your Graph",
                content: "Watch your graph appear as you add data! You can see it change right away."
            },
            {
                title: "Step 5: Read and Understand",
                content: "Look at the 'What This Graph Shows' section to learn what your graph tells you. Try the Challenge button to test your knowledge!"
            }
        ];

        // ============================================================================
        // INITIALIZATION
        // ============================================================================
        
        function initApp() {
            // Load saved graphs from localStorage
            loadSavedGraphs();
            
            // Set up event listeners
            setupEventListeners();
            
            // Initialize default data rows
            addDataRow();
            addDataRow();
            addDataRow();
            
            // Generate tutorial dots
            generateTutorialDots();
            
            // Update saved graphs list
            updateSavedGraphsList();
            
            // Check for system preference for dark mode
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                setTheme('dark');
            }
        }

        // ============================================================================
        // EVENT HANDLERS SETUP
        // ============================================================================
        
        function setupEventListeners() {
            // Graph selection buttons
            selectGraphButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const card = this.closest('.graph-card');
                    const graphType = card.dataset.graphType;
                    selectGraph(graphType);
                });
            });
            
            // Control buttons
            themeToggleBtn.addEventListener('click', toggleTheme);
            tutorialBtn.addEventListener('click', showTutorial);
            challengeBtn.addEventListener('click', startTimedChallenge);
            
            // Exit challenge button (in header)
            if (exitChallengeBtn) {
                exitChallengeBtn.addEventListener('click', exitChallenge);
            }
            
            // Close challenge button (in results)
            if (closeChallengeBtn) {
                closeChallengeBtn.addEventListener('click', exitChallenge);
            }
            backToHomeBtn.addEventListener('click', showHomeScreen);
            randomExampleBtn.addEventListener('click', loadRandomExample);
            resetBtn.addEventListener('click', resetGraph);
            addRowBtn.addEventListener('click', () => addDataRow());
            saveGraphBtn.addEventListener('click', saveCurrentGraph);
            fullscreenBtn.addEventListener('click', toggleFullscreen);
            
            // Tutorial buttons
            prevTutorialBtn.addEventListener('click', prevTutorialStep);
            nextTutorialBtn.addEventListener('click', nextTutorialStep);
            skipTutorialBtn.addEventListener('click', hideTutorial);
            
            // Input field listeners for live updates
            graphTitleInput.addEventListener('input', updateGraph);
            xLabelInput.addEventListener('input', updateGraph);
            yLabelInput.addEventListener('input', updateGraph);
            
            // Close tutorial when clicking outside
            tutorialOverlay.addEventListener('click', function(e) {
                if (e.target === tutorialOverlay) {
                    hideTutorial();
                }
            });
            
            // Close challenge overlay when clicking outside (but not during timed mode)
            if (challengeOverlay) {
                challengeOverlay.addEventListener('click', function(e) {
                    if (e.target === challengeOverlay && !appState.challenges.timedMode) {
                        // Only allow closing if not in timed mode (to prevent accidental closes during challenge)
                        challengeOverlay.style.display = 'none';
                        document.body.style.overflow = '';
                        appState.challenges.active = false;
                    }
                });
                
                // Prevent closing when clicking inside the panel
                if (challengePanel) {
                    challengePanel.addEventListener('click', function(e) {
                        e.stopPropagation();
                    });
                }
            }
            
            // Keyboard shortcuts
            document.addEventListener('keydown', function(e) {
                // Escape to close tutorial
                if (e.key === 'Escape' && tutorialOverlay.style.display === 'flex') {
                    hideTutorial();
                }
                
                // Ctrl/Cmd + S to save
                if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                    e.preventDefault();
                    saveCurrentGraph();
                }
                
                // Ctrl/Cmd + D for random example
                if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
                    e.preventDefault();
                    loadRandomExample();
                }
            });
            
            // Handle fullscreen change
            document.addEventListener('fullscreenchange', updateFullscreenButton);
            document.addEventListener('webkitfullscreenchange', updateFullscreenButton);
            document.addEventListener('mozfullscreenchange', updateFullscreenButton);
            document.addEventListener('MSFullscreenChange', updateFullscreenButton);
        }

        // ============================================================================
        // GRAPH MANAGEMENT
        // ============================================================================
        
        function selectGraph(graphType) {
            appState.currentGraphType = graphType;
            
            // Update UI
            homeScreen.style.display = 'none';
            graphBuilderScreen.style.display = 'flex';
            
            // Update screen title and icon
            screenTitle.textContent = `${graphNames[graphType]} Builder`;
            graphDisplayTitle.textContent = `${graphNames[graphType]} Preview`;
            graphDisplayIcon.textContent = graphIcons[graphType];
            
            // Load example for this graph type
            loadExample(graphType);
            
            // Update graph visualization
            updateGraph();
            
            // Show tutorial on first visit
            const hasSeenTutorial = localStorage.getItem('graphExplorerTutorialSeen');
            if (!hasSeenTutorial) {
                showTutorial();
                localStorage.setItem('graphExplorerTutorialSeen', 'true');
            }
        }

        // Show home screen
        function showHomeScreen() {
            homeScreen.style.display = 'flex';
            graphBuilderScreen.style.display = 'none';
            challengeOverlay.style.display = 'none';
            document.body.style.overflow = '';
            appState.challenges.active = false;
        }

        // Add a data row
        function addDataRow(customLabel = null, customValue = null) {
            const rowCount = dataRows.children.length;
            const rowId = `row-${rowCount + 1}`;
            
            const row = document.createElement('div');
            row.className = 'data-row';
            row.id = rowId;
            
            // Default values
            const defaultLabel = customLabel !== null ? customLabel : (appState.currentGraphType === 'pictograph' ? (pictographCategories[rowCount % pictographCategories.length] || 'Item') : `Item ${rowCount + 1}`);
            const defaultValue = customValue !== null ? customValue : getRandomSingleDigit();
            
            // For pictographs, include icon selection
            if (appState.currentGraphType === 'pictograph') {
                const lowerDefaultLabel = (defaultLabel || "").toLowerCase();
                const isDefaultDogRelated = lowerDefaultLabel.includes("dog") || lowerDefaultLabel.includes("puppy");
                let uniqueIcon = getUniqueIcon(defaultLabel, rowId);
                
                // FINAL SAFETY CHECK: Ensure icon is never dog for non-dog labels
                if (uniqueIcon === "üê∂" && !isDefaultDogRelated) {
                    // Emergency fallback - get first available non-dog icon
                    const usedIcons = getUsedIcons(rowId);
                    const availableIcons = getAvailableIcons(false, usedIcons);
                    uniqueIcon = availableIcons.length > 0 ? availableIcons[0] : "üìä";
                }
                
                row.innerHTML = `
                    <input type="text" class="data-label" placeholder="Label" value="${defaultLabel}">
                    <input type="number" class="data-value" placeholder="Value" min="0" value="${defaultValue}">
                    <select class="data-icon">
                        ${pictographIcons.map((icon, i) => 
                            `<option value="${icon}" ${icon === uniqueIcon ? 'selected' : ''}>${icon}</option>`
                        ).join('')}
                    </select>
                    <div class="row-controls">
                        <button class="row-btn remove-row-btn" onclick="removeDataRow('${rowId}')">‚àí</button>
                    </div>
                `;
            } else {
                row.innerHTML = `
                    <input type="text" class="data-label" placeholder="Label" value="${defaultLabel}">
                    <input type="number" class="data-value" placeholder="Value" min="0" value="${defaultValue}">
                    <div class="row-controls">
                        <button class="row-btn remove-row-btn" onclick="removeDataRow('${rowId}')">‚àí</button>
                    </div>
                `;
            }
            
            dataRows.appendChild(row);
            
            // Add event listeners to the new inputs
            const labelInput = row.querySelector('.data-label');
            const valueInput = row.querySelector('.data-value');
            const iconSelect = row.querySelector('.data-icon');
            
            labelInput.addEventListener('input', () => {
                if (appState.currentGraphType === 'pictograph' && iconSelect) {
                    const uniqueIcon = getUniqueIcon(labelInput.value, rowId, iconSelect.value);
                    if (uniqueIcon && uniqueIcon !== iconSelect.value) {
                        iconSelect.value = uniqueIcon;
                    }
                }
                updateGraph();
            });
            valueInput.addEventListener('input', updateGraph);
            if (iconSelect) {
                iconSelect.addEventListener('change', () => {
                    // Check if this icon is already used by another row OR if dog icon is selected for non-dog label
                    const selectedIcon = iconSelect.value;
                    const usedIcons = getUsedIcons(rowId);
                    const currentLabel = (labelInput.value || "").toLowerCase();
                    const isDogRelated = currentLabel.includes("dog") || currentLabel.includes("puppy");
                    
                    // Prevent dog icon for non-dog labels
                    if (selectedIcon === "üê∂" && !isDogRelated) {
                        // Dog icon selected but label is not dog-related - find a unique alternative
                        const uniqueIcon = getUniqueIcon(labelInput.value, rowId);
                        if (uniqueIcon) {
                            iconSelect.value = uniqueIcon;
                        }
                        updateGraph();
                        return;
                    }
                    
                    if (usedIcons.has(selectedIcon)) {
                        // Icon is already used, find a unique one
                        const uniqueIcon = getUniqueIcon(labelInput.value, rowId);
                        if (uniqueIcon) {
                            iconSelect.value = uniqueIcon;
                        }
                    }
                    updateGraph();
                });
            }
            
            updateGraph();
        }

        // Remove a data row
        function removeDataRow(rowId) {
            const row = document.getElementById(rowId);
            if (row && dataRows.children.length > 1) {
                row.remove();
                updateGraph();
            }
        }

        // Update graph visualization
        function updateGraph() {
            // Collect data from input rows
            const data = [];
            const rows = dataRows.querySelectorAll('.data-row');
            
            rows.forEach(row => {
                const labelInput = row.querySelector('.data-label');
                const valueInput = row.querySelector('.data-value');
                const iconSelect = row.querySelector('.data-icon');
                
                const label = labelInput.value.trim();
                const value = parseFloat(valueInput.value) || 0;
                
                // Skip empty labels or invalid values
                if (label && value >= 0) {
                    const dataPoint = { label, value };
                    
                    // Add icon for pictographs with validation
                    if (appState.currentGraphType === 'pictograph' && iconSelect) {
                        const currentIcon = iconSelect.value;
                        const lowerLabel = label.toLowerCase();
                        const isDogRelated = lowerLabel.includes("dog") || lowerLabel.includes("puppy");
                        
                        // CRITICAL: Fix dog icon for non-dog labels immediately
                        if (currentIcon === "üê∂" && !isDogRelated) {
                            // Get correct icon and update dropdown
                            const rowId = row.id;
                            const correctIcon = getUniqueIcon(label, rowId);
                            if (correctIcon && correctIcon !== "üê∂") {
                                iconSelect.value = correctIcon;
                                dataPoint.icon = correctIcon;
                            } else {
                                // Fallback to safe icon
                                dataPoint.icon = "üìä";
                            }
                        } else {
                            dataPoint.icon = currentIcon;
                        }
                    }
                    
                    data.push(dataPoint);
                }
            });
            
            // Update app state
            appState.graphData = data;
            
            // Update display title and icon
            if (graphTitleInput.value) {
                graphDisplayTitle.textContent = graphTitleInput.value;
            } else {
                graphDisplayTitle.textContent = `${graphNames[appState.currentGraphType]} Preview`;
            }
            graphDisplayIcon.textContent = graphIcons[appState.currentGraphType];
            
            // Hide default message if we have data
            if (data.length > 0) {
                defaultGraphMessage.style.display = 'none';
                drawGraph();
                generateSummary();
                generateChallengeQuestions();
            } else {
                defaultGraphMessage.style.display = 'block';
                summaryText.textContent = "Add data to see insights about your graph.";
            }
        }

        // ============================================================================
        // GRAPH DRAWING FUNCTIONS
        // ============================================================================
        
        // SVG namespace constant
        const SVG_NS = "http://www.w3.org/2000/svg";
        
        // Common graph colors
        const GRAPH_COLORS = [
            '#4A6FA5', '#FF9E5D', '#5DBB63', '#FF6B8B', '#9D65C9',
            '#FFCC00', '#2EC4B6', '#E71D36', '#FF9F1C', '#8AC926'
        ];
        
        // ============================================================================
        // UTILITY FUNCTIONS
        // ============================================================================
        
        /**
         * Generate a random single-digit number (1-9) for kid-friendly graphs
         * @returns {number} Random number between 1 and 9
         */
        function getRandomSingleDigit() {
            return Math.floor(Math.random() * 9) + 1;
        }
        
        /**
         * Create an SVG element with namespace
         * @param {string} tagName - The SVG element tag name
         * @param {Object} attributes - Optional attributes to set
         * @returns {SVGElement} The created SVG element
         */
        function createSVGElement(tagName, attributes = {}) {
            const element = document.createElementNS(SVG_NS, tagName);
            Object.entries(attributes).forEach(([key, value]) => {
                element.setAttribute(key, value);
            });
            return element;
        }
        
        function drawGraph() {
            const data = appState.graphData;
            if (data.length === 0) return;
            
            graphVisualization.innerHTML = '';
            
            switch(appState.currentGraphType) {
                case 'pictograph':
                    drawPictograph(data);
                    break;
                case 'pie':
                    drawPieChart(data);
                    break;
                case 'line':
                    drawLineGraph(data);
                    break;
                case 'bar':
                    drawBarGraph(data);
                    break;
            }
        }

        // Draw a pictograph
        function drawPictograph(data) {
            const container = document.createElement('div');
            container.className = 'pictograph-container';
            
            // Sort data by value (largest first) for better visual organization
            const sortedData = [...data].sort((a, b) => b.value - a.value);
            
            sortedData.forEach(item => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'pictograph-item';
                
                // Create label container (on the left)
                const labelDiv = document.createElement('div');
                labelDiv.className = 'pictograph-label';
                labelDiv.innerHTML = `<strong>${item.label}</strong><span style="color: var(--text-light); font-size: 0.9rem;"> (${item.value})</span>`;
                
                // Create icon container (on the right)
                const iconsDiv = document.createElement('div');
                iconsDiv.className = 'pictograph-icons';
                
                // Add icons in a neat grid layout
                const iconCount = Math.min(item.value, 50); // Limit to 50 icons for performance
                const iconsPerRow = 10; // Fixed number of icons per row for neatness
                
                for (let i = 0; i < iconCount; i++) {
                    const iconSpan = document.createElement('span');
                    iconSpan.className = 'pictograph-icon';
                    iconSpan.textContent = item.icon || 'üîµ';
                    iconSpan.title = `${item.label}: ${item.value}`;
                    iconsDiv.appendChild(iconSpan);
                }
                
                // If value exceeds icon limit, show indicator
                if (item.value > 50) {
                    const moreSpan = document.createElement('span');
                    moreSpan.className = 'pictograph-icon';
                    moreSpan.textContent = `+${item.value - 50} more`;
                    moreSpan.style.fontSize = '0.9rem';
                    moreSpan.style.color = 'var(--text-light)';
                    moreSpan.style.fontWeight = 'bold';
                    iconsDiv.appendChild(moreSpan);
                }
                
                itemDiv.appendChild(labelDiv);
                itemDiv.appendChild(iconsDiv);
                container.appendChild(itemDiv);
            });
            
            graphVisualization.appendChild(container);
        }

        // Draw a pie chart
        function drawPieChart(data) {
            const svg = createSVGElement("svg");
            
            // Pie chart dimensions
            const pieRadius = 120;
            const centerX = 150;
            const centerY = 150;
            const legendItemHeight = 25;
            const padding = 20;
            
            // Calculate pie chart boundaries
            const pieLeft = centerX - pieRadius;
            const pieRight = centerX + pieRadius;
            const pieTop = centerY - pieRadius;
            const pieBottom = centerY + pieRadius;
            
            // Estimate legend width (longest label + value + spacing)
            // Use more accurate estimation: measure actual text lengths
            const maxLabelText = data.reduce((max, item) => {
                const text = `${item.label}: ${item.value}`;
                return text.length > max.length ? text : max;
            }, '');
            const estimatedLegendWidth = maxLabelText.length * 7 + 35; // 7px per char + box (15px) + spacing (20px)
            const legendHeight = data.length * legendItemHeight;
            
            // Determine best position: right side or below
            // Try right side first (need at least 300px width for comfortable spacing)
            const minWidthForRight = pieRight + padding + estimatedLegendWidth + padding;
            let legendX, legendY, legendPosition;
            
            if (minWidthForRight <= 650) {
                // Enough space to the right - position legend there
                legendX = pieRight + padding + 10;
                legendY = pieTop;
                legendPosition = 'right';
            } else {
                // Not enough space - position below pie chart, centered
                legendX = centerX - (estimatedLegendWidth / 2);
                // Ensure legend doesn't start too far left
                if (legendX < padding) legendX = padding;
                legendY = pieBottom + padding + 20;
                legendPosition = 'bottom';
            }
            
            // Calculate total dimensions needed to fit everything with proper padding
            const totalWidth = legendPosition === 'right' 
                ? Math.max(650, legendX + estimatedLegendWidth + padding)
                : Math.max(400, Math.max(pieRight + padding, legendX + estimatedLegendWidth + padding));
            const totalHeight = legendPosition === 'bottom'
                ? Math.max(400, legendY + legendHeight + padding)
                : Math.max(350, pieBottom + padding);
            
            svg.setAttribute("class", "graph-svg");
            svg.setAttribute("viewBox", `0 0 ${totalWidth} ${totalHeight}`);
            
            // Calculate total for percentages
            const total = data.reduce((sum, item) => sum + item.value, 0);
            
            // Colors for pie slices
            const colors = GRAPH_COLORS;
            
            let startAngle = 0;
            
            // Draw pie slices
            data.forEach((item, index) => {
                const sliceAngle = (item.value / total) * 2 * Math.PI;
                const endAngle = startAngle + sliceAngle;
                
                // Calculate points for the slice
                const x1 = centerX + pieRadius * Math.cos(startAngle);
                const y1 = centerY + pieRadius * Math.sin(startAngle);
                const x2 = centerX + pieRadius * Math.cos(endAngle);
                const y2 = centerY + pieRadius * Math.sin(endAngle);
                
                // Large arc flag (1 if slice angle > 180 degrees)
                const largeArcFlag = sliceAngle > Math.PI ? 1 : 0;
                
                // Create path for the slice
                const path = document.createElementNS(SVG_NS, "path");
                const pathData = `M ${centerX} ${centerY} L ${x1} ${y1} A ${pieRadius} ${pieRadius} 0 ${largeArcFlag} 1 ${x2} ${y2} Z`;
                path.setAttribute("d", pathData);
                path.setAttribute("fill", colors[index % colors.length]);
                path.setAttribute("stroke", "white");
                path.setAttribute("stroke-width", "2");
                
                // Add hover effect
                path.addEventListener('mouseover', function() {
                    this.style.opacity = '0.8';
                    showTooltip(item, event);
                });
                path.addEventListener('mouseout', function() {
                    this.style.opacity = '1';
                    hideTooltip();
                });
                
                // Add title for accessibility
                const title = document.createElementNS(SVG_NS, "title");
                title.textContent = `${item.label}: ${item.value} (${Math.round((item.value / total) * 100)}%)`;
                path.appendChild(title);
                
                svg.appendChild(path);
                startAngle = endAngle;
            });
            
            // Add legend - positioned outside pie chart area
            const legend = document.createElementNS(SVG_NS, "g");
            legend.setAttribute("transform", `translate(${legendX}, ${legendY})`);
            
            data.forEach((item, index) => {
                // Legend color box
                const rect = document.createElementNS(SVG_NS, "rect");
                rect.setAttribute("x", "0");
                rect.setAttribute("y", index * legendItemHeight);
                rect.setAttribute("width", "15");
                rect.setAttribute("height", "15");
                rect.setAttribute("fill", colors[index % colors.length]);
                rect.setAttribute("stroke", "white");
                rect.setAttribute("stroke-width", "1");
                legend.appendChild(rect);
                
                // Legend text - positioned to the right of color box
                const text = document.createElementNS(SVG_NS, "text");
                text.setAttribute("x", "20");
                text.setAttribute("y", index * legendItemHeight + 12);
                text.setAttribute("font-size", "12");
                text.setAttribute("fill", "var(--text)");
                text.textContent = `${item.label}: ${item.value}`;
                legend.appendChild(text);
            });
            
            svg.appendChild(legend);
            graphVisualization.appendChild(svg);
        }

        // Draw a line graph
        function drawLineGraph(data) {
            const svg = createSVGElement("svg", {
                "class": "graph-svg",
                "viewBox": "0 0 600 400"
            });
            
            // Setup margins and drawing area
            const margin = { top: 40, right: 40, bottom: 60, left: 60 };
            const width = 600 - margin.left - margin.right;
            const height = 400 - margin.top - margin.bottom;
            
            const g = createSVGElement("g", {
                "transform": `translate(${margin.left}, ${margin.top})`
            });
            
            // Find min and max values for scaling
            const values = data.map(item => item.value);
            const maxValue = Math.max(...values);
            const minValue = Math.min(...values);
            
            // Calculate x and y scales
            const xScale = width / (data.length - 1 || 1);
            const yScale = height / (maxValue - minValue || 1);
            
            // Draw grid lines (draw first so they appear behind everything)
            // Horizontal grid lines (for Y-axis values)
            const yStep = (maxValue - minValue) / 5;
            for (let i = 0; i <= 5; i++) {
                const value = minValue + i * yStep;
                const y = height - (value - minValue) * yScale;
                
                const gridLine = document.createElementNS(SVG_NS, "line");
                gridLine.setAttribute("x1", "0");
                gridLine.setAttribute("y1", y);
                gridLine.setAttribute("x2", width);
                gridLine.setAttribute("y2", y);
                gridLine.setAttribute("stroke", "var(--text-light)");
                gridLine.setAttribute("stroke-width", "1");
                gridLine.setAttribute("stroke-opacity", "0.3");
                gridLine.setAttribute("stroke-dasharray", "2,2");
                g.appendChild(gridLine);
            }
            
            // Vertical grid lines (for X-axis positions)
            data.forEach((item, index) => {
                const x = index * xScale;
                const gridLine = document.createElementNS(SVG_NS, "line");
                gridLine.setAttribute("x1", x);
                gridLine.setAttribute("y1", "0");
                gridLine.setAttribute("x2", x);
                gridLine.setAttribute("y2", height);
                gridLine.setAttribute("stroke", "var(--text-light)");
                gridLine.setAttribute("stroke-width", "1");
                gridLine.setAttribute("stroke-opacity", "0.3");
                gridLine.setAttribute("stroke-dasharray", "2,2");
                g.appendChild(gridLine);
            });
            
            // Create line path
                const path = document.createElementNS(SVG_NS, "path");
            let pathData = `M 0 ${height - (data[0].value - minValue) * yScale}`;
            
            data.forEach((item, index) => {
                const x = index * xScale;
                const y = height - (item.value - minValue) * yScale;
                pathData += ` L ${x} ${y}`;
                
                // Add data point circle
                const circle = document.createElementNS(SVG_NS, "circle");
                circle.setAttribute("cx", x);
                circle.setAttribute("cy", y);
                circle.setAttribute("r", "5");
                circle.setAttribute("fill", GRAPH_COLORS[0]);
                circle.setAttribute("stroke", "white");
                circle.setAttribute("stroke-width", "2");
                
                // Add hover effect
                circle.addEventListener('mouseover', function() {
                    this.setAttribute("r", "7");
                    showTooltip(item, event);
                });
                circle.addEventListener('mouseout', function() {
                    this.setAttribute("r", "5");
                    hideTooltip();
                });
                
                // Add title for accessibility
                const title = document.createElementNS(SVG_NS, "title");
                title.textContent = `${item.label}: ${item.value}`;
                circle.appendChild(title);
                
                g.appendChild(circle);
            });
            
            path.setAttribute("d", pathData);
            path.setAttribute("fill", "none");
            path.setAttribute("stroke", GRAPH_COLORS[0]);
            path.setAttribute("stroke-width", "3");
            
            // Add axes
            const xAxis = document.createElementNS(SVG_NS, "line");
            xAxis.setAttribute("x1", "0");
            xAxis.setAttribute("y1", height);
            xAxis.setAttribute("x2", width);
            xAxis.setAttribute("y2", height);
            xAxis.setAttribute("stroke", "var(--text)");
            xAxis.setAttribute("stroke-width", "2");
            
            const yAxis = document.createElementNS(SVG_NS, "line");
            yAxis.setAttribute("x1", "0");
            yAxis.setAttribute("y1", "0");
            yAxis.setAttribute("x2", "0");
            yAxis.setAttribute("y2", height);
            yAxis.setAttribute("stroke", "var(--text)");
            yAxis.setAttribute("stroke-width", "2");
            
            // Add labels on x-axis with tick marks
            data.forEach((item, index) => {
                const x = index * xScale;
                
                // Draw tick mark on X-axis
                const tick = document.createElementNS(SVG_NS, "line");
                tick.setAttribute("x1", x);
                tick.setAttribute("y1", height);
                tick.setAttribute("x2", x);
                tick.setAttribute("y2", height + 5);
                tick.setAttribute("stroke", "var(--text)");
                tick.setAttribute("stroke-width", "2");
                g.appendChild(tick);
                
                const text = document.createElementNS(SVG_NS, "text");
                text.setAttribute("x", x);
                text.setAttribute("y", height + 20);
                text.setAttribute("text-anchor", "middle");
                text.setAttribute("font-size", "12");
                text.setAttribute("fill", "var(--text)");
                text.textContent = item.label;
                g.appendChild(text);
            });
            
            // Add y-axis values (yStep already declared in grid section above)
            for (let i = 0; i <= 5; i++) {
                const value = minValue + i * yStep;
                const y = height - (value - minValue) * yScale;
                
                const text = document.createElementNS(SVG_NS, "text");
                text.setAttribute("x", -10);
                text.setAttribute("y", y + 3);
                text.setAttribute("text-anchor", "end");
                text.setAttribute("font-size", "10");
                text.setAttribute("fill", "var(--text)");
                text.textContent = Math.round(value);
                g.appendChild(text);
            }
            
            // Add axis labels
            const xLabel = document.createElementNS(SVG_NS, "text");
            xLabel.setAttribute("x", width / 2);
            xLabel.setAttribute("y", height + 40);
            xLabel.setAttribute("text-anchor", "middle");
            xLabel.setAttribute("font-size", "14");
            xLabel.setAttribute("fill", "var(--text)");
            xLabel.textContent = xLabelInput.value || "Categories";
            g.appendChild(xLabel);
            
            const yLabel = document.createElementNS(SVG_NS, "text");
            yLabel.setAttribute("transform", `rotate(-90) translate(-${height/2}, -40)`);
            yLabel.setAttribute("text-anchor", "middle");
            yLabel.setAttribute("font-size", "14");
            yLabel.setAttribute("fill", "var(--text)");
            yLabel.textContent = yLabelInput.value || "Values";
            g.appendChild(yLabel);
            
            // Assemble the SVG
            g.appendChild(xAxis);
            g.appendChild(yAxis);
            g.appendChild(path);
            
            svg.appendChild(g);
            graphVisualization.appendChild(svg);
        }

        // Draw a bar graph
        function drawBarGraph(data) {
            const svg = createSVGElement("svg", {
                "class": "graph-svg",
                "viewBox": "0 0 600 400"
            });
            
            // Setup margins and drawing area
            const margin = { top: 40, right: 40, bottom: 60, left: 60 };
            const width = 600 - margin.left - margin.right;
            const height = 400 - margin.top - margin.bottom;
            
            const g = createSVGElement("g", {
                "transform": `translate(${margin.left}, ${margin.top})`
            });
            
            // Find max value for scaling
            const maxValue = Math.max(...data.map(item => item.value));
            
            // Draw grid lines (draw first so they appear behind everything)
            // Horizontal grid lines (for Y-axis values)
            const gridSteps = 5;
            const yStep = maxValue / gridSteps;
            for (let i = 0; i <= gridSteps; i++) {
                const value = i * yStep;
                const y = height - (value / maxValue) * height;
                
                const gridLine = document.createElementNS(SVG_NS, "line");
                gridLine.setAttribute("x1", "0");
                gridLine.setAttribute("y1", y);
                gridLine.setAttribute("x2", width);
                gridLine.setAttribute("y2", y);
                gridLine.setAttribute("stroke", "var(--text-light)");
                gridLine.setAttribute("stroke-width", "1");
                gridLine.setAttribute("stroke-opacity", "0.3");
                gridLine.setAttribute("stroke-dasharray", "2,2");
                g.appendChild(gridLine);
            }
            
            // Calculate bar width and spacing
            const barWidth = width / data.length * 0.7;
            const barSpacing = width / data.length * 0.3;
            
            // Colors for bars
            const colors = GRAPH_COLORS;
            
            // Draw bars
            data.forEach((item, index) => {
                const barHeight = (item.value / maxValue) * height;
                const x = index * (barWidth + barSpacing);
                const y = height - barHeight;
                
                // Create bar
                const rect = document.createElementNS(SVG_NS, "rect");
                rect.setAttribute("x", x);
                rect.setAttribute("y", y);
                rect.setAttribute("width", barWidth);
                rect.setAttribute("height", barHeight);
                rect.setAttribute("fill", colors[index % colors.length]);
                rect.setAttribute("stroke", "white");
                rect.setAttribute("stroke-width", "1");
                
                // Add hover effect
                rect.addEventListener('mouseover', function() {
                    this.style.opacity = '0.8';
                    showTooltip(item, event);
                });
                rect.addEventListener('mouseout', function() {
                    this.style.opacity = '1';
                    hideTooltip();
                });
                
                // Add title for accessibility
                const title = document.createElementNS(SVG_NS, "title");
                title.textContent = `${item.label}: ${item.value}`;
                rect.appendChild(title);
                
                g.appendChild(rect);
                
                // Add label below bar
                const text = document.createElementNS(SVG_NS, "text");
                text.setAttribute("x", x + barWidth / 2);
                text.setAttribute("y", height + 20);
                text.setAttribute("text-anchor", "middle");
                text.setAttribute("font-size", "12");
                text.setAttribute("fill", "var(--text)");
                text.textContent = item.label;
                g.appendChild(text);
                
                // Add value on top of bar
                const valueText = document.createElementNS(SVG_NS, "text");
                valueText.setAttribute("x", x + barWidth / 2);
                valueText.setAttribute("y", y - 5);
                valueText.setAttribute("text-anchor", "middle");
                valueText.setAttribute("font-size", "11");
                valueText.setAttribute("fill", "var(--text)");
                valueText.setAttribute("font-weight", "bold");
                valueText.textContent = item.value;
                g.appendChild(valueText);
                
                // X-axis tick mark
                const tick = document.createElementNS(SVG_NS, "line");
                tick.setAttribute("x1", x + barWidth / 2);
                tick.setAttribute("y1", height);
                tick.setAttribute("x2", x + barWidth / 2);
                tick.setAttribute("y2", height + 5);
                tick.setAttribute("stroke", "var(--text)");
                tick.setAttribute("stroke-width", "2");
                g.appendChild(tick);
            });
            
            // Add axes
            const xAxis = document.createElementNS(SVG_NS, "line");
            xAxis.setAttribute("x1", "0");
            xAxis.setAttribute("y1", height);
            xAxis.setAttribute("x2", width);
            xAxis.setAttribute("y2", height);
            xAxis.setAttribute("stroke", "var(--text)");
            xAxis.setAttribute("stroke-width", "2");
            
            const yAxis = document.createElementNS(SVG_NS, "line");
            yAxis.setAttribute("x1", "0");
            yAxis.setAttribute("y1", "0");
            yAxis.setAttribute("x2", "0");
            yAxis.setAttribute("y2", height);
            yAxis.setAttribute("stroke", "var(--text)");
            yAxis.setAttribute("stroke-width", "2");
            
            // Add y-axis values with tick marks (gridSteps already declared in grid section above)
            for (let i = 0; i <= gridSteps; i++) {
                const value = (maxValue / gridSteps) * i;
                const y = height - (value / maxValue) * height;
                
                // Tick mark
                const tick = document.createElementNS(SVG_NS, "line");
                tick.setAttribute("x1", "-5");
                tick.setAttribute("y1", y);
                tick.setAttribute("x2", "0");
                tick.setAttribute("y2", y);
                tick.setAttribute("stroke", "var(--text)");
                tick.setAttribute("stroke-width", "2");
                g.appendChild(tick);
                
                // Label
                const text = document.createElementNS(SVG_NS, "text");
                text.setAttribute("x", -10);
                text.setAttribute("y", y + 3);
                text.setAttribute("text-anchor", "end");
                text.setAttribute("font-size", "11");
                text.setAttribute("fill", "var(--text)");
                text.setAttribute("font-weight", "500");
                const displayValue = value % 1 === 0 ? Math.round(value) : value.toFixed(1);
                text.textContent = displayValue;
                g.appendChild(text);
            }
            
            // Add axis labels
            const xLabel = document.createElementNS(SVG_NS, "text");
            xLabel.setAttribute("x", width / 2);
            xLabel.setAttribute("y", height + 40);
            xLabel.setAttribute("text-anchor", "middle");
            xLabel.setAttribute("font-size", "14");
            xLabel.setAttribute("fill", "var(--text)");
            xLabel.textContent = xLabelInput.value || "Categories";
            g.appendChild(xLabel);
            
            const yLabel = document.createElementNS(SVG_NS, "text");
            yLabel.setAttribute("transform", `rotate(-90) translate(-${height/2}, -40)`);
            yLabel.setAttribute("text-anchor", "middle");
            yLabel.setAttribute("font-size", "14");
            yLabel.setAttribute("fill", "var(--text)");
            yLabel.textContent = yLabelInput.value || "Values";
            g.appendChild(yLabel);
            
            // Assemble the SVG
            g.appendChild(xAxis);
            g.appendChild(yAxis);
            
            svg.appendChild(g);
            graphVisualization.appendChild(svg);
        }

        // Show tooltip on graph elements
        function showTooltip(dataItem, event) {
            // Remove any existing tooltip
            hideTooltip();
            
            const tooltip = document.createElement('div');
            tooltip.id = 'graphTooltip';
            tooltip.style.position = 'absolute';
            tooltip.style.backgroundColor = 'var(--card)';
            tooltip.style.color = 'var(--text)';
            tooltip.style.padding = '10px 15px';
            tooltip.style.borderRadius = '8px';
            tooltip.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
            tooltip.style.border = '2px solid var(--primary)';
            tooltip.style.zIndex = '1000';
            tooltip.style.maxWidth = '250px';
            tooltip.style.fontSize = '14px';
            
            // Calculate total for percentage if needed
            let tooltipText = `<strong>${dataItem.label}</strong>: ${dataItem.value}`;
            
            if (appState.currentGraphType === 'pie' || appState.currentGraphType === 'pictograph') {
                const total = appState.graphData.reduce((sum, item) => sum + item.value, 0);
                const percentage = Math.round((dataItem.value / total) * 100);
                tooltipText += ` (${percentage}% of total)`;
            }
            
            tooltip.innerHTML = tooltipText;
            document.body.appendChild(tooltip);
            
            // Position tooltip near cursor
            const x = event.clientX + 10;
            const y = event.clientY + 10;
            
            tooltip.style.left = `${x}px`;
            tooltip.style.top = `${y}px`;
        }

        // Hide tooltip
        function hideTooltip() {
            const tooltip = document.getElementById('graphTooltip');
            if (tooltip) {
                tooltip.remove();
            }
        }

        // Generate summary text
        function generateSummary() {
            const data = appState.graphData;
            if (data.length === 0) {
                summaryText.textContent = "Add data to see insights about your graph.";
                return;
            }
            
            const total = data.reduce((sum, item) => sum + item.value, 0);
            const maxItem = data.reduce((max, item) => item.value > max.value ? item : max, data[0]);
            const minItem = data.reduce((min, item) => item.value < min.value ? item : min, data[0]);
            
            let summary = "";
            
            switch(appState.currentGraphType) {
                case 'pictograph':
                    summary = `This pictograph shows ${data.length} different items. `;
                    summary += `The most common item is ${maxItem.label} with ${maxItem.value} pictures. `;
                    summary += `There are ${total} pictures in total.`;
                    break;
                    
                case 'pie':
                    const maxPercent = Math.round((maxItem.value / total) * 100);
                    const minPercent = Math.round((minItem.value / total) * 100);
                    summary = `This pie chart shows how a total of ${total} is divided. `;
                    summary += `${maxItem.label} is the biggest slice at ${maxPercent}%. `;
                    summary += `${minItem.label} is the smallest slice at ${minPercent}%.`;
                    break;
                    
                case 'line':
                    const firstValue = data[0].value;
                    const lastValue = data[data.length - 1].value;
                    const change = lastValue - firstValue;
                    const trend = change > 0 ? "increased" : change < 0 ? "decreased" : "stayed the same";
                    
                    summary = `This line graph shows changes over ${data.length} points. `;
                    summary += `The values range from ${minItem.value} to ${maxItem.value}. `;
                    summary += `Overall, the values ${trend} by ${Math.abs(change)}.`;
                    break;
                    
                case 'bar':
                    const difference = maxItem.value - minItem.value;
                    summary = `This bar graph compares ${data.length} different items. `;
                    summary += `The tallest bar is ${maxItem.label} with ${maxItem.value}. `;
                    summary += `The shortest bar is ${minItem.label} with ${minItem.value}. `;
                    summary += `That's a difference of ${difference}.`;
                    break;
            }
            
            summaryText.textContent = summary;
        }

        // Generate challenge questions
        function generateChallengeQuestions() {
            const data = appState.graphData;
            if (data.length < 2) return;
            
            const total = data.reduce((sum, item) => sum + item.value, 0);
            const maxItem = data.reduce((max, item) => item.value > max.value ? item : max, data[0]);
            const minItem = data.reduce((min, item) => item.value < min.value ? item : min, data[0]);
            
            // Clear previous questions
            appState.challenges.questions = [];
            
            // Generate questions based on graph type
            switch(appState.currentGraphType) {
                case 'pictograph':
                case 'bar':
                    appState.challenges.questions.push({
                        question: `Which ${xLabelInput.value.toLowerCase() || 'category'} has the largest value?`,
                        answers: data.map(item => item.label),
                        correctAnswer: maxItem.label,
                        type: 'multiple-choice'
                    });
                    
                    appState.challenges.questions.push({
                        question: `What is the total of all values?`,
                        answers: [total, total + 5, total - 2, Math.floor(total * 1.5)],
                        correctAnswer: total,
                        type: 'multiple-choice'
                    });
                    
                    if (data.length >= 2) {
                        const secondLargest = [...data].sort((a, b) => b.value - a.value)[1];
                        const difference = maxItem.value - secondLargest.value;
                        appState.challenges.questions.push({
                            question: `How much larger is ${maxItem.label} than ${secondLargest.label}?`,
                            answers: [difference, difference + 2, maxItem.value, secondLargest.value],
                            correctAnswer: difference,
                            type: 'multiple-choice'
                        });
                    }
                    break;
                    
                case 'pie':
                    const maxPercent = Math.round((maxItem.value / total) * 100);
                    appState.challenges.questions.push({
                        question: `What percentage does ${maxItem.label} represent?`,
                        answers: [`${maxPercent}%`, "25%", "50%", "75%"],
                        correctAnswer: `${maxPercent}%`,
                        type: 'multiple-choice'
                    });
                    
                    appState.challenges.questions.push({
                        question: `If ${maxItem.label} has ${maxItem.value} and ${minItem.label} has ${minItem.value}, what's the difference?`,
                        answers: [maxItem.value - minItem.value, maxItem.value, minItem.value, total],
                        correctAnswer: maxItem.value - minItem.value,
                        type: 'multiple-choice'
                    });
                    break;
                    
                case 'line':
                    const firstValue = data[0].value;
                    const lastValue = data[data.length - 1].value;
                    const change = lastValue - firstValue;
                    
                    appState.challenges.questions.push({
                        question: `What is the value at the start?`,
                        answers: [firstValue, lastValue, maxItem.value, minItem.value],
                        correctAnswer: firstValue,
                        type: 'multiple-choice'
                    });
                    
                    appState.challenges.questions.push({
                        question: `Did the values increase or decrease overall?`,
                        answers: [change > 0 ? "Increased" : "Decreased", "Stayed the same", "Both", "Can't tell"],
                        correctAnswer: change > 0 ? "Increased" : "Decreased",
                        type: 'multiple-choice'
                    });
                    break;
            }
        }

        // ============================================================================
        // CHALLENGE MODE FUNCTIONS
        // ============================================================================
        
        /**
         * Exit the challenge and return to the main app
         * Stops timer, re-enables inputs, and restores the original graph
         */
        function exitChallenge() {
            // Stop timer if running
            if (appState.challenges.timer) {
                clearInterval(appState.challenges.timer);
                appState.challenges.timer = null;
            }
            
            // Re-enable input fields
            const inputPanel = document.querySelector('.input-panel');
            if (inputPanel) {
                inputPanel.style.opacity = '1';
                inputPanel.style.pointerEvents = 'auto';
            }
            
            const allInputs = document.querySelectorAll('.input-panel input, .input-panel select, .input-panel button');
            allInputs.forEach(input => {
                input.disabled = false;
                input.style.cursor = '';
            });
            
            // Reset challenge state
            appState.challenges.timedMode = false;
            appState.challenges.active = false;
            challengeOverlay.style.display = 'none';
            document.body.style.overflow = ''; // Restore scrolling
            
            // Restore original graph if needed
            if (appState.graphData.length > 0) {
                updateGraph();
            }
        }
        
        function startTimedChallenge() {
            // Reset challenge state
            appState.challenges.timedMode = true;
            appState.challenges.active = true;
            appState.challenges.score = 0;
            appState.challenges.correctAnswers = 0;
            appState.challenges.totalAnswered = 0;
            appState.challenges.timeRemaining = 120; // 2 minutes
            
            // Ensure we're on the graph builder screen
            if (homeScreen.style.display !== 'none') {
                // Need to select a graph type first - use a random one
                const graphTypes = ['pictograph', 'pie', 'line', 'bar'];
                const randomType = graphTypes[Math.floor(Math.random() * graphTypes.length)];
                selectGraph(randomType);
            }
            
            // Show challenge overlay
            challengeOverlay.style.display = 'flex';
            document.body.style.overflow = 'hidden'; // Prevent background scrolling
            challengeTimer.style.display = 'flex';
            challengeStats.style.display = 'flex';
            challengeResults.style.display = 'none';
            
            // Show question/answers sections
            document.getElementById('challengeQuestion').style.display = 'block';
            document.getElementById('challengeAnswers').style.display = 'flex';
            if (challengeGraphDisplay) {
                challengeGraphDisplay.style.display = 'flex';
            }
            
            // Update UI
            updateChallengeStats();
            updateTimerDisplay();
            
            // Generate first random challenge graph
            generateRandomChallengeGraph();
            
            // Start timer
            startChallengeTimer();
        }

        // Generate a random challenge graph with question
        function generateRandomChallengeGraph() {
            // Pick a random graph type
            const graphTypes = ['pictograph', 'pie', 'line', 'bar'];
            const randomGraphType = graphTypes[Math.floor(Math.random() * graphTypes.length)];
            
            // Pick a random topic
            const topic = randomTopics[Math.floor(Math.random() * randomTopics.length)];
            
            // Randomize how many items (between 3 and 6)
            const numItems = Math.floor(Math.random() * 4) + 3;
            
            // Shuffle labels/icons and pick numItems
            const shuffledIndices = [...Array(topic.labels.length).keys()].sort(() => Math.random() - 0.5);
            const selectedIndices = shuffledIndices.slice(0, numItems);
            
            const randomData = selectedIndices.map(idx => ({
                label: topic.labels[idx],
                value: getRandomSingleDigit(),
                icon: topic.icons[idx]
            }));
            
            // Store challenge graph data
            appState.challenges.challengeGraphData = randomData;
            appState.challenges.challengeGraphType = randomGraphType;
            
            // Load the graph
            const challengeExample = {
                title: topic.title,
                xLabel: topic.xLabel,
                yLabel: topic.yLabel,
                data: randomData
            };
            
            // Set graph type and ensure screen is visible
            if (!appState.currentGraphType || appState.currentGraphType !== randomGraphType) {
                // Update screen title and icon
                screenTitle.textContent = `${graphNames[randomGraphType]} Challenge`;
                graphDisplayTitle.textContent = `${graphNames[randomGraphType]} Preview`;
                graphDisplayIcon.textContent = graphIcons[randomGraphType];
            }
            
            appState.currentGraphType = randomGraphType;
            
            // Ensure graph builder screen is visible
            homeScreen.style.display = 'none';
            graphBuilderScreen.style.display = 'flex';
            
            // Load the graph
            loadExample(randomGraphType, challengeExample);
            
            // Disable input fields during challenge
            if (appState.challenges.timedMode) {
                const inputPanel = document.querySelector('.input-panel');
                if (inputPanel) {
                    inputPanel.style.opacity = '0.6';
                    inputPanel.style.pointerEvents = 'none';
                }
                
                // Disable all input fields
                const allInputs = document.querySelectorAll('.input-panel input, .input-panel select, .input-panel button');
                allInputs.forEach(input => {
                    input.disabled = true;
                    input.style.cursor = 'not-allowed';
                });
            }
            
            // Generate question for this graph
            generateChallengeQuestionForGraph(randomData, randomGraphType, topic);
            
            // Draw the graph in the challenge modal
            drawChallengeGraph(randomData, randomGraphType);
            
            // Show the question
            showNextChallenge();
        }

        // Draw graph in challenge modal
        function drawChallengeGraph(data, graphType) {
            if (!challengeGraphDisplay || data.length === 0) return;
            
            // Clear previous graph
            challengeGraphDisplay.innerHTML = '';
            
            switch(graphType) {
                case 'pictograph':
                    drawChallengePictograph(data);
                    break;
                case 'pie':
                    drawChallengePieChart(data);
                    break;
                case 'line':
                    drawChallengeLineGraph(data);
                    break;
                case 'bar':
                    drawChallengeBarGraph(data);
                    break;
            }
        }

        // Draw pictograph in challenge modal
        function drawChallengePictograph(data) {
            const container = document.createElement('div');
            container.className = 'pictograph-container';
            
            // Sort data by value (largest first) for better visual organization
            const sortedData = [...data].sort((a, b) => b.value - a.value);
            
            sortedData.forEach(item => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'pictograph-item';
                
                // Create label container (on the left)
                const labelDiv = document.createElement('div');
                labelDiv.className = 'pictograph-label';
                labelDiv.innerHTML = `<strong>${item.label}</strong><span style="color: var(--text-light); font-size: 0.85rem;"> (${item.value})</span>`;
                
                // Create icon container (on the right)
                const iconsDiv = document.createElement('div');
                iconsDiv.className = 'pictograph-icons';
                
                // Add icons in a neat grid layout (limit for modal display)
                const iconCount = Math.min(item.value, 20); // Limit to 20 icons for modal
                const iconsPerRow = 8; // Fixed number of icons per row for modal
                
                for (let i = 0; i < iconCount; i++) {
                    const iconSpan = document.createElement('span');
                    iconSpan.className = 'pictograph-icon';
                    iconSpan.textContent = item.icon || 'üîµ';
                    iconSpan.title = `${item.label}: ${item.value}`;
                    iconSpan.style.fontSize = '1.4rem'; // Slightly smaller for modal
                    iconsDiv.appendChild(iconSpan);
                }
                
                // If value exceeds icon limit, show indicator
                if (item.value > 20) {
                    const moreSpan = document.createElement('span');
                    moreSpan.className = 'pictograph-icon';
                    moreSpan.textContent = `+${item.value - 20}`;
                    moreSpan.style.fontSize = '0.8rem';
                    moreSpan.style.color = 'var(--text-light)';
                    moreSpan.style.fontWeight = 'bold';
                    iconsDiv.appendChild(moreSpan);
                }
                
                itemDiv.appendChild(labelDiv);
                itemDiv.appendChild(iconsDiv);
                container.appendChild(itemDiv);
            });
            
            challengeGraphDisplay.appendChild(container);
        }

        // Draw pie chart in challenge modal
        function drawChallengePieChart(data) {
            const svg = createSVGElement("svg", { "class": "graph-svg" });
            
            // Smaller dimensions for modal
            const pieRadius = 80;
            const centerX = 100;
            const centerY = 100;
            const legendItemHeight = 20;
            const padding = 15;
            
            // Calculate pie chart boundaries
            const pieLeft = centerX - pieRadius;
            const pieRight = centerX + pieRadius;
            const pieTop = centerY - pieRadius;
            const pieBottom = centerY + pieRadius;
            
            // Estimate legend width
            const maxLabelText = data.reduce((max, item) => {
                const text = `${item.label}: ${item.value}`;
                return text.length > max.length ? text : max;
            }, '');
            const estimatedLegendWidth = maxLabelText.length * 6 + 30;
            const legendHeight = data.length * legendItemHeight;
            
            // Determine best position
            const minWidthForRight = pieRight + padding + estimatedLegendWidth + padding;
            let legendX, legendY, legendPosition, totalWidth, totalHeight;
            
            if (minWidthForRight <= 400) {
                legendX = pieRight + padding + 5;
                legendY = pieTop;
                legendPosition = 'right';
                totalWidth = pieRight + padding + estimatedLegendWidth + padding;
                totalHeight = Math.max(pieBottom + padding, legendY + legendHeight + padding);
            } else {
                legendX = centerX;
                legendY = pieBottom + padding + 10;
                legendPosition = 'below';
                totalWidth = Math.max(pieRight + padding, estimatedLegendWidth + padding * 2);
                totalHeight = pieBottom + padding + legendHeight + padding;
            }
            
            svg.setAttribute("viewBox", `0 0 ${totalWidth} ${totalHeight}`);
            
            // Calculate total for percentages
            const total = data.reduce((sum, item) => sum + item.value, 0);
            let currentAngle = -90;
            
            // Colors
            const colors = GRAPH_COLORS;
            
            // Draw pie slices
            data.forEach((item, index) => {
                const percentage = (item.value / total) * 100;
                const sliceAngle = (item.value / total) * 360;
                
                const startAngle = currentAngle;
                const endAngle = currentAngle + sliceAngle;
                
                const startAngleRad = (startAngle * Math.PI) / 180;
                const endAngleRad = (endAngle * Math.PI) / 180;
                
                const x1 = centerX + pieRadius * Math.cos(startAngleRad);
                const y1 = centerY + pieRadius * Math.sin(startAngleRad);
                const x2 = centerX + pieRadius * Math.cos(endAngleRad);
                const y2 = centerY + pieRadius * Math.sin(endAngleRad);
                
                const largeArc = sliceAngle > 180 ? 1 : 0;
                
                const path = document.createElementNS(SVG_NS, "path");
                path.setAttribute("d", `M ${centerX} ${centerY} L ${x1} ${y1} A ${pieRadius} ${pieRadius} 0 ${largeArc} 1 ${x2} ${y2} Z`);
                path.setAttribute("fill", colors[index % colors.length]);
                path.setAttribute("stroke", "white");
                path.setAttribute("stroke-width", "2");
                svg.appendChild(path);
                
                currentAngle = endAngle;
            });
            
            // Draw legend
            data.forEach((item, index) => {
                const legendYPos = legendPosition === 'right' 
                    ? legendY + index * legendItemHeight 
                    : legendY + index * legendItemHeight;
                const legendXPos = legendPosition === 'right' 
                    ? legendX 
                    : legendX - estimatedLegendWidth / 2;
                
                // Color box
                const rect = document.createElementNS(SVG_NS, "rect");
                rect.setAttribute("x", legendXPos);
                rect.setAttribute("y", legendYPos - 10);
                rect.setAttribute("width", 15);
                rect.setAttribute("height", 15);
                rect.setAttribute("fill", colors[index % colors.length]);
                svg.appendChild(rect);
                
                // Label text
                const text = document.createElementNS(SVG_NS, "text");
                text.setAttribute("x", legendXPos + 20);
                text.setAttribute("y", legendYPos);
                text.setAttribute("font-size", "12");
                text.setAttribute("fill", "var(--text)");
                text.textContent = `${item.label}: ${item.value}`;
                svg.appendChild(text);
            });
            
            challengeGraphDisplay.appendChild(svg);
        }

        // Draw line graph in challenge modal
        function drawChallengeLineGraph(data) {
            const svg = createSVGElement("svg", {
                "class": "graph-svg",
                "viewBox": "0 0 400 250"
            });
            
            const margin = { top: 30, right: 30, bottom: 40, left: 50 };
            const width = 400 - margin.left - margin.right;
            const height = 250 - margin.top - margin.bottom;
            
            const g = createSVGElement("g", {
                "transform": `translate(${margin.left}, ${margin.top})`
            });
            
            const values = data.map(item => item.value);
            const maxValue = Math.max(...values);
            const minValue = Math.min(...values);
            
            const xScale = width / (data.length - 1 || 1);
            const yScale = height / (maxValue - minValue || 1);
            
            // Draw grid lines (draw first so they appear behind everything)
            // Horizontal grid lines (for Y-axis values)
            const yStep = (maxValue - minValue) / 5;
            for (let i = 0; i <= 5; i++) {
                const value = minValue + i * yStep;
                const y = height - (value - minValue) * yScale;
                
                const gridLine = document.createElementNS(SVG_NS, "line");
                gridLine.setAttribute("x1", "0");
                gridLine.setAttribute("y1", y);
                gridLine.setAttribute("x2", width);
                gridLine.setAttribute("y2", y);
                gridLine.setAttribute("stroke", "var(--text-light)");
                gridLine.setAttribute("stroke-width", "1");
                gridLine.setAttribute("stroke-opacity", "0.3");
                gridLine.setAttribute("stroke-dasharray", "2,2");
                g.appendChild(gridLine);
            }
            
            // Vertical grid lines (for X-axis positions)
            data.forEach((item, index) => {
                const x = index * xScale;
                const gridLine = document.createElementNS(SVG_NS, "line");
                gridLine.setAttribute("x1", x);
                gridLine.setAttribute("y1", "0");
                gridLine.setAttribute("x2", x);
                gridLine.setAttribute("y2", height);
                gridLine.setAttribute("stroke", "var(--text-light)");
                gridLine.setAttribute("stroke-width", "1");
                gridLine.setAttribute("stroke-opacity", "0.3");
                gridLine.setAttribute("stroke-dasharray", "2,2");
                g.appendChild(gridLine);
            });
            
            // Create line path
            const path = document.createElementNS(SVG_NS, "path");
            let pathData = `M 0 ${height - (data[0].value - minValue) * yScale}`;
            
            data.forEach((item, index) => {
                const x = index * xScale;
                const y = height - (item.value - minValue) * yScale;
                pathData += ` L ${x} ${y}`;
            });
            
            path.setAttribute("d", pathData);
            path.setAttribute("fill", "none");
            path.setAttribute("stroke", GRAPH_COLORS[0]);
            path.setAttribute("stroke-width", "3");
            g.appendChild(path);
            
            // Draw points with value labels
            data.forEach((item, index) => {
                const x = index * xScale;
                const y = height - (item.value - minValue) * yScale;
                
                const circle = document.createElementNS(SVG_NS, "circle");
                circle.setAttribute("cx", x);
                circle.setAttribute("cy", y);
                circle.setAttribute("r", "6");
                circle.setAttribute("fill", GRAPH_COLORS[0]);
                circle.setAttribute("stroke", "white");
                circle.setAttribute("stroke-width", "2");
                g.appendChild(circle);
                
                // Value label above point
                const valueText = document.createElementNS(SVG_NS, "text");
                valueText.setAttribute("x", x);
                valueText.setAttribute("y", y - 10);
                valueText.setAttribute("font-size", "10");
                valueText.setAttribute("text-anchor", "middle");
                valueText.setAttribute("fill", "var(--text)");
                valueText.setAttribute("font-weight", "600");
                valueText.textContent = item.value;
                g.appendChild(valueText);
                
                // X-axis label
                const text = document.createElementNS(SVG_NS, "text");
                text.setAttribute("x", x);
                text.setAttribute("y", height + 20);
                text.setAttribute("font-size", "10");
                text.setAttribute("text-anchor", "middle");
                text.setAttribute("fill", "var(--text)");
                text.textContent = item.label;
                g.appendChild(text);
            });
            
            // Y-axis with tick marks
            const yAxis = document.createElementNS(SVG_NS, "line");
            yAxis.setAttribute("x1", 0);
            yAxis.setAttribute("y1", 0);
            yAxis.setAttribute("x2", 0);
            yAxis.setAttribute("y2", height);
            yAxis.setAttribute("stroke", "var(--text)");
            yAxis.setAttribute("stroke-width", "2");
            g.appendChild(yAxis);
            
            // Y-axis tick marks and labels
            for (let i = 0; i <= 5; i++) {
                const value = minValue + i * yStep;
                const y = height - (value - minValue) * yScale;
                
                // Tick mark
                const tick = document.createElementNS(SVG_NS, "line");
                tick.setAttribute("x1", "-5");
                tick.setAttribute("y1", y);
                tick.setAttribute("x2", "0");
                tick.setAttribute("y2", y);
                tick.setAttribute("stroke", "var(--text)");
                tick.setAttribute("stroke-width", "2");
                g.appendChild(tick);
                
                // Label
                const text = document.createElementNS(SVG_NS, "text");
                text.setAttribute("x", -10);
                text.setAttribute("y", y + 3);
                text.setAttribute("text-anchor", "end");
                text.setAttribute("font-size", "10");
                text.setAttribute("fill", "var(--text)");
                text.setAttribute("font-weight", "500");
                const displayValue = value % 1 === 0 ? Math.round(value) : value.toFixed(1);
                text.textContent = displayValue;
                g.appendChild(text);
            }
            
            // X-axis with tick marks
            const xAxis = document.createElementNS(SVG_NS, "line");
            xAxis.setAttribute("x1", 0);
            xAxis.setAttribute("y1", height);
            xAxis.setAttribute("x2", width);
            xAxis.setAttribute("y2", height);
            xAxis.setAttribute("stroke", "var(--text)");
            xAxis.setAttribute("stroke-width", "2");
            g.appendChild(xAxis);
            
            // X-axis tick marks
            data.forEach((item, index) => {
                const x = index * xScale;
                const tick = document.createElementNS(SVG_NS, "line");
                tick.setAttribute("x1", x);
                tick.setAttribute("y1", height);
                tick.setAttribute("x2", x);
                tick.setAttribute("y2", height + 5);
                tick.setAttribute("stroke", "var(--text)");
                tick.setAttribute("stroke-width", "2");
                g.appendChild(tick);
            });
            
            svg.appendChild(g);
            challengeGraphDisplay.appendChild(svg);
        }

        // Draw bar graph in challenge modal
        function drawChallengeBarGraph(data) {
            const svg = createSVGElement("svg", {
                "class": "graph-svg",
                "viewBox": "0 0 400 250"
            });
            
            const margin = { top: 30, right: 30, bottom: 40, left: 50 };
            const width = 400 - margin.left - margin.right;
            const height = 250 - margin.top - margin.bottom;
            
            const g = createSVGElement("g", {
                "transform": `translate(${margin.left}, ${margin.top})`
            });
            
            const maxValue = Math.max(...data.map(item => item.value));
            
            // Draw grid lines (draw first so they appear behind everything)
            // Horizontal grid lines (for Y-axis values)
            const gridSteps = 5;
            const yStep = maxValue / gridSteps;
            for (let i = 0; i <= gridSteps; i++) {
                const value = i * yStep;
                const y = height - (value / maxValue) * height;
                
                const gridLine = document.createElementNS(SVG_NS, "line");
                gridLine.setAttribute("x1", "0");
                gridLine.setAttribute("y1", y);
                gridLine.setAttribute("x2", width);
                gridLine.setAttribute("y2", y);
                gridLine.setAttribute("stroke", "var(--text-light)");
                gridLine.setAttribute("stroke-width", "1");
                gridLine.setAttribute("stroke-opacity", "0.3");
                gridLine.setAttribute("stroke-dasharray", "2,2");
                g.appendChild(gridLine);
            }
            
            const barWidth = width / data.length * 0.7;
            const barSpacing = width / data.length * 0.3;
            
            const colors = GRAPH_COLORS;
            
            data.forEach((item, index) => {
                const barHeight = (item.value / maxValue) * height;
                const x = index * (barWidth + barSpacing);
                const y = height - barHeight;
                
                const rect = document.createElementNS(SVG_NS, "rect");
                rect.setAttribute("x", x);
                rect.setAttribute("y", y);
                rect.setAttribute("width", barWidth);
                rect.setAttribute("height", barHeight);
                rect.setAttribute("fill", colors[index % colors.length]);
                g.appendChild(rect);
                
                // Value label on top
                const valueText = document.createElementNS(SVG_NS, "text");
                valueText.setAttribute("x", x + barWidth / 2);
                valueText.setAttribute("y", y - 5);
                valueText.setAttribute("font-size", "10");
                valueText.setAttribute("text-anchor", "middle");
                valueText.setAttribute("fill", "var(--text)");
                valueText.textContent = item.value;
                g.appendChild(valueText);
                
                // X-axis label
                const labelText = document.createElementNS(SVG_NS, "text");
                labelText.setAttribute("x", x + barWidth / 2);
                labelText.setAttribute("y", height + 20);
                labelText.setAttribute("font-size", "10");
                labelText.setAttribute("text-anchor", "middle");
                labelText.setAttribute("fill", "var(--text)");
                labelText.textContent = item.label;
                g.appendChild(labelText);
                
                // X-axis tick mark
                const tick = document.createElementNS(SVG_NS, "line");
                tick.setAttribute("x1", x + barWidth / 2);
                tick.setAttribute("y1", height);
                tick.setAttribute("x2", x + barWidth / 2);
                tick.setAttribute("y2", height + 5);
                tick.setAttribute("stroke", "var(--text)");
                tick.setAttribute("stroke-width", "2");
                g.appendChild(tick);
            });
            
            // Y-axis with tick marks
            const yAxis = document.createElementNS(SVG_NS, "line");
            yAxis.setAttribute("x1", 0);
            yAxis.setAttribute("y1", 0);
            yAxis.setAttribute("x2", 0);
            yAxis.setAttribute("y2", height);
            yAxis.setAttribute("stroke", "var(--text)");
            yAxis.setAttribute("stroke-width", "2");
            g.appendChild(yAxis);
            
            // Y-axis tick marks and labels
            for (let i = 0; i <= gridSteps; i++) {
                const value = i * yStep;
                const y = height - (value / maxValue) * height;
                
                // Tick mark
                const tick = document.createElementNS(SVG_NS, "line");
                tick.setAttribute("x1", "-5");
                tick.setAttribute("y1", y);
                tick.setAttribute("x2", "0");
                tick.setAttribute("y2", y);
                tick.setAttribute("stroke", "var(--text)");
                tick.setAttribute("stroke-width", "2");
                g.appendChild(tick);
                
                // Label
                const text = document.createElementNS(SVG_NS, "text");
                text.setAttribute("x", -10);
                text.setAttribute("y", y + 3);
                text.setAttribute("text-anchor", "end");
                text.setAttribute("font-size", "9");
                text.setAttribute("fill", "var(--text)");
                text.setAttribute("font-weight", "500");
                const displayValue = value % 1 === 0 ? Math.round(value) : value.toFixed(1);
                text.textContent = displayValue;
                g.appendChild(text);
            }
            
            // X-axis with tick marks
            const xAxis = document.createElementNS(SVG_NS, "line");
            xAxis.setAttribute("x1", 0);
            xAxis.setAttribute("y1", height);
            xAxis.setAttribute("x2", width);
            xAxis.setAttribute("y2", height);
            xAxis.setAttribute("stroke", "var(--text)");
            xAxis.setAttribute("stroke-width", "2");
            g.appendChild(xAxis);
            
            // X-axis tick marks
            data.forEach((item, index) => {
                const x = index * (barWidth + barSpacing) + barWidth / 2;
                const tick = document.createElementNS(SVG_NS, "line");
                tick.setAttribute("x1", x);
                tick.setAttribute("y1", height);
                tick.setAttribute("x2", x);
                tick.setAttribute("y2", height + 5);
                tick.setAttribute("stroke", "var(--text)");
                tick.setAttribute("stroke-width", "2");
                g.appendChild(tick);
            });
            
            svg.appendChild(g);
            challengeGraphDisplay.appendChild(svg);
        }

        // Generate a question for a specific graph
        function generateChallengeQuestionForGraph(data, graphType, topic) {
            const total = data.reduce((sum, item) => sum + item.value, 0);
            const maxItem = data.reduce((max, item) => item.value > max.value ? item : max, data[0]);
            const minItem = data.reduce((min, item) => item.value < min.value ? item : min, data[0]);
            const sortedData = [...data].sort((a, b) => b.value - a.value);
            const secondLargest = data.length >= 2 ? sortedData[1] : null;
            const secondSmallest = data.length >= 2 ? sortedData[sortedData.length - 2] : null;
            
            // Clear previous questions
            appState.challenges.questions = [];
            
            // Generate question based on graph type with simple language for kids
            switch(graphType) {
                case 'pictograph':
                case 'bar':
                    const questionTypes = [];
                    
                    // Question 1: Which has the most? (simplest)
                    questionTypes.push({
                        question: `Which one has the most?`,
                        answers: data.map(item => item.label),
                        correctAnswer: maxItem.label
                    });
                    
                    // Question 2: Which has the least?
                    questionTypes.push({
                        question: `Which one has the least?`,
                        answers: data.map(item => item.label),
                        correctAnswer: minItem.label
                    });
                    
                    // Question 3: How many does [item] have?
                    const randomItem = data[Math.floor(Math.random() * data.length)];
                    const wrongAnswers = data
                        .filter(item => item.value !== randomItem.value)
                        .map(item => item.value)
                        .slice(0, 3);
                    questionTypes.push({
                        question: `How many does ${randomItem.label} have?`,
                        answers: [randomItem.value, ...wrongAnswers].sort(() => Math.random() - 0.5),
                        correctAnswer: randomItem.value
                    });
                    
                    // Question 4: Count all together
                    const wrongTotals = [
                        total + 3,
                        total - 3,
                        total + Math.floor(total * 0.2),
                        total - Math.floor(total * 0.2)
                    ].filter(v => v > 0).slice(0, 3);
                    questionTypes.push({
                        question: `If we count all of them together, how many do we get?`,
                        answers: [total, ...wrongTotals].sort(() => Math.random() - 0.5),
                        correctAnswer: total
                    });
                    
                    // Question 5: Which is bigger? (comparing two items)
                    if (data.length >= 2 && secondLargest) {
                        const item1 = maxItem;
                        const item2 = secondLargest;
                        questionTypes.push({
                            question: `Which is bigger: ${item1.label} or ${item2.label}?`,
                            answers: [item1.label, item2.label, "They are the same", "I don't know"].sort(() => Math.random() - 0.5),
                            correctAnswer: item1.label
                        });
                    }
                    
                    // Question 6: How many more does [max] have than [min]?
                    if (data.length >= 2) {
                        const difference = maxItem.value - minItem.value;
                        const wrongDiffs = [
                            difference + 2,
                            difference - 1,
                            maxItem.value,
                            minItem.value
                        ].filter(v => v > 0).slice(0, 3);
                        questionTypes.push({
                            question: `How many more does ${maxItem.label} have than ${minItem.label}?`,
                            answers: [difference, ...wrongDiffs].sort(() => Math.random() - 0.5),
                            correctAnswer: difference
                        });
                    }
                    
                    // Question 7: Find a specific number (only if unique)
                    const uniqueValueItems = data.filter((item, index, self) => 
                        self.filter(i => i.value === item.value).length === 1
                    );
                    if (uniqueValueItems.length > 0) {
                        const specificValue = uniqueValueItems[Math.floor(Math.random() * uniqueValueItems.length)];
                        const otherLabels = data
                            .filter(item => item.label !== specificValue.label)
                            .map(item => item.label)
                            .slice(0, 3);
                        questionTypes.push({
                            question: `Which one has exactly ${specificValue.value}?`,
                            answers: [specificValue.label, ...otherLabels].sort(() => Math.random() - 0.5),
                            correctAnswer: specificValue.label
                        });
                    }
                    
                    // Question 8: Which has exactly [number]? (ensures only one answer)
                    const itemsWithUniqueValues = data.filter((item, index, self) => 
                        self.findIndex(i => i.value === item.value) === index
                    );
                    if (itemsWithUniqueValues.length >= 2) {
                        const targetItem = itemsWithUniqueValues[Math.floor(Math.random() * itemsWithUniqueValues.length)];
                        const wrongItems = data
                            .filter(item => item.value !== targetItem.value)
                            .map(item => item.label)
                            .slice(0, 3);
                        questionTypes.push({
                            question: `Which one has exactly ${targetItem.value}?`,
                            answers: [targetItem.label, ...wrongItems].sort(() => Math.random() - 0.5),
                            correctAnswer: targetItem.label
                        });
                    }
                    
                    // Question 9: Which is the second biggest? (only if there's a clear second)
                    if (data.length >= 2 && secondLargest && secondLargest.value !== maxItem.value) {
                        const wrongItems = data
                            .filter(item => item.label !== secondLargest.label && item.label !== maxItem.label)
                            .map(item => item.label)
                            .slice(0, 2);
                        questionTypes.push({
                            question: `Which one is the second biggest?`,
                            answers: [secondLargest.label, maxItem.label, ...wrongItems].sort(() => Math.random() - 0.5),
                            correctAnswer: secondLargest.label
                        });
                    }
                    
                    // Question 10: Which is the second smallest? (only if there's a clear second)
                    if (data.length >= 2 && secondSmallest && secondSmallest.value !== minItem.value) {
                        const wrongItems = data
                            .filter(item => item.label !== secondSmallest.label && item.label !== minItem.label)
                            .map(item => item.label)
                            .slice(0, 2);
                        questionTypes.push({
                            question: `Which one is the second smallest?`,
                            answers: [secondSmallest.label, minItem.label, ...wrongItems].sort(() => Math.random() - 0.5),
                            correctAnswer: secondSmallest.label
                        });
                    }
                    
                    appState.challenges.questions = questionTypes;
                    break;
                    
                case 'pie':
                    const maxPercent = Math.round((maxItem.value / total) * 100);
                    const pieQuestions = [];
                    
                    // Question 1: Which slice is biggest?
                    pieQuestions.push({
                        question: `Which slice is the biggest?`,
                        answers: data.map(item => item.label),
                        correctAnswer: maxItem.label
                    });
                    
                    // Question 2: Which slice is smallest?
                    pieQuestions.push({
                        question: `Which slice is the smallest?`,
                        answers: data.map(item => item.label),
                        correctAnswer: minItem.label
                    });
                    
                    // Question 3: How many does [item] have?
                    const randomPieItem = data[Math.floor(Math.random() * data.length)];
                    const wrongPieAnswers = data
                        .filter(item => item.value !== randomPieItem.value)
                        .map(item => item.value)
                        .slice(0, 3);
                    pieQuestions.push({
                        question: `How many does ${randomPieItem.label} have?`,
                        answers: [randomPieItem.value, ...wrongPieAnswers].sort(() => Math.random() - 0.5),
                        correctAnswer: randomPieItem.value
                    });
                    
                    // Question 4: Count all together
                    const wrongPieTotals = [
                        total + 2,
                        total - 2,
                        total + 5
                    ].filter(v => v > 0).slice(0, 3);
                    pieQuestions.push({
                        question: `If we add all the pieces together, how many do we get?`,
                        answers: [total, ...wrongPieTotals].sort(() => Math.random() - 0.5),
                        correctAnswer: total
                    });
                    
                    // Question 5: Which is bigger? (comparing two slices)
                    if (data.length >= 2 && secondLargest) {
                        pieQuestions.push({
                            question: `Which slice is bigger: ${maxItem.label} or ${secondLargest.label}?`,
                            answers: [maxItem.label, secondLargest.label, "They are the same", "I don't know"].sort(() => Math.random() - 0.5),
                            correctAnswer: maxItem.label
                        });
                    }
                    
                    appState.challenges.questions = pieQuestions;
                    break;
                    
                case 'line':
                    const firstValue = data[0].value;
                    const lastValue = data[data.length - 1].value;
                    const change = lastValue - firstValue;
                    const lineQuestions = [];
                    
                    // Question 1: What number did we start with?
                    lineQuestions.push({
                        question: `What number did we start with?`,
                        answers: [firstValue, lastValue, maxItem.value, minItem.value].sort(() => Math.random() - 0.5),
                        correctAnswer: firstValue
                    });
                    
                    // Question 2: What number did we end with?
                    lineQuestions.push({
                        question: `What number did we end with?`,
                        answers: [lastValue, firstValue, maxItem.value, minItem.value].sort(() => Math.random() - 0.5),
                        correctAnswer: lastValue
                    });
                    
                    // Question 3: Did it go up or down?
                    lineQuestions.push({
                        question: `Did the line go up or down?`,
                        answers: [
                            change > 0 ? "Up" : "Down",
                            change > 0 ? "Down" : "Up",
                            "It stayed the same",
                            "I can't tell"
                        ].sort(() => Math.random() - 0.5),
                        correctAnswer: change > 0 ? "Up" : "Down"
                    });
                    
                    // Question 4: What's the highest number?
                    lineQuestions.push({
                        question: `What's the highest number on the graph?`,
                        answers: [maxItem.value, minItem.value, firstValue, lastValue].sort(() => Math.random() - 0.5),
                        correctAnswer: maxItem.value
                    });
                    
                    // Question 5: What's the lowest number?
                    lineQuestions.push({
                        question: `What's the lowest number on the graph?`,
                        answers: [minItem.value, maxItem.value, firstValue, lastValue].sort(() => Math.random() - 0.5),
                        correctAnswer: minItem.value
                    });
                    
                    // Question 6: How many does [first item] have?
                    const firstItem = data[0];
                    const wrongFirstAnswers = data
                        .filter(item => item.value !== firstItem.value)
                        .map(item => item.value)
                        .slice(0, 3);
                    lineQuestions.push({
                        question: `How many does ${firstItem.label} have?`,
                        answers: [firstItem.value, ...wrongFirstAnswers].sort(() => Math.random() - 0.5),
                        correctAnswer: firstItem.value
                    });
                    
                    // Question 7: How many does [last item] have?
                    const lastItem = data[data.length - 1];
                    const wrongLastAnswers = data
                        .filter(item => item.value !== lastItem.value)
                        .map(item => item.value)
                        .slice(0, 3);
                    lineQuestions.push({
                        question: `How many does ${lastItem.label} have?`,
                        answers: [lastItem.value, ...wrongLastAnswers].sort(() => Math.random() - 0.5),
                        correctAnswer: lastItem.value
                    });
                    
                    appState.challenges.questions = lineQuestions;
                    break;
            }
        }

        // Start the challenge timer
        function startChallengeTimer() {
            // Clear any existing timer
            if (appState.challenges.timer) {
                clearInterval(appState.challenges.timer);
            }
            
            // Update timer every second
            appState.challenges.timer = setInterval(() => {
                appState.challenges.timeRemaining--;
                updateTimerDisplay();
                
                if (appState.challenges.timeRemaining <= 0) {
                    endChallenge();
                }
            }, 1000);
        }

        // Update timer display
        function updateTimerDisplay() {
            const minutes = Math.floor(appState.challenges.timeRemaining / 60);
            const seconds = appState.challenges.timeRemaining % 60;
            timerDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            // Change color when time is running out
            if (appState.challenges.timeRemaining <= 30) {
                timerDisplay.style.color = 'var(--accent)';
            } else {
                timerDisplay.style.color = 'var(--primary)';
            }
        }

        // Update challenge stats display
        function updateChallengeStats() {
            challengeScore.textContent = appState.challenges.score;
            challengeAnswered.textContent = appState.challenges.totalAnswered;
        }

        // End challenge and show results
        function endChallenge() {
            // Clear timer
            if (appState.challenges.timer) {
                clearInterval(appState.challenges.timer);
                appState.challenges.timer = null;
            }
            
            // Re-enable input fields
            const inputPanel = document.querySelector('.input-panel');
            if (inputPanel) {
                inputPanel.style.opacity = '1';
                inputPanel.style.pointerEvents = 'auto';
            }
            
            const allInputs = document.querySelectorAll('.input-panel input, .input-panel select, .input-panel button');
            allInputs.forEach(input => {
                input.disabled = false;
                input.style.cursor = '';
            });
            
            // Hide question/answers/graph, show results
            document.getElementById('challengeQuestion').style.display = 'none';
            document.getElementById('challengeAnswers').style.display = 'none';
            document.getElementById('challengeFeedback').style.display = 'none';
            if (challengeGraphDisplay) {
                challengeGraphDisplay.style.display = 'none';
            }
            challengeTimer.style.display = 'none';
            challengeStats.style.display = 'none';
            
            // Show results
            resultsCorrect.textContent = appState.challenges.correctAnswers;
            resultsTotal.textContent = appState.challenges.totalAnswered;
            resultsScore.textContent = appState.challenges.score;
            challengeResults.style.display = 'block';
            
            // Reset challenge mode
            appState.challenges.timedMode = false;
            appState.challenges.active = false;
            
            // Note: Keep overlay visible to show results, user will close it with button
        }

        // Toggle challenge panel (for non-timed mode - keeping for backward compatibility)
        function toggleChallengePanel() {
            // If already in timed mode, don't allow toggling
            if (appState.challenges.timedMode) {
                return;
            }
            
            if (appState.graphData.length < 2) {
                alert("Add at least 2 data points to activate challenges!");
                return;
            }
            
            appState.challenges.active = !appState.challenges.active;
            
            if (appState.challenges.active) {
                challengeOverlay.style.display = 'flex';
                challengeTimer.style.display = 'none';
                challengeStats.style.display = 'none';
                challengeResults.style.display = 'none';
                showNextChallenge();
            } else {
                challengeOverlay.style.display = 'none';
            }
        }

        // Show next challenge question
        function showNextChallenge() {
            const questions = appState.challenges.questions;
            if (questions.length === 0) {
                // If no questions, generate new graph (for timed mode)
                if (appState.challenges.timedMode) {
                    generateRandomChallengeGraph();
                }
                return;
            }
            
            // Pick a random question
            const randomIndex = Math.floor(Math.random() * questions.length);
            appState.challenges.currentQuestion = questions[randomIndex];
            
            const questionElement = document.getElementById('challengeQuestion');
            const answersElement = document.getElementById('challengeAnswers');
            const feedbackElement = document.getElementById('challengeFeedback');
            
            // Show question/answers/graph in timed mode
            if (appState.challenges.timedMode) {
                questionElement.style.display = 'block';
                answersElement.style.display = 'flex';
                if (challengeGraphDisplay) {
                    challengeGraphDisplay.style.display = 'flex';
                }
            }
            
            questionElement.textContent = appState.challenges.currentQuestion.question;
            answersElement.innerHTML = '';
            feedbackElement.style.display = 'none';
            
            // Shuffle answers
            const shuffledAnswers = [...appState.challenges.currentQuestion.answers];
            for (let i = shuffledAnswers.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffledAnswers[i], shuffledAnswers[j]] = [shuffledAnswers[j], shuffledAnswers[i]];
            }
            
            // Create answer buttons
            shuffledAnswers.forEach(answer => {
                const answerDiv = document.createElement('div');
                answerDiv.className = 'challenge-answer';
                answerDiv.textContent = answer;
                answerDiv.style.pointerEvents = 'auto'; // Re-enable clicking
                answerDiv.addEventListener('click', function() {
                    checkChallengeAnswer(answer);
                });
                answersElement.appendChild(answerDiv);
            });
        }

        // Check challenge answer
        function checkChallengeAnswer(selectedAnswer) {
            const correctAnswer = appState.challenges.currentQuestion.correctAnswer;
            const feedbackElement = document.getElementById('challengeFeedback');
            
            // Track answer
            appState.challenges.totalAnswered++;
            
            if (selectedAnswer == correctAnswer) {
                feedbackElement.textContent = "üéâ Correct! Great job!";
                feedbackElement.className = "challenge-feedback feedback-correct";
                
                // Update score in timed mode
                if (appState.challenges.timedMode) {
                    appState.challenges.correctAnswers++;
                    appState.challenges.score++;
                    updateChallengeStats();
                }
            } else {
                feedbackElement.textContent = `Incorrect. The correct answer is: ${correctAnswer}`;
                feedbackElement.className = "challenge-feedback feedback-incorrect";
            }
            
            feedbackElement.style.display = 'block';
            
            // In timed mode, immediately show next challenge (no delay)
            if (appState.challenges.timedMode) {
                // Disable answer buttons to prevent double-clicking
                const answerButtons = document.querySelectorAll('.challenge-answer');
                answerButtons.forEach(btn => {
                    btn.style.pointerEvents = 'none';
                });
                
                // Generate new random graph and question after short delay
                setTimeout(() => {
                    if (appState.challenges.timedMode && appState.challenges.timeRemaining > 0) {
                        generateRandomChallengeGraph();
                    }
                }, 1000);
            } else {
                // Show next question after delay (non-timed mode)
                setTimeout(showNextChallenge, 2500);
            }
        }

        // ============================================================================
        // ICON MANAGEMENT UTILITIES
        // ============================================================================
        
        function getSmartIcon(label) {
            if (!label) return null;
            const lowerLabel = label.toLowerCase();
            
            // Try exact match first
            if (iconMap[lowerLabel]) return iconMap[lowerLabel];
            
            // Try keyword match - prioritize longer/more specific matches first
            // Sort keywords by length (longest first) to match "hotdog" before "dog"
            const sortedKeywords = Object.entries(iconMap).sort((a, b) => b[0].length - a[0].length);
            for (const [keyword, emoji] of sortedKeywords) {
                if (lowerLabel.includes(keyword)) {
                    // Extra safeguard: For "dog" or "puppy", ensure it's not part of another word
                    if (keyword === "dog" || keyword === "puppy" || keyword === "dogs" || keyword === "puppies") {
                        // Check if it's a standalone word (not part of "hotdog", "doghouse", etc.)
                        const keywordIndex = lowerLabel.indexOf(keyword);
                        const beforeChar = keywordIndex > 0 ? lowerLabel[keywordIndex - 1] : ' ';
                        const afterChar = keywordIndex + keyword.length < lowerLabel.length ? lowerLabel[keywordIndex + keyword.length] : ' ';
                        // Only match if surrounded by non-letter characters (word boundary)
                        if (/[a-z]/.test(beforeChar) || /[a-z]/.test(afterChar)) {
                            // It's part of another word, skip this match
                            continue;
                        }
                    }
                    return emoji;
                }
            }
            
            return null;
        }

        // Get all currently used icons from existing rows (excluding the current row being edited)
        function getUsedIcons(excludeRowId = null) {
            const usedIcons = new Set();
            const rows = dataRows.querySelectorAll('.data-row');
            
            rows.forEach(row => {
                // Skip the row we're currently editing
                if (excludeRowId && row.id === excludeRowId) return;
                
                const iconSelect = row.querySelector('.data-icon');
                if (iconSelect && iconSelect.value) {
                    usedIcons.add(iconSelect.value);
                }
            });
            
            return usedIcons;
        }

        // Get available icons filtered by label type (excludes dog icon for non-dog labels)
        function getAvailableIcons(isDogRelated, usedIcons = new Set()) {
            return pictographIcons.filter(icon => {
                // Always exclude used icons
                if (usedIcons.has(icon)) return false;
                // Exclude dog icon if label is not dog-related
                if (icon === "üê∂" && !isDogRelated) return false;
                return true;
            });
        }

        // Get a unique icon for a label, ensuring it doesn't conflict with existing icons
        function getUniqueIcon(label, excludeRowId = null, preferredIcon = null) {
            const usedIcons = getUsedIcons(excludeRowId);
            
            // Check if label is dog-related FIRST (before validating preferred icon)
            const lowerLabel = (label || "").toLowerCase();
            const isDogRelated = lowerLabel.includes("dog") || lowerLabel.includes("puppy");
            
            // Validate preferred icon: reject dog icon if label is not dog-related
            if (preferredIcon) {
                if (preferredIcon === "üê∂" && !isDogRelated) {
                    // Preferred icon is dog but label is not dog-related - reject it
                    preferredIcon = null; // Treat as if no preferred icon
                } else if (!usedIcons.has(preferredIcon)) {
                    // Also check if preferred icon is in available icons for this label type
                    const availableIcons = getAvailableIcons(isDogRelated, usedIcons);
                    if (availableIcons.includes(preferredIcon)) {
                        return preferredIcon;
                    }
                }
            }
            
            // Try to get smart icon match
            const smartIcon = getSmartIcon(label);
            if (smartIcon) {
                // Validate smart icon is appropriate for label type
                if (smartIcon === "üê∂" && !isDogRelated) {
                    // Smart icon returned dog but label is not dog-related - reject it
                    // This should never happen with proper getSmartIcon, but safety check
                } else if (!usedIcons.has(smartIcon)) {
                    return smartIcon;
                }
            }
            
            // Get filtered available icons (excludes dog for non-dog labels)
            const availableIcons = getAvailableIcons(isDogRelated, usedIcons);
            
            // Return first available icon
            if (availableIcons.length > 0) {
                return availableIcons[0];
            }
            
            // If all icons are used (unlikely), return safe fallback
            // Never return dog icon for non-dog labels
            return smartIcon && smartIcon !== "üê∂" ? smartIcon : "üìä";
        }

        // Load example data
        // ============================================================================
        // DATA LOADING & EXAMPLES
        // ============================================================================
        
        function loadExample(graphType, customData = null) {
            const example = customData || examples[graphType];
            
            if (!example) return;
            
            // Clear existing rows
            dataRows.innerHTML = '';
            
            // Set form values
            graphTitleInput.value = example.title;
            xLabelInput.value = example.xLabel;
            yLabelInput.value = example.yLabel;
            
            // Add data rows - collect icons as we go to ensure uniqueness
            const usedIconsInBatch = new Set();
            
            example.data.forEach((item, index) => {
                const rowId = `row-${index + 1}`;
                const row = document.createElement('div');
                row.className = 'data-row';
                row.id = rowId;
                
                if (graphType === 'pictograph') {
                    // Get unique icon - prefer explicit icon, then smart icon, then fallback
                    let icon;
                    
                    // Check if label is dog-related FIRST
                    const lowerLabel = (item.label || "").toLowerCase();
                    const isDogRelated = lowerLabel.includes("dog") || lowerLabel.includes("puppy");
                    
                    // Validate explicit icon: reject dog icon if label is not dog-related
                    if (item.icon) {
                        if (item.icon === "üê∂" && !isDogRelated) {
                            // Explicit icon is dog but label is not dog-related - reject it
                            item.icon = null; // Treat as if no icon provided
                        } else if (!usedIconsInBatch.has(item.icon)) {
                            icon = item.icon;
                        }
                    }
                    
                    // If no valid icon yet, find one using helper function
                    if (!icon) {
                        // Try smart icon first (but validate it's appropriate)
                        const smartIcon = getSmartIcon(item.label);
                        if (smartIcon) {
                            // Validate smart icon is appropriate for label type
                            if (smartIcon === "üê∂" && !isDogRelated) {
                                // Smart icon returned dog but label is not dog-related - reject it
                                // This should never happen, but safety check
                            } else if (!usedIconsInBatch.has(smartIcon)) {
                                icon = smartIcon;
                            }
                        }
                        
                        // If still no icon, get from available icons (already filtered)
                        if (!icon) {
                            const availableIcons = getAvailableIcons(isDogRelated, usedIconsInBatch);
                            if (availableIcons.length > 0) {
                                icon = availableIcons[0];
                            } else {
                                // All icons used - use safe fallback
                                icon = "üìä";
                            }
                        }
                    }
                    
                    // FINAL SAFETY CHECK: Ensure icon is never dog for non-dog labels
                    if (icon === "üê∂" && !isDogRelated) {
                        // Emergency fallback - get first available non-dog icon
                        const availableIcons = getAvailableIcons(false, usedIconsInBatch);
                        icon = availableIcons.length > 0 ? availableIcons[0] : "üìä";
                    }
                    
                    usedIconsInBatch.add(icon);
                    
                    row.innerHTML = `
                        <input type="text" class="data-label" placeholder="Label" value="${item.label}">
                        <input type="number" class="data-value" placeholder="Value" min="0" value="${item.value}">
                        <select class="data-icon">
                            ${pictographIcons.map((iconOption, i) => 
                                `<option value="${iconOption}" ${iconOption === icon ? 'selected' : ''}>${iconOption}</option>`
                            ).join('')}
                        </select>
                        <div class="row-controls">
                            <button class="row-btn remove-row-btn" onclick="removeDataRow('${rowId}')">‚àí</button>
                        </div>
                    `;
                } else {
                    row.innerHTML = `
                        <input type="text" class="data-label" placeholder="Label" value="${item.label}">
                        <input type="number" class="data-value" placeholder="Value" min="0" value="${item.value}">
                        <div class="row-controls">
                            <button class="row-btn remove-row-btn" onclick="removeDataRow('${rowId}')">‚àí</button>
                        </div>
                    `;
                }
                
                dataRows.appendChild(row);
                
                // Add event listeners
                const labelInput = row.querySelector('.data-label');
                const valueInput = row.querySelector('.data-value');
                const iconSelect = row.querySelector('.data-icon');
                
                labelInput.addEventListener('input', () => {
                    // Auto-update icon if it's a pictograph, ensuring uniqueness
                    if (appState.currentGraphType === 'pictograph' && iconSelect) {
                        const uniqueIcon = getUniqueIcon(labelInput.value, rowId, iconSelect.value);
                        if (uniqueIcon && uniqueIcon !== iconSelect.value) {
                            iconSelect.value = uniqueIcon;
                        }
                    }
                    updateGraph();
                });
                valueInput.addEventListener('input', updateGraph);
                if (iconSelect) {
                    iconSelect.addEventListener('change', () => {
                        // Check if this icon is already used by another row OR if dog icon is selected for non-dog label
                        const selectedIcon = iconSelect.value;
                        const usedIcons = getUsedIcons(rowId);
                        const currentLabel = (labelInput.value || "").toLowerCase();
                        const isDogRelated = currentLabel.includes("dog") || currentLabel.includes("puppy");
                        
                        // Prevent dog icon for non-dog labels
                        if (selectedIcon === "üê∂" && !isDogRelated) {
                            // Dog icon selected but label is not dog-related - find a unique alternative
                            const uniqueIcon = getUniqueIcon(labelInput.value, rowId);
                            if (uniqueIcon) {
                                iconSelect.value = uniqueIcon;
                            }
                            updateGraph();
                            return;
                        }
                        
                        if (usedIcons.has(selectedIcon)) {
                            // Icon is already used, find a unique one
                            const uniqueIcon = getUniqueIcon(labelInput.value, rowId);
                            if (uniqueIcon) {
                                iconSelect.value = uniqueIcon;
                            }
                        }
                        updateGraph();
                    });
                }
            });
            
            updateGraph();
        }

        // Load random example
        function loadRandomExample() {
            if (!appState.currentGraphType) return;
            
            // Pick a random topic
            const topic = randomTopics[Math.floor(Math.random() * randomTopics.length)];
            
            // Randomize how many items (between 3 and 6)
            const numItems = Math.floor(Math.random() * 4) + 3;
            
            // Shuffle labels/icons and pick numItems
            const shuffledIndices = [...Array(topic.labels.length).keys()].sort(() => Math.random() - 0.5);
            const selectedIndices = shuffledIndices.slice(0, numItems);
            
            const randomData = selectedIndices.map(idx => ({
                label: topic.labels[idx],
                value: getRandomSingleDigit(),
                icon: topic.icons[idx]
            }));
            
            const randomExample = {
                title: topic.title,
                xLabel: topic.xLabel,
                yLabel: topic.yLabel,
                data: randomData
            };
            
            loadExample(appState.currentGraphType, randomExample);
        }

        // Reset graph
        // ============================================================================
        // GRAPH PERSISTENCE (SAVE/LOAD)
        // ============================================================================
        
        function resetGraph() {
            if (confirm("Are you sure you want to reset? You'll lose your current data.")) {
                // Clear all rows
                dataRows.innerHTML = '';
                
                // Reset form values
                graphTitleInput.value = "My Awesome Graph";
                xLabelInput.value = "Categories";
                yLabelInput.value = "Values";
                
                // Add three default rows
                addDataRow();
                addDataRow();
                addDataRow();
                
                updateGraph();
            }
        }

        // Save current graph
        function saveCurrentGraph() {
            if (appState.graphData.length === 0) {
                alert("Add some data to your graph before saving!");
                return;
            }
            
            const graphName = prompt("Give your graph a name:", graphTitleInput.value || "My Graph");
            if (!graphName) return;
            
            const graphToSave = {
                id: Date.now(),
                name: graphName,
                type: appState.currentGraphType,
                title: graphTitleInput.value,
                xLabel: xLabelInput.value,
                yLabel: yLabelInput.value,
                data: appState.graphData,
                date: new Date().toISOString()
            };
            
            // Add to saved graphs
            appState.savedGraphs.push(graphToSave);
            
            // Save to localStorage
            localStorage.setItem('graphExplorerSavedGraphs', JSON.stringify(appState.savedGraphs));
            
            // Update UI
            updateSavedGraphsList();
            
            alert(`Graph "${graphName}" saved successfully!`);
        }

        // Load saved graphs from localStorage
        function loadSavedGraphs() {
            const saved = localStorage.getItem('graphExplorerSavedGraphs');
            if (saved) {
                try {
                    appState.savedGraphs = JSON.parse(saved);
                } catch (e) {
                    console.error("Error loading saved graphs:", e);
                    appState.savedGraphs = [];
                }
            }
        }

        // Update saved graphs list
        function updateSavedGraphsList() {
            savedGraphsList.innerHTML = '';
            
            if (appState.savedGraphs.length === 0) {
                savedGraphsList.innerHTML = '<div style="text-align: center; color: var(--text-light); padding: 20px;">No saved graphs yet. Create one to see it here!</div>';
                return;
            }
            
            // Sort by most recent
            const sortedGraphs = [...appState.savedGraphs].sort((a, b) => b.id - a.id);
            
            sortedGraphs.forEach(graph => {
                const graphItem = document.createElement('div');
                graphItem.className = 'saved-graph-item';
                graphItem.innerHTML = `
                    <div>
                        <div class="saved-graph-name">${graph.name}</div>
                        <div class="saved-graph-type">${graph.type.charAt(0).toUpperCase() + graph.type.slice(1)} ‚Ä¢ ${new Date(graph.date).toLocaleDateString()}</div>
                    </div>
                    <button class="btn btn-sm btn-outline" onclick="loadSavedGraph(${graph.id})">Load</button>
                `;
                savedGraphsList.appendChild(graphItem);
            });
        }

        // Load a saved graph
        function loadSavedGraph(graphId) {
            const graph = appState.savedGraphs.find(g => g.id === graphId);
            if (!graph) return;
            
            // Navigate to the graph type
            selectGraph(graph.type);
            
            // Set form values
            graphTitleInput.value = graph.title;
            xLabelInput.value = graph.xLabel;
            yLabelInput.value = graph.yLabel;
            
            // Clear existing rows
            dataRows.innerHTML = '';
            
            // Add data rows - collect icons as we go to ensure uniqueness
            const usedIconsInBatch = new Set();
            
            graph.data.forEach((item, index) => {
                const rowId = `row-${index + 1}`;
                const row = document.createElement('div');
                row.className = 'data-row';
                row.id = rowId;
                
                if (graph.type === 'pictograph') {
                    // Get unique icon - prefer saved icon, then smart icon, then fallback
                    let icon;
                    
                    // Check if label is dog-related FIRST
                    const lowerLabel = (item.label || "").toLowerCase();
                    const isDogRelated = lowerLabel.includes("dog") || lowerLabel.includes("puppy");
                    
                    // Validate explicit icon: reject dog icon if label is not dog-related
                    if (item.icon) {
                        if (item.icon === "üê∂" && !isDogRelated) {
                            // Explicit icon is dog but label is not dog-related - reject it
                            item.icon = null; // Treat as if no icon provided
                        } else if (!usedIconsInBatch.has(item.icon)) {
                            icon = item.icon;
                        }
                    }
                    
                    // If no valid icon yet, find one using helper function
                    if (!icon) {
                        // Try smart icon first (but validate it's appropriate)
                        const smartIcon = getSmartIcon(item.label);
                        if (smartIcon) {
                            // Validate smart icon is appropriate for label type
                            if (smartIcon === "üê∂" && !isDogRelated) {
                                // Smart icon returned dog but label is not dog-related - reject it
                                // This should never happen, but safety check
                            } else if (!usedIconsInBatch.has(smartIcon)) {
                                icon = smartIcon;
                            }
                        }
                        
                        // If still no icon, get from available icons (already filtered)
                        if (!icon) {
                            const availableIcons = getAvailableIcons(isDogRelated, usedIconsInBatch);
                            if (availableIcons.length > 0) {
                                icon = availableIcons[0];
                            } else {
                                // All icons used - use safe fallback
                                icon = "üìä";
                            }
                        }
                    }
                    
                    // FINAL SAFETY CHECK: Ensure icon is never dog for non-dog labels
                    if (icon === "üê∂" && !isDogRelated) {
                        // Emergency fallback - get first available non-dog icon
                        const availableIcons = getAvailableIcons(false, usedIconsInBatch);
                        icon = availableIcons.length > 0 ? availableIcons[0] : "üìä";
                    }
                    
                    usedIconsInBatch.add(icon);
                    
                    row.innerHTML = `
                        <input type="text" class="data-label" placeholder="Label" value="${item.label}">
                        <input type="number" class="data-value" placeholder="Value" min="0" value="${item.value}">
                        <select class="data-icon">
                            ${pictographIcons.map((iconOption, i) => 
                                `<option value="${iconOption}" ${iconOption === icon ? 'selected' : ''}>${iconOption}</option>`
                            ).join('')}
                        </select>
                        <div class="row-controls">
                            <button class="row-btn remove-row-btn" onclick="removeDataRow('${rowId}')">‚àí</button>
                        </div>
                    `;
                } else {
                    row.innerHTML = `
                        <input type="text" class="data-label" placeholder="Label" value="${item.label}">
                        <input type="number" class="data-value" placeholder="Value" min="0" value="${item.value}">
                        <div class="row-controls">
                            <button class="row-btn remove-row-btn" onclick="removeDataRow('${rowId}')">‚àí</button>
                        </div>
                    `;
                }
                
                dataRows.appendChild(row);
                
                // Add event listeners
                const labelInput = row.querySelector('.data-label');
                const valueInput = row.querySelector('.data-value');
                const iconSelect = row.querySelector('.data-icon');
                
                labelInput.addEventListener('input', () => {
                    // Auto-update icon if it's a pictograph, ensuring uniqueness
                    if (appState.currentGraphType === 'pictograph' && iconSelect) {
                        const uniqueIcon = getUniqueIcon(labelInput.value, rowId, iconSelect.value);
                        if (uniqueIcon && uniqueIcon !== iconSelect.value) {
                            iconSelect.value = uniqueIcon;
                        }
                    }
                    updateGraph();
                });
                valueInput.addEventListener('input', updateGraph);
                if (iconSelect) {
                    iconSelect.addEventListener('change', () => {
                        // Check if this icon is already used by another row OR if dog icon is selected for non-dog label
                        const selectedIcon = iconSelect.value;
                        const usedIcons = getUsedIcons(rowId);
                        const currentLabel = (labelInput.value || "").toLowerCase();
                        const isDogRelated = currentLabel.includes("dog") || currentLabel.includes("puppy");
                        
                        // Prevent dog icon for non-dog labels
                        if (selectedIcon === "üê∂" && !isDogRelated) {
                            // Dog icon selected but label is not dog-related - find a unique alternative
                            const uniqueIcon = getUniqueIcon(labelInput.value, rowId);
                            if (uniqueIcon) {
                                iconSelect.value = uniqueIcon;
                            }
                            updateGraph();
                            return;
                        }
                        
                        if (usedIcons.has(selectedIcon)) {
                            // Icon is already used, find a unique one
                            const uniqueIcon = getUniqueIcon(labelInput.value, rowId);
                            if (uniqueIcon) {
                                iconSelect.value = uniqueIcon;
                            }
                        }
                        updateGraph();
                    });
                }
            });
            
            updateGraph();
        }

        // Toggle theme
        // ============================================================================
        // UI UTILITIES (THEME, TUTORIAL, FULLSCREEN)
        // ============================================================================
        
        function toggleTheme() {
            const newTheme = appState.theme === 'light' ? 'dark' : 'light';
            setTheme(newTheme);
        }

        // Set theme
        function setTheme(theme) {
            appState.theme = theme;
            
            if (theme === 'dark') {
                document.body.classList.add('dark-theme');
                themeToggleBtn.innerHTML = '<span class="btn-icon">‚òÄÔ∏è</span> Light Mode';
            } else {
                document.body.classList.remove('dark-theme');
                themeToggleBtn.innerHTML = '<span class="btn-icon">üåô</span> Dark Mode';
            }
            
            // Save preference
            localStorage.setItem('graphExplorerTheme', theme);
        }

        // Show tutorial
        function showTutorial() {
            appState.tutorialStep = 0;
            updateTutorialStep();
            tutorialOverlay.style.display = 'flex';
        }

        // Hide tutorial
        function hideTutorial() {
            tutorialOverlay.style.display = 'none';
        }

        // Previous tutorial step
        function prevTutorialStep() {
            if (appState.tutorialStep > 0) {
                appState.tutorialStep--;
                updateTutorialStep();
            }
        }

        // Next tutorial step
        function nextTutorialStep() {
            if (appState.tutorialStep < tutorialSteps.length - 1) {
                appState.tutorialStep++;
                updateTutorialStep();
            } else {
                hideTutorial();
            }
        }

        // Update tutorial step
        function updateTutorialStep() {
            const step = tutorialSteps[appState.tutorialStep];
            tutorialStepTitle.textContent = step.title;
            tutorialStepContent.innerHTML = `
                <div class="tutorial-step">Step ${appState.tutorialStep + 1} of ${tutorialSteps.length}</div>
                <p>${step.content}</p>
            `;
            
            // Update button visibility
            prevTutorialBtn.style.display = appState.tutorialStep === 0 ? 'none' : 'inline-block';
            nextTutorialBtn.textContent = appState.tutorialStep === tutorialSteps.length - 1 ? 'Finish' : 'Next';
            
            // Update dots
            const dots = tutorialDots.querySelectorAll('.tutorial-dot');
            dots.forEach((dot, index) => {
                dot.classList.toggle('active', index === appState.tutorialStep);
            });
        }

        // Generate tutorial dots
        function generateTutorialDots() {
            tutorialDots.innerHTML = '';
            for (let i = 0; i < tutorialSteps.length; i++) {
                const dot = document.createElement('div');
                dot.className = `tutorial-dot ${i === 0 ? 'active' : ''}`;
                dot.addEventListener('click', () => {
                    appState.tutorialStep = i;
                    updateTutorialStep();
                });
                tutorialDots.appendChild(dot);
            }
        }

        // Toggle fullscreen
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.error(`Error attempting to enable fullscreen: ${err.message}`);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        // Update fullscreen button text
        function updateFullscreenButton() {
            if (document.fullscreenElement) {
                fullscreenBtn.innerHTML = '<span class="btn-icon">‚õ∂</span> Exit Fullscreen';
            } else {
                fullscreenBtn.innerHTML = '<span class="btn-icon">‚õ∂</span> Fullscreen';
            }
        }

        // ============================================================================
        // APPLICATION INITIALIZATION
        // ============================================================================
        
        // Initialize the app when DOM is loaded
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>