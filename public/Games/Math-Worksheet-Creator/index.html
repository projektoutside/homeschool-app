<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <title>Math Worksheet Creator</title>
  <link rel="icon"
    href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>➗</text></svg>">
  <style>
    /* ============== PRINT & PAGE SETTINGS ============== */
    @media print {
      @page {
        size: 8.5in 11in;
        margin: 0.2in;
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
      }

      * {
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
      }

      /* Hide ALL placeholder text in print - universal rule */
      input::placeholder,
      input::-webkit-input-placeholder,
      input::-moz-placeholder,
      input:-ms-input-placeholder,
      input::-ms-input-placeholder {
        color: transparent !important;
        opacity: 0 !important;
        visibility: hidden !important;
      }

      /* Note: input[placeholder]:before removed - pseudo-elements don't work on input elements */

      #main-menu,
      #setup-screen,
      .button-container,
      .back-btn,
      .generate-btn,
      .check-btn,
      .step-navigation,
      .example-box,
      .worksheet-number {
        display: none !important;
      }

      html,
      body {
        margin: 0 !important;
        padding: 0 !important;
        width: 8.5in !important;
        height: 11in !important;
        overflow: hidden !important;
        background: white !important;
        color: black !important;
      }

      #worksheet-screen {
        display: flex !important;
        flex-direction: column !important;
        align-items: center !important;
        width: 8.1in !important;
        max-width: 8.1in !important;
        height: 10.6in !important;
        max-height: 10.6in !important;
        margin: 0 auto !important;
        padding: 0 !important;
        box-sizing: border-box !important;
        page-break-after: avoid !important;
        page-break-inside: avoid !important;
        page-break-before: avoid !important;
        overflow: hidden !important;
        position: relative !important;
        background: white !important;
      }

      .header {
        width: 100% !important;
        max-width: 100% !important;
        margin: 0 0 0.1in 0 !important;
        padding: 0 !important;
        flex-shrink: 0 !important;
        box-sizing: border-box !important;
        page-break-after: avoid !important;
        page-break-inside: avoid !important;
        background: white !important;
      }

      .header h1 {
        font-size: 20px !important;
        margin: 0 0 0.06in 0 !important;
        line-height: 1.1 !important;
        padding: 0 !important;
        page-break-after: avoid !important;
      }

      .header p {
        font-size: 12px !important;
        margin: 0.03in 0 0 0 !important;
        gap: 0.2in !important;
        line-height: 1.15 !important;
        padding: 0 !important;
        page-break-after: avoid !important;
      }

      .header label {
        font-size: 12px !important;
        margin: 0 !important;
      }

      .header input {
        font-size: 12px !important;
        width: 1.8in !important;
        padding: 1px 0 !important;
        margin: 0 !important;
        border-bottom-width: 1.5px !important;
      }

      .header input::placeholder {
        color: transparent !important;
        opacity: 0 !important;
        visibility: hidden !important;
      }

      .problems-grid {
        display: grid !important;
        grid-template-columns: repeat(var(--print-cols, 6), var(--print-problem-width, 1.2in)) !important;
        gap: var(--print-gap, 0.1in) !important;
        width: 100% !important;
        max-width: 100% !important;
        margin: 0 !important;
        padding: 0 !important;
        page-break-inside: avoid !important;
        page-break-after: avoid !important;
        height: var(--print-grid-height, auto) !important;
        max-height: var(--print-grid-height, auto) !important;
        align-content: start !important;
        justify-content: center !important;
        box-sizing: border-box !important;
        flex: 1 1 auto !important;
        overflow: hidden !important;
        background: white !important;
      }

      .problem {
        box-shadow: none !important;
        border: 1px solid #d0d0d0 !important;
        border-radius: 6px !important;
        padding: 0.06in !important;
        min-height: 0 !important;
        height: var(--print-problem-height, auto) !important;
        max-height: var(--print-problem-height, auto) !important;
        width: 100% !important;
        max-width: 100% !important;
        display: flex !important;
        flex-direction: column !important;
        justify-content: space-between !important;
        box-sizing: border-box !important;
        overflow: hidden !important;
        page-break-inside: avoid !important;
        background: white !important;
        position: relative !important;
      }

      .math-expression {
        font-size: 20px !important;
        line-height: 1.1 !important;
        margin-bottom: 0.05in !important;
        padding: 0 !important;
        overflow: hidden !important;
        width: 100% !important;
        max-width: 100% !important;
        box-sizing: border-box !important;
      }

      .operator-line {
        border-bottom-width: 2px !important;
        margin-top: 0.02in !important;
      }

      .problem input[type="number"] {
        width: 100% !important;
        max-width: 0.9in !important;
        height: 0.4in !important;
        font-size: 12px !important;
        padding: 0.02in 0.04in !important;
        margin-top: auto !important;
        box-sizing: border-box !important;
        border: 2px solid #fdc9ec !important;
        border-radius: 4px !important;
      }

      .problem input[type="number"]::placeholder {
        color: transparent !important;
        opacity: 0 !important;
        visibility: hidden !important;
      }

      .problem::before {
        content: attr(data-number) !important;
        position: absolute !important;
        top: -0.03in !important;
        left: -0.03in !important;
        color: #666666 !important;
        font-size: 9px !important;
        font-weight: 600 !important;
        z-index: 2 !important;
        pointer-events: none !important;
        background-color: #f0f0f0 !important;
        padding: 2px 6px !important;
        border-radius: 4px !important;
        line-height: 1 !important;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1) !important;
      }

      /* Prevent any page breaks */
      .header,
      .problems-grid,
      .problem {
        page-break-before: avoid !important;
        page-break-after: avoid !important;
        page-break-inside: avoid !important;
        orphans: 999 !important;
        widows: 999 !important;
      }

      #worksheet-screen>* {
        page-break-inside: avoid !important;
      }
    }

    /* ============== BASE LAYOUT & FONTS ============== */
    * {
      box-sizing: border-box;
    }

    html {
      width: 100%;
      overflow-x: hidden;
      -webkit-text-size-adjust: 100%;
      -ms-text-size-adjust: 100%;
      text-size-adjust: 100%;
    }

    body {
      font-family: 'Comic Sans MS', cursive, sans-serif;
      color: #3498db;
      padding: 10px;
      background-color: #f0f8ff;
      margin: 0 auto;
      box-sizing: border-box;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 100vw;
      overflow-x: hidden;
      -webkit-tap-highlight-color: transparent;
      position: relative;
    }

    body.worksheet-mode {
      background-color: white !important;
    }

    /* ============== WORKSHEET SCREEN STYLES ============== */
    #worksheet-screen {
      display: none;
      width: 100%;
      max-width: 8.5in;
      flex-direction: column;
      align-items: center;
      box-sizing: border-box;
      padding: 20px;
      background: white;
      margin: 0 auto;
      min-height: 100vh;
    }

    #worksheet-screen .header {
      text-align: center;
      margin-bottom: 25px;
      width: 100%;
      background: white;
    }

    #worksheet-screen .header h1 {
      font-size: clamp(24px, 5vw, 32px);
      margin: 0 0 15px 0;
      color: #2ecc71;
    }

    #worksheet-screen .header p {
      font-size: clamp(14px, 4vw, 18px);
      margin: 8px 0;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
      align-items: center;
    }

    #worksheet-screen .header label {
      font-weight: bold;
      color: #3498db;
    }

    #worksheet-screen .header input {
      font-family: inherit;
      font-size: 18px;
      border: none;
      border-bottom: 2px solid #3498db;
      outline: none;
      width: clamp(140px, 40vw, 250px);
      padding: 5px;
      background: transparent;
    }

    #worksheet-screen .problems-grid {
      display: grid;
      gap: 20px;
      margin: 25px auto;
      width: 100%;
      justify-content: center;
      box-sizing: border-box;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      background: white;
    }

    #worksheet-screen .problem {
      border: 2px solid #eef2f7;
      padding: 25px 15px 15px 15px;
      text-align: right;
      background-color: white;
      border-radius: 12px;
      box-shadow: none;
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      transition: transform 0.2s;
      min-height: 150px;
    }

    #worksheet-screen .problem:hover {
      transform: translateY(-3px);
    }

    #worksheet-screen .problem.correct {
      border: 2px solid #2ecc71;
      background-color: #f0fff4;
    }

    #worksheet-screen .problem.incorrect {
      border: 2px solid #e74c3c;
      background-color: #fff5f5;
    }

    #worksheet-screen .math-expression {
      font-size: 28px;
      color: #2c3e50;
      line-height: 1.3;
      margin-bottom: 15px;
      white-space: pre;
      font-family: 'Comic Sans MS', cursive, sans-serif;
    }

    #worksheet-screen .operator-line {
      border-bottom: 3px solid #3498db;
      width: 100%;
      display: block;
      margin-top: 4px;
    }

    #worksheet-screen .problem input[type="number"] {
      width: 100%;
      min-width: 90px;
      height: 48px;
      font-size: 24px;
      text-align: right;
      border: 2px solid #fdc9ec;
      border-radius: 8px;
      font-family: inherit;
      padding: 0 8px;
      -moz-appearance: textfield;
      appearance: textfield;
      background: white;
      box-sizing: border-box;
    }

    #worksheet-screen .problem input::-webkit-outer-spin-button,
    #worksheet-screen .problem input::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    #worksheet-screen .problem::before {
      content: attr(data-number);
      position: absolute;
      top: -8px;
      left: -8px;
      color: #666666;
      font-size: 11px;
      font-weight: 600;
      z-index: 2;
      pointer-events: none;
      background-color: #f0f0f0;
      padding: 4px 8px;
      border-radius: 6px;
      line-height: 1;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    #worksheet-screen .button-container {
      display: flex;
      gap: 15px;
      margin-top: 40px;
      justify-content: center;
      flex-wrap: wrap;
      width: 100%;
      background: white;
    }

    #worksheet-screen .btn {
      padding: 15px 30px;
      font-size: 18px;
      color: #fff;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      font-family: inherit;
      transition: all 0.2s;
      min-height: 54px;
      flex: 1 0 auto;
      max-width: 220px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 0 rgba(0, 0, 0, 0.1);
      font-weight: bold;
      -webkit-user-select: none;
      user-select: none;
    }

    #worksheet-screen .generate-btn {
      background-color: #2ECC71;
    }

    #worksheet-screen .check-btn {
      background-color: #3498DB;
    }

    #worksheet-screen .back-btn {
      background-color: #95a5a6;
    }

    #worksheet-screen .btn:active {
      transform: translateY(3px);
      box-shadow: none;
    }

    #worksheet-screen .grade-display {
      margin-top: 40px;
      text-align: center;
      padding: 30px;
      border-radius: 20px;
      background: white;
      border: 4px dashed #3498db;
      width: 100%;
      max-width: 550px;
      box-sizing: border-box;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.05);
    }

    #worksheet-screen .grade-emoji {
      font-size: 80px;
      display: block;
      margin-bottom: 15px;
    }

    #worksheet-screen .grade-text {
      font-size: 28px;
      font-weight: bold;
    }

    #worksheet-screen .correct-answer {
      position: absolute;
      top: 30px;
      left: 15px;
      color: #e74c3c;
      font-weight: bold;
      font-size: 20px;
      background: white;
      padding: 4px 10px;
      border-radius: 8px;
      border: 2px solid #e74c3c;
      z-index: 5;
      box-shadow: 0 4px 10px rgba(231, 76, 60, 0.2);
    }

    #worksheet-screen .worksheet-number {
      font-size: 12px;
      color: #bdc3c7;
      align-self: flex-start;
      margin-bottom: 10px;
    }

    /* ============== MAIN MENU STYLES ============== */
    #main-menu {
      width: 100%;
      max-width: 500px;
      background: white;
      border: 3px solid #3498db;
      border-radius: 20px;
      padding: 40px 20px;
      text-align: center;
      margin-top: 50px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
      box-sizing: border-box;
      position: relative;
    }

    #main-menu h1 {
      color: #2ECC71;
      margin-top: 0;
      font-size: clamp(28px, 6vw, 40px);
      text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.05);
      margin-bottom: 40px;
    }

    .main-menu-btn {
      width: 100%;
      padding: 25px 30px;
      margin: 15px 0;
      font-size: clamp(20px, 5vw, 26px);
      font-family: 'Comic Sans MS', cursive, sans-serif;
      border: 3px solid #3498db;
      border-radius: 15px;
      cursor: pointer;
      transition: all 0.2s;
      background: white;
      color: #3498db;
      font-weight: bold;
      box-shadow: 0 6px 0 #2980b9;
      -webkit-user-select: none;
      user-select: none;
    }

    .main-menu-btn:hover {
      background: #e8f4fc;
      transform: translateY(-2px);
      box-shadow: 0 8px 0 #2980b9;
    }

    .main-menu-btn:active {
      transform: translateY(3px);
      box-shadow: 0 3px 0 #2980b9;
    }

    .main-menu-btn.create {
      background: #2ECC71;
      color: white;
      border-color: #27AE60;
      box-shadow: 0 6px 0 #27AE60;
    }

    .main-menu-btn.create:hover {
      background: #27AE60;
      box-shadow: 0 8px 0 #27AE60;
    }

    .main-menu-btn.load {
      background: #3498DB;
      color: white;
      border-color: #2980b9;
      box-shadow: 0 6px 0 #2980b9;
    }

    .main-menu-btn.load:hover {
      background: #2980b9;
      box-shadow: 0 8px 0 #2980b9;
    }

    /* ============== SETUP SCREEN STYLES ============== */
    #setup-screen {
      display: none;
      width: 100%;
      max-width: 700px;
      background: white;
      border: 3px solid #3498db;
      border-radius: 20px;
      padding: 20px;
      text-align: center;
      margin-top: 10px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
      box-sizing: border-box;
      position: relative;
      overflow-x: hidden;
    }

    @media (min-width: 600px) {
      body {
        padding: 20px;
      }

      #setup-screen {
        padding: 30px;
        margin-top: 20px;
      }
    }

    #setup-screen h1 {
      color: #2ECC71;
      margin-top: 0;
      font-size: clamp(24px, 6vw, 36px);
      text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.05);
    }

    .step-indicator {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .step-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #bdc3c7;
      transition: all 0.3s;
    }

    .step-dot.active {
      background: #3498db;
      transform: scale(1.3);
    }

    .step-dot.completed {
      background: #2ecc71;
    }

    .step-content {
      display: none;
      position: relative;
      padding-top: 70px;
      min-height: 400px;
    }

    .step-content.active {
      display: block;
    }

    .step-content h2 {
      margin-top: 0;
      margin-bottom: 12px;
      font-size: 20px;
      font-weight: 600;
    }

    /* ============== TEMPLATES & GRID ============== */
    .template-section {
      margin: 25px 0;
      text-align: center;
    }

    .template-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 15px;
      margin-bottom: 20px;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }

    @media (max-width: 600px) {
      .template-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
        max-width: 100%;
      }
    }

    .template-item {
      cursor: pointer;
      transition: all 0.2s ease;
      border-radius: 12px;
      padding: 8px;
      background: white;
      border: 2px solid #e0e0e0;
    }

    .template-item:hover {
      transform: translateY(-3px);
      box-shadow: 0 4px 12px rgba(52, 152, 219, 0.2);
      border-color: #3498db;
    }

    .template-item.selected {
      border-color: #2ecc71;
      background: #f0fff4;
      box-shadow: 0 4px 12px rgba(46, 204, 113, 0.3);
    }

    .template-preview {
      width: 100%;
      aspect-ratio: 8.5 / 11;
      background: white;
      border: 1px solid #d0d7de;
      border-radius: 8px;
      padding: 8px;
      box-sizing: border-box;
      margin-bottom: 8px;
      box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.06);
    }

    .template-grid-preview {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      box-sizing: border-box;
    }

    .template-header-area {
      height: 20%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      border-bottom: 1px solid #e8eaed;
      margin-bottom: 3px;
      padding: 2px 0;
    }

    .template-header-title {
      width: 60%;
      height: 4px;
      background: #2ecc71;
      border-radius: 2px;
      margin-bottom: 3px;
    }

    .template-header-fields {
      display: flex;
      gap: 8px;
      width: 100%;
      justify-content: center;
    }

    .template-header-field {
      width: 35%;
      height: 3px;
      background: #3498db;
      border-radius: 1px;
    }

    .template-cells-grid {
      flex: 1;
      display: grid;
      gap: 2px;
      box-sizing: border-box;
      min-height: 0;
    }

    .template-cell {
      background: #f8f9fa;
      border: 1px solid #e8eaed;
      border-radius: 2px;
      min-height: 0;
    }

    .template-label {
      font-size: 13px;
      font-weight: 600;
      color: #2c3e50;
      font-family: 'Comic Sans MS', cursive, sans-serif;
    }

    .template-label span {
      font-size: 11px;
      color: #7f8c8d;
      font-weight: normal;
    }

    .custom-layout-btn {
      padding: 12px 24px;
      background: #f8f9fa;
      border: 2px solid #fdc9ec;
      border-radius: 10px;
      color: #3498db;
      font-family: 'Comic Sans MS', cursive, sans-serif;
      font-size: 15px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-top: 10px;
    }

    .custom-layout-btn:hover {
      background: #e8f4fc;
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(52, 152, 219, 0.2);
    }

    .grid-layout-controls {
      display: flex;
      gap: 30px;
      justify-content: center;
      align-items: flex-start;
      margin: 30px 0;
      flex-wrap: wrap;
    }

    .grid-control-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      min-width: 140px;
    }

    .compact-number-control {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 8px;
      background: white;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      padding: 4px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
    }

    .compact-btn {
      width: 36px;
      height: 36px;
      min-width: 36px;
      min-height: 36px;
      border: none;
      border-radius: 6px;
      background: #f8f9fa;
      color: #5a6c7d;
      font-size: 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s ease;
      -webkit-user-select: none;
      user-select: none;
      flex-shrink: 0;
      touch-action: manipulation;
    }

    .compact-btn:hover {
      background: #e9ecef;
      color: #34495e;
    }

    .compact-btn-up {
      color: #27ae60;
    }

    .compact-btn-up:hover {
      background: #d5f4e6;
      color: #229954;
    }

    .compact-btn-down {
      color: #e74c3c;
    }

    .compact-btn-down:hover {
      background: #fadbd8;
      color: #c0392b;
    }

    .compact-number-control input {
      width: 60px;
      padding: 8px 4px;
      border: none;
      border-radius: 4px;
      font-family: 'Comic Sans MS', cursive, sans-serif;
      font-size: 18px;
      font-weight: 600;
      text-align: center;
      background: transparent;
      color: #2c3e50;
      pointer-events: none;
      outline: none;
    }

    /* ============== MINIMALISTIC PREVIEW ============== */
    .minimal-preview-container {
      margin: 30px auto;
      max-width: 400px;
      padding: 20px;
      background: #fafbfc;
      border: 1px solid #e8eaed;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
    }

    .minimal-preview-label {
      font-size: 12px;
      font-weight: 600;
      color: #95a5a6;
      text-transform: uppercase;
      letter-spacing: 1px;
      text-align: center;
      margin-bottom: 12px;
    }

    .minimal-preview-page {
      width: 100%;
      max-width: 360px;
      aspect-ratio: 8.5 / 11;
      margin: 0 auto;
      background: white;
      border: 1px solid #d0d7de;
      border-radius: 6px;
      padding: 0.25in;
      box-sizing: border-box;
      box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.06);
      display: flex;
      flex-direction: column;
      position: relative;
    }

    .minimal-preview-header {
      width: 100%;
      text-align: center;
      margin-bottom: 0.15in;
      flex-shrink: 0;
    }

    .minimal-preview-title {
      font-size: 18px;
      font-weight: bold;
      color: #2ecc71;
      margin-bottom: 0.1in;
      font-family: 'Comic Sans MS', cursive, sans-serif;
    }

    .minimal-preview-name-date {
      display: flex;
      justify-content: center;
      gap: 0.2in;
      flex-wrap: wrap;
      margin-top: 0.08in;
    }

    .minimal-preview-field {
      display: flex;
      align-items: center;
      gap: 0.05in;
    }

    .minimal-preview-label-text {
      font-size: 11px;
      font-weight: bold;
      color: #3498db;
      white-space: nowrap;
      font-family: 'Comic Sans MS', cursive, sans-serif;
    }

    .minimal-preview-underline-text {
      display: inline-block;
      font-size: 10px;
      color: #3498db;
      font-family: 'Comic Sans MS', cursive, sans-serif;
      text-decoration: underline;
      text-decoration-color: #3498db;
      text-underline-offset: 2px;
      text-decoration-thickness: 1.5px;
      margin-left: 0.05in;
      white-space: nowrap;
    }

    .minimal-grid-preview {
      width: 100%;
      flex: 1;
      background: transparent;
      border: none;
      border-radius: 0;
      padding: 0;
      box-shadow: none;
      display: grid;
      gap: 0.08in;
      box-sizing: border-box;
      min-height: 0;
    }

    .minimal-grid-preview .grid-preview-cell {
      border: 1px solid #e8eaed;
      border-radius: 2px;
      background: #f8f9fa;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 6px;
      color: #adb5bd;
      min-height: 0;
      transition: background 0.2s;
    }

    .preview-info {
      text-align: center;
      margin-top: 12px;
      font-size: 13px;
      color: #7f8c8d;
      font-weight: 500;
    }

    /* ============== MATH OPERATIONS ============== */
    .operations-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 15px;
      margin: 20px 0;
    }

    .operation-btn {
      padding: 20px;
      border: 3px solid #3498db;
      border-radius: 15px;
      background: white;
      color: #3498db;
      font-family: 'Comic Sans MS', cursive, sans-serif;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      -webkit-user-select: none;
      user-select: none;
      position: relative;
    }

    .operation-btn.selected {
      background: #3498db;
      color: white;
      transform: translateY(-2px) scale(1.02);
      animation: glowPulse 2s ease-in-out infinite;
    }

    .operation-btn.selected::before {
      content: '✓';
      position: absolute;
      top: 8px;
      right: 8px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
      animation: checkmarkPop 0.3s ease-out;
    }

    @keyframes checkmarkPop {
      0% {
        transform: scale(0);
        opacity: 0;
      }

      50% {
        transform: scale(1.2);
      }

      100% {
        transform: scale(1);
        opacity: 1;
      }
    }

    @keyframes glowPulse {

      0%,
      100% {
        box-shadow: 0 0 15px rgba(52, 152, 219, 0.6);
      }

      50% {
        box-shadow: 0 0 20px rgba(52, 152, 219, 0.8);
      }
    }

    .operation-btn.add {
      border-color: #e74c3c;
      color: #e74c3c;
    }

    .operation-btn.add.selected {
      background: #e74c3c;
      border-color: #e74c3c;
      color: white;
      animation: glowPulseRed 2s infinite;
    }

    @keyframes glowPulseRed {

      0%,
      100% {
        box-shadow: 0 0 15px rgba(231, 76, 60, 0.6);
      }

      50% {
        box-shadow: 0 0 20px rgba(231, 76, 60, 0.8);
      }
    }

    .operation-btn.sub {
      border-color: #f39c12;
      color: #f39c12;
    }

    .operation-btn.sub.selected {
      background: #f39c12;
      border-color: #f39c12;
      color: white;
      animation: glowPulseOrange 2s infinite;
    }

    @keyframes glowPulseOrange {

      0%,
      100% {
        box-shadow: 0 0 15px rgba(243, 156, 18, 0.6);
      }

      50% {
        box-shadow: 0 0 20px rgba(243, 156, 18, 0.8);
      }
    }

    .operation-btn.mul {
      border-color: #1abc9c;
      color: #1abc9c;
    }

    .operation-btn.mul.selected {
      background: #1abc9c;
      border-color: #1abc9c;
      color: white;
      animation: glowPulseTeal 2s infinite;
    }

    @keyframes glowPulseTeal {

      0%,
      100% {
        box-shadow: 0 0 15px rgba(26, 188, 156, 0.6);
      }

      50% {
        box-shadow: 0 0 20px rgba(26, 188, 156, 0.8);
      }
    }

    .operation-btn.div {
      border-color: #e67e22;
      color: #e67e22;
    }

    .operation-btn.div.selected {
      background: #e67e22;
      border-color: #e67e22;
      color: white;
      animation: glowPulseDarkOrange 2s infinite;
    }

    @keyframes glowPulseDarkOrange {

      0%,
      100% {
        box-shadow: 0 0 15px rgba(230, 126, 34, 0.6);
      }

      50% {
        box-shadow: 0 0 20px rgba(230, 126, 34, 0.8);
      }
    }

    /* ============== DISTRIBUTION ============== */
    .distribution-presets {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 15px;
      margin: 20px 0;
    }

    .distribution-btn {
      padding: 20px;
      border: 3px solid #3498db;
      border-radius: 15px;
      background: white;
      color: #3498db;
      font-family: 'Comic Sans MS', cursive, sans-serif;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
      -webkit-user-select: none;
      user-select: none;
    }

    .distribution-btn.selected {
      background: #3498db;
      color: white;
      box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
    }

    .problem-counter {
      background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
      color: white;
      padding: 15px;
      border-radius: 12px;
      text-align: center;
      margin-bottom: 20px;
      font-size: 18px;
      font-weight: bold;
    }

    .total-badge {
      background: white;
      color: #3498db;
      padding: 4px 12px;
      border-radius: 20px;
      margin-left: 8px;
    }

    #custom-distribution-panel {
      display: none;
      background: #f8f9fa;
      padding: 15px;
      border-radius: 15px;
      border: 2px solid #ecf0f1;
      margin-top: 10px;
    }

    .math-type-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 15px;
      margin: 10px 0;
      background: white;
      border-radius: 12px;
      border: 2px solid #ecf0f1;
      transition: all 0.2s;
      flex-wrap: wrap;
      gap: 15px;
    }

    .math-type-row.has-problems {
      border-color: #2ecc71;
      background: #f0fff4;
    }

    .math-type-info {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .math-type-icon {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 22px;
      font-weight: bold;
      color: white;
    }

    .math-type-icon.add {
      background: #e74c3c;
    }

    .math-type-icon.sub {
      background: #f39c12;
    }

    .math-type-icon.mul {
      background: #1abc9c;
    }

    .math-type-icon.div {
      background: #e67e22;
    }

    .math-type-controls {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .stepper-btn {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      border: 2px solid #3498db;
      background: white;
      color: #3498db;
      font-size: 24px;
      font-weight: bold;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.1s;
      -webkit-user-select: none;
      user-select: none;
    }

    .stepper-btn:active {
      transform: scale(0.9);
      background: #3498db;
      color: white;
    }

    .count-display {
      width: 60px;
      text-align: center;
      font-size: 20px;
      font-weight: bold;
      border: none;
      background: transparent;
      font-family: 'Comic Sans MS', cursive, sans-serif;
    }

    .quick-fill-row {
      display: flex;
      gap: 8px;
      margin-top: 20px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .quick-fill-btn {
      padding: 10px 14px;
      border: 1px solid #bdc3c7;
      border-radius: 8px;
      background: white;
      color: #7f8c8d;
      font-family: inherit;
      font-size: 13px;
      cursor: pointer;
      min-height: 44px;
      flex: 1 0 calc(50% - 10px);
      -webkit-user-select: none;
      user-select: none;
    }

    .progress-container {
      margin-top: 20px;
    }

    .progress-bar {
      height: 14px;
      background: #ecf0f1;
      border-radius: 7px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, #3498db, #2ecc71);
      transition: width 0.3s ease;
    }

    .progress-fill.over {
      background: #e74c3c;
    }

    .progress-labels {
      display: flex;
      justify-content: space-between;
      font-size: 13px;
      color: #7f8c8d;
      margin-top: 8px;
    }

    /* ============== DIFFICULTY MODES ============== */
    /* Compact Explanation Guide */
    .difficulty-explanation,
    .number-mode-section {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 8px;
      padding: 10px 12px;
      margin: 12px 0;
      font-size: 13px;
    }

    .explanation-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      cursor: pointer;
      transition: opacity 0.2s;
      -webkit-user-select: none;
      user-select: none;
      padding: 0;
      margin: 0;
    }

    .explanation-header:hover {
      opacity: 0.7;
    }

    .explanation-title-compact {
      flex: 1;
      color: #495057;
      font-size: 14px;
      font-weight: 600;
    }

    .explanation-toggle-btn {
      background: transparent;
      border: 1px solid #3498db;
      border-radius: 4px;
      width: 22px;
      height: 22px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
      padding: 0;
      margin: 0;
      font-size: 13px;
      color: #3498db;
      flex-shrink: 0;
      font-weight: 600;
    }

    .explanation-toggle-btn:hover {
      background: #e8f4fc;
      border-color: #2980b9;
    }

    .toggle-icon {
      display: inline-block;
      font-size: 13px;
      line-height: 1;
      color: #3498db;
      font-weight: 600;
      font-style: normal;
      font-family: Arial, sans-serif;
    }

    .difficulty-explanation.collapsed .explanation-header,
    .number-mode-section.collapsed .explanation-header {
      border-bottom: none;
    }

    .explanation-content {
      color: #495057;
      font-size: 13px;
      line-height: 1.5;
      overflow: hidden;
      transition: max-height 0.25s ease, margin 0.25s ease, padding 0.25s ease, opacity 0.25s ease;
      opacity: 1;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid #dee2e6;
    }

    .difficulty-explanation:not(.collapsed) .explanation-content,
    .number-mode-section:not(.collapsed) .explanation-content {
      max-height: 500px;
    }

    .difficulty-explanation.collapsed .explanation-content,
    .number-mode-section.collapsed .explanation-content {
      max-height: 0 !important;
      margin-top: 0;
      margin-bottom: 0;
      padding-top: 0;
      padding-bottom: 0;
      opacity: 0;
      border-top: none;
    }

    .explanation-content p {
      margin: 6px 0;
      font-size: 12px;
    }

    .explanation-content strong {
      color: #495057;
      font-weight: 600;
    }

    .explanation-note-compact {
      margin-top: 8px;
      padding: 8px;
      background: #fff3cd;
      border-radius: 4px;
      border: 1px solid #ffc107;
      color: #856404;
      font-size: 12px;
    }

    .difficulty-modes {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      margin: 15px 0;
    }

    .difficulty-mode {
      position: relative;
      padding: 12px 10px;
      border: 2px solid #3498db;
      border-radius: 8px;
      background: white;
      cursor: pointer;
      transition: all 0.2s;
      -webkit-user-select: none;
      user-select: none;
      text-align: center;
    }

    .difficulty-mode:hover {
      background: #e8f4fc;
      transform: translateY(-1px);
    }

    .difficulty-mode.selected {
      background: #3498db;
      color: white;
      box-shadow: 0 2px 8px rgba(52, 152, 219, 0.25);
    }

    .difficulty-mode h4 {
      margin: 0 0 6px 0;
      font-size: 16px;
      font-weight: 600;
    }

    .difficulty-mode p {
      margin: 0;
      font-size: 12px;
      opacity: 0.9;
    }

    .settings-icon {
      position: absolute;
      top: 6px;
      right: 6px;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: rgba(52, 152, 219, 0.15);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
    }

    .settings-icon:hover {
      background: rgba(52, 152, 219, 0.3);
      transform: rotate(90deg);
    }

    .difficulty-mode.selected .settings-icon {
      background: rgba(255, 255, 255, 0.3);
    }

    /* Difficulty Type Selection Buttons */
    .difficulty-type-selection {
      display: flex;
      flex-direction: column;
      gap: 20px;
      margin: 30px 0;
    }

    .difficulty-type-btn {
      padding: 25px;
      font-size: 20px;
      color: white;
      border: none;
      border-radius: 15px;
      cursor: pointer;
      transition: all 0.3s;
      font-family: inherit;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }

    .difficulty-type-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
    }

    .difficulty-type-btn:active {
      transform: translateY(0);
    }

    /* Grade Level Cards */
    .grade-level-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 15px;
      margin: 25px 0;
    }

    .grade-level-card {
      padding: 20px;
      text-align: center;
      background: white;
      border: 3px solid #e0e0e0;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s;
    }

    .grade-level-card:hover {
      border-color: #667eea;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
    }

    .grade-level-card h4 {
      margin: 0 0 8px 0;
      color: #667eea;
      font-size: 18px;
      font-weight: 600;
    }

    .grade-level-card p {
      margin: 0;
      font-size: 14px;
      color: #666;
    }

    .grade-level-card p:last-child {
      margin-top: 8px;
      font-size: 12px;
      color: #999;
    }

    .difficulty-warning-display {
      margin: 12px 0;
      padding: 10px 12px;
      background: #fff3cd;
      border: 1px solid #ffc107;
      border-radius: 6px;
      display: flex;
      align-items: center;
      gap: 8px;
      animation: slideDown 0.2s ease;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-5px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .warning-icon {
      font-size: 16px;
      flex-shrink: 0;
    }

    .warning-content {
      flex: 1;
      color: #856404;
      font-size: 12px;
      line-height: 1.4;
    }

    .warning-content strong {
      display: inline;
      margin-right: 4px;
      font-size: 12px;
      font-weight: 600;
    }

    .difficulty-settings-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      align-items: center;
      justify-content: center;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 20px;
      box-sizing: border-box;
    }

    .difficulty-settings-modal.active {
      display: flex;
    }

    /* Number Mode Compact Controls */
    .number-mode-controls-compact {
      margin-top: 10px;
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .checkbox-label {
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      font-size: 13px;
      color: #495057;
      font-weight: 500;
    }

    .checkbox-label input[type="checkbox"] {
      width: 16px;
      height: 16px;
      cursor: pointer;
      accent-color: #28a745;
    }

    #number-mode-input-container {
      display: none;
      align-items: center;
      gap: 8px;
      margin-left: 8px;
    }

    #number-mode-input-container label {
      font-size: 12px;
      color: #6c757d;
      font-weight: 500;
    }

    #number-mode-input-container input[type="number"] {
      width: 60px;
      padding: 4px 8px;
      border: 1px solid #28a745;
      border-radius: 4px;
      font-size: 14px;
      font-weight: 600;
      text-align: center;
    }

    #number-mode-preview {
      color: #28a745;
      font-weight: 500;
      font-size: 12px;
    }

    .settings-modal-content {
      background: white;
      padding: 20px;
      border-radius: 12px;
      max-width: 350px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    }

    .settings-input-group {
      margin: 15px 0;
    }

    .settings-input-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
      color: #7f8c8d;
    }

    .settings-input-group input {
      width: 100%;
      padding: 10px;
      border: 2px solid #bdc3c7;
      border-radius: 8px;
      font-family: 'Comic Sans MS', cursive, sans-serif;
      font-size: 16px;
      box-sizing: border-box;
    }

    .modal-close-btn {
      margin-top: 20px;
      padding: 12px 24px;
      background: #3498db;
      color: white;
      border: none;
      border-radius: 10px;
      font-family: 'Comic Sans MS', cursive, sans-serif;
      font-size: 16px;
      cursor: pointer;
      width: 100%;
    }

    /* ============== NAVIGATION & ACTIONS ============== */
    .step-navigation {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 15px;
      z-index: 100;
      pointer-events: none;
    }

    .step-navigation.has-center {
      position: relative;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 15px;
      margin-top: 20px;
    }

    .nav-btn {
      padding: 12px 24px;
      font-size: 16px;
      color: #fff;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-family: 'Comic Sans MS', cursive, sans-serif;
      transition: all 0.2s;
      min-height: 44px;
      min-width: 100px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 0 rgba(0, 0, 0, 0.1);
      font-weight: bold;
      -webkit-user-select: none;
      user-select: none;
      pointer-events: auto;
    }

    .nav-btn.back {
      margin-right: auto;
      background-color: #95a5a6;
      box-shadow: 0 4px 0 #7f8c8d;
    }

    .nav-btn.continue {
      margin-left: auto;
      background-color: #2ECC71;
      box-shadow: 0 4px 0 #27AE60;
    }

    .nav-btn.save {
      background-color: #9b59b6;
      box-shadow: 0 4px 0 #8e44ad;
    }

    .nav-btn.generate {
      background-color: #2ECC71;
      box-shadow: 0 4px 0 #27AE60;
    }

    .bottom-actions-container {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 12px;
      margin-top: 20px;
      margin-bottom: 10px;
    }

    .nav-btn:active {
      transform: translateY(3px);
      box-shadow: none;
    }

    .nav-btn:disabled {
      background-color: #bdc3c7;
      box-shadow: 0 4px 0 #95a5a6;
      cursor: not-allowed;
    }

    .final-actions {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 20px;
    }

    .action-btn {
      padding: 10px 20px;
      font-size: 14px;
      color: #fff;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-family: 'Comic Sans MS', cursive, sans-serif;
      transition: all 0.2s;
      font-weight: 600;
      box-shadow: 0 3px 0 rgba(0, 0, 0, 0.15);
      -webkit-user-select: none;
      user-select: none;
    }

    .action-btn.preview {
      background-color: #3498DB;
      box-shadow: 0 3px 0 #2980b9;
    }

    .action-btn.save {
      background-color: #9b59b6;
      box-shadow: 0 3px 0 #8e44ad;
    }

    .action-btn.generate {
      background-color: #2ECC71;
      box-shadow: 0 3px 0 #27AE60;
      font-size: 15px;
      font-weight: 700;
    }

    .action-btn:active {
      transform: translateY(2px);
      box-shadow: 0 1px 0 rgba(0, 0, 0, 0.15);
    }

    /* ============== PREVIEW MODAL ============== */
    .preview-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 1000;
      align-items: center;
      justify-content: center;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 20px;
      box-sizing: border-box;
    }

    .preview-modal.active {
      display: flex;
    }

    /* ============== VALIDATION NOTIFICATION MODAL ============== */
    .validation-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.6);
      z-index: 2000;
      align-items: center;
      justify-content: center;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 20px;
      box-sizing: border-box;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .validation-modal.active {
      display: flex;
      opacity: 1;
    }

    .validation-modal-content {
      background: white;
      border-radius: 20px;
      padding: 0;
      max-width: 600px;
      width: 90%;
      max-height: 85vh;
      overflow-y: auto;
      overflow-x: hidden;
      box-shadow: 0 15px 40px rgba(0, 0, 0, 0.4);
      animation: slideIn 0.3s ease;
    }

    @keyframes slideIn {
      from {
        transform: translateY(-50px);
        opacity: 0;
      }

      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    .validation-header {
      background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
      color: white;
      padding: 20px 25px;
      border-radius: 20px 20px 0 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: relative;
    }

    .validation-header h3 {
      margin: 0;
      font-size: 22px;
      font-weight: bold;
      font-family: 'Comic Sans MS', cursive, sans-serif;
    }

    .validation-modal .modal-close-btn {
      position: absolute;
      top: 15px;
      right: 15px;
      width: 35px;
      height: 35px;
      margin: 0;
      padding: 0;
      background: rgba(255, 255, 255, 0.2);
      border: none;
      border-radius: 50%;
      color: white;
      font-size: 24px;
      font-weight: bold;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      transition: all 0.2s;
      font-family: Arial, sans-serif;
    }

    .validation-modal .modal-close-btn:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: rotate(90deg);
    }

    .validation-body {
      padding: 25px;
    }

    .validation-section {
      margin-bottom: 20px;
    }

    .validation-section:last-child {
      margin-bottom: 0;
    }

    .validation-section.errors {
      background: #fee;
      border-left: 4px solid #e74c3c;
      padding: 15px;
      border-radius: 8px;
    }

    .validation-section.warnings {
      background: #fff9e6;
      border-left: 4px solid #f39c12;
      padding: 15px;
      border-radius: 8px;
    }

    .validation-section h4 {
      margin: 0 0 12px 0;
      font-size: 18px;
      font-weight: bold;
      font-family: 'Comic Sans MS', cursive, sans-serif;
      color: #2c3e50;
    }

    .validation-section.errors h4 {
      color: #c0392b;
    }

    .validation-section.warnings h4 {
      color: #d68910;
    }

    .validation-section ul {
      margin: 0;
      padding-left: 20px;
      list-style-type: disc;
    }

    .validation-section li {
      margin: 8px 0;
      line-height: 1.6;
      color: #34495e;
      font-size: 15px;
    }

    .validation-note {
      margin: 15px 0 0 0;
      padding: 12px;
      background: rgba(0, 0, 0, 0.05);
      border-radius: 6px;
      font-size: 14px;
      line-height: 1.5;
      color: #555;
    }

    .validation-actions {
      padding: 20px 25px;
      background: #f8f9fa;
      border-radius: 0 0 20px 20px;
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }

    .validation-btn {
      padding: 12px 24px;
      font-size: 16px;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-weight: bold;
      font-family: 'Comic Sans MS', cursive, sans-serif;
      transition: all 0.2s;
      min-width: 120px;
      box-shadow: 0 4px 0 rgba(0, 0, 0, 0.1);
    }

    .validation-btn.primary {
      background-color: #2ECC71;
      color: white;
      box-shadow: 0 4px 0 #27AE60;
    }

    .validation-btn.primary:hover {
      background-color: #27AE60;
    }

    .validation-btn.secondary {
      background-color: #95a5a6;
      color: white;
      box-shadow: 0 4px 0 #7f8c8d;
    }

    .validation-btn.secondary:hover {
      background-color: #7f8c8d;
    }

    .validation-btn:active {
      transform: translateY(2px);
      box-shadow: 0 2px 0 rgba(0, 0, 0, 0.1);
    }

    .preview-content {
      background: white;
      border-radius: 20px;
      padding: 20px;
      max-width: 900px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
      overflow-x: hidden;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .preview-close {
      position: absolute;
      top: 15px;
      right: 15px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: #e74c3c;
      color: white;
      border: none;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
    }

    .preview-worksheet {
      width: 100%;
      border: 2px solid #fdc9ec;
      border-radius: 10px;
      padding: 20px;
      background: white;
      box-sizing: border-box;
    }

    .preview-worksheet-container {
      width: 8.5in;
      min-height: 11in;
      background: white;
      padding: 0.2in;
      box-sizing: border-box;
      margin: 0 auto;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      transform: scale(0.75);
      transform-origin: top center;
      font-family: 'Comic Sans MS', cursive, sans-serif;
      height: 11in;
      overflow: hidden;
      transition: transform 0.2s ease;
    }

    /* Style for Preview Matching Printed Worksheet */
    .preview-worksheet-container .header {
      text-align: center;
      margin: 0 0 0.1in 0;
    }

    .preview-worksheet-container .header h1 {
      font-size: 20px;
      margin: 0 0 0.06in 0;
      color: #2ecc71;
    }

    .preview-worksheet-container .header p {
      font-size: 12px;
      margin: 0.03in 0 0 0;
      display: flex;
      justify-content: center;
      gap: 0.2in;
    }

    .preview-worksheet-container .header input {
      border: none;
      border-bottom: 1.5px solid #3498db;
      width: 1.8in;
    }

    .preview-worksheet-container .problems-grid {
      display: grid;
      grid-template-columns: repeat(var(--print-cols, 4), var(--print-problem-width, 1.2in));
      gap: var(--print-gap, 0.1in);
    }

    .preview-worksheet-container .problem {
      border: 1px solid #ccc;
      padding: 0.06in;
      text-align: right;
      width: var(--print-problem-width, 1.2in);
      height: var(--print-problem-height, 0.8in);
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      position: relative;
      align-items: flex-end;
    }

    .preview-worksheet-container .math-expression {
      font-size: 14px;
      margin-bottom: 0.05in;
      width: 100%;
      white-space: pre;
      color: #2c3e50;
      text-align: right;
    }

    .preview-worksheet-container .problem.horizontal .math-expression {
      white-space: normal !important;
      text-align: center !important;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }

    .preview-worksheet-container .operator-line {
      border-bottom: 2px solid #3498db;
      display: block;
      width: 100%;
      margin-top: 0.02in;
    }

    .preview-worksheet-container .problem input {
      width: 100%;
      max-width: 0.9in;
      height: 0.25in;
      font-size: 12px;
      text-align: right;
      border: 2px solid #fdc9ec;
      border-radius: 6px;
    }

    /* Saved Worksheets */
    .saved-worksheets {
      margin: 20px 0;
      max-height: 400px;
      overflow-y: auto;
    }

    .saved-worksheet-item {
      padding: 15px;
      margin: 10px 0;
      background: #f8f9fa;
      border: 2px solid #ecf0f1;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .saved-worksheet-item:hover {
      background: #e8f4fc;
      border-color: #3498db;
    }

    .saved-worksheet-item h4 {
      margin: 0 0 5px 0;
      color: #3498db;
    }

    .saved-worksheet-item p {
      margin: 5px 0;
      font-size: 12px;
      color: #7f8c8d;
    }
  </style>
</head>

<body>
  <div id="main-menu">
    <h1>Math Worksheet Creator</h1>
    <button class="main-menu-btn create" onclick="showCreateWorksheet()">Create New Worksheet</button>
    <button class="main-menu-btn load" onclick="showLoadWorksheet()">Load Worksheet</button>
  </div>

  <div id="setup-screen">
    <h1>Math Worksheet Creator</h1>
    <div class="step-indicator" id="step-indicator"></div>

    <div class="step-content active" id="step-1">
      <h2>Select Math Operations</h2>
      <p>Choose 1 to 4 math operations for your worksheet:</p>
      <div class="operations-grid">
        <button class="operation-btn add" onclick="toggleOperation('add')"><span>➕</span> <span>Addition</span></button>
        <button class="operation-btn sub" onclick="toggleOperation('sub')"><span>➖</span>
          <span>Subtraction</span></button>
        <button class="operation-btn mul" onclick="toggleOperation('mul')"><span>✖️</span>
          <span>Multiplication</span></button>
        <button class="operation-btn div" onclick="toggleOperation('div')"><span>➗</span> <span>Division</span></button>
      </div>
      <div class="step-navigation">
        <button class="nav-btn back" onclick="goToMainMenu()">Back</button>
        <button class="nav-btn continue" id="step1-continue" onclick="goToStep(2)" disabled>Continue</button>
      </div>
    </div>

    <div class="step-content" id="step-2">
      <h2>Grid Layout</h2>
      <p>Choose your grid size (will fit perfectly on standard paper):</p>

      <div class="template-section">
        <div class="template-grid">
          <div class="template-item" onclick="selectTemplate(4, 5)">
            <div class="template-preview" id="template-4x5">
              <div class="template-grid-preview">
                <div class="template-header-area">
                  <div class="template-header-title"></div>
                  <div class="template-header-fields">
                    <div class="template-header-field"></div>
                    <div class="template-header-field"></div>
                  </div>
                </div>
                <div class="template-cells-grid"
                  style="grid-template-columns: repeat(5, 1fr); grid-template-rows: repeat(4, 1fr);"></div>
              </div>
            </div>
            <div class="template-label">4 × 5<br><span>20 problems</span></div>
          </div>
          <div class="template-item" onclick="selectTemplate(5, 6)">
            <div class="template-preview" id="template-5x6">
              <div class="template-grid-preview">
                <div class="template-header-area">
                  <div class="template-header-title"></div>
                  <div class="template-header-fields">
                    <div class="template-header-field"></div>
                    <div class="template-header-field"></div>
                  </div>
                </div>
                <div class="template-cells-grid"
                  style="grid-template-columns: repeat(6, 1fr); grid-template-rows: repeat(5, 1fr);"></div>
              </div>
            </div>
            <div class="template-label">5 × 6<br><span>30 problems</span></div>
          </div>
          <div class="template-item" onclick="selectTemplate(6, 7)">
            <div class="template-preview" id="template-6x7">
              <div class="template-grid-preview">
                <div class="template-header-area">
                  <div class="template-header-title"></div>
                  <div class="template-header-fields">
                    <div class="template-header-field"></div>
                    <div class="template-header-field"></div>
                  </div>
                </div>
                <div class="template-cells-grid"
                  style="grid-template-columns: repeat(7, 1fr); grid-template-rows: repeat(6, 1fr);"></div>
              </div>
            </div>
            <div class="template-label">6 × 7<br><span>42 problems</span></div>
          </div>
          <div class="template-item" onclick="selectTemplate(7, 8)">
            <div class="template-preview" id="template-7x8">
              <div class="template-grid-preview">
                <div class="template-header-area">
                  <div class="template-header-title"></div>
                  <div class="template-header-fields">
                    <div class="template-header-field"></div>
                    <div class="template-header-field"></div>
                  </div>
                </div>
                <div class="template-cells-grid"
                  style="grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(7, 1fr);"></div>
              </div>
            </div>
            <div class="template-label">7 × 8<br><span>56 problems</span></div>
          </div>
        </div>
        <button class="custom-layout-btn" onclick="showCustomLayout()">Custom Layout</button>
      </div>

      <div class="grid-layout-controls" id="custom-layout-controls" style="display: none;">
        <div class="grid-control-item">
          <label for="rows">Rows</label>
          <div class="compact-number-control">
            <button class="compact-btn compact-btn-up" onclick="adjustGridValue('rows', 1)"><span>▲</span></button>
            <input type="number" id="rows" value="5" min="1" max="30" onchange="updateGridPreview()" readonly>
            <button class="compact-btn compact-btn-down" onclick="adjustGridValue('rows', -1)"><span>▼</span></button>
          </div>
        </div>
        <div class="grid-control-item">
          <label for="cols">Columns</label>
          <div class="compact-number-control">
            <button class="compact-btn compact-btn-up" onclick="adjustGridValue('cols', 1)"><span>▲</span></button>
            <input type="number" id="cols" value="6" min="1" max="12" onchange="updateGridPreview()" readonly>
            <button class="compact-btn compact-btn-down" onclick="adjustGridValue('cols', -1)"><span>▼</span></button>
          </div>
        </div>
      </div>
      <div class="minimal-preview-container">
        <div class="minimal-preview-label">PREVIEW</div>
        <div class="minimal-preview-page">
          <div class="minimal-preview-header">
            <div class="minimal-preview-title">Math Worksheet</div>
            <div class="minimal-preview-name-date">
              <div class="minimal-preview-field"><span class="minimal-preview-label-text">Name:</span><span
                  class="minimal-preview-underline-text">Enter name</span></div>
              <div class="minimal-preview-field"><span class="minimal-preview-label-text">Date:</span><span
                  class="minimal-preview-underline-text">Today's Date</span></div>
            </div>
          </div>
          <div class="minimal-grid-preview" id="grid-preview"></div>
        </div>
        <div class="preview-info" id="preview-info">30 problems</div>
      </div>
      <div class="step-navigation">
        <button class="nav-btn back" onclick="goToStep(1)">Back</button>
        <button class="nav-btn continue" id="step2-continue" onclick="goToStep(3)" disabled>Continue</button>
      </div>
    </div>

    <div class="step-content" id="step-3">
      <h2>Operation Distribution</h2>
      <p>How would you like to distribute the operations?</p>
      <div class="problem-counter" id="problem-counter">Total Problems: <span class="total-badge"
          id="total-badge">30</span></div>
      <div class="distribution-presets">
        <button class="distribution-btn" onclick="selectDistribution('random-mix')">🎲 Random Mix</button>
        <button class="distribution-btn" onclick="selectDistribution('every-other')">🔄 Every Other Mix</button>
        <button class="distribution-btn" onclick="selectDistribution('half-half')">⚖️ Half and Half</button>
        <button class="distribution-btn" onclick="selectDistribution('custom')">🎯 Custom</button>
      </div>
      <div id="custom-distribution-panel">
        <div class="math-type-row" id="row-add">
          <div class="math-type-info">
            <div class="math-type-icon add">+</div><span class="math-type-name">Addition</span>
          </div>
          <div class="math-type-controls">
            <button class="stepper-btn" onclick="adjustCount('add', -1)">−</button>
            <input type="number" class="count-display" id="count-add" value="0" min="0" onchange="onCountChange()">
            <button class="stepper-btn" onclick="adjustCount('add', 1)">+</button>
          </div>
        </div>
        <div class="math-type-row" id="row-sub">
          <div class="math-type-info">
            <div class="math-type-icon sub">−</div><span class="math-type-name">Subtraction</span>
          </div>
          <div class="math-type-controls">
            <button class="stepper-btn" onclick="adjustCount('sub', -1)">−</button>
            <input type="number" class="count-display" id="count-sub" value="0" min="0" onchange="onCountChange()">
            <button class="stepper-btn" onclick="adjustCount('sub', 1)">+</button>
          </div>
        </div>
        <div class="math-type-row" id="row-mul">
          <div class="math-type-info">
            <div class="math-type-icon mul">×</div><span class="math-type-name">Multiplication</span>
          </div>
          <div class="math-type-controls">
            <button class="stepper-btn" onclick="adjustCount('mul', -1)">−</button>
            <input type="number" class="count-display" id="count-mul" value="0" min="0" onchange="onCountChange()">
            <button class="stepper-btn" onclick="adjustCount('mul', 1)">+</button>
          </div>
        </div>
        <div class="math-type-row" id="row-div">
          <div class="math-type-info">
            <div class="math-type-icon div">÷</div><span class="math-type-name">Division</span>
          </div>
          <div class="math-type-controls">
            <button class="stepper-btn" onclick="adjustCount('div', -1)">−</button>
            <input type="number" class="count-display" id="count-div" value="0" min="0" onchange="onCountChange()">
            <button class="stepper-btn" onclick="adjustCount('div', 1)">+</button>
          </div>
        </div>
        <div class="quick-fill-row">
          <button class="quick-fill-btn" onclick="quickFill('clear')">🗑️ Clear All</button>
          <button class="quick-fill-btn" onclick="quickFill('fill-remaining-add')">Fill rest with +</button>
          <button class="quick-fill-btn" onclick="quickFill('fill-remaining-sub')">Fill rest with −</button>
          <button class="quick-fill-btn" onclick="quickFill('fill-remaining-mul')">Fill rest with ×</button>
          <button class="quick-fill-btn" onclick="quickFill('fill-remaining-div')">Fill rest with ÷</button>
        </div>
        <div class="progress-container">
          <div class="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
          </div>
          <div class="progress-labels"><span id="assigned-count">0 assigned</span><span id="remaining-count">30
              remaining</span></div>
        </div>
      </div>
      <div class="step-navigation">
        <button class="nav-btn back" onclick="goToStep(2)">Back</button>
        <button class="nav-btn continue" id="step3-continue" onclick="goToStep(4)">Continue</button>
      </div>
    </div>

    <!-- Step 4: Difficulty Type Selection -->
    <div class="step-content" id="step-4">
      <h2>Select Difficulty Type</h2>
      <p>Choose how you want to set the difficulty level:</p>
      <div class="difficulty-type-selection" style="display: flex; flex-direction: column; gap: 20px; margin: 30px 0;">
        <button class="difficulty-type-btn" onclick="selectDifficultyType('grade-level')"
          style="padding: 25px; font-size: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 15px; cursor: pointer; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4); transition: all 0.3s;">
          <div style="font-size: 32px; margin-bottom: 10px;">🎓</div>
          <div style="font-weight: bold; margin-bottom: 5px;">Grade Level Math Difficulty</div>
          <div style="font-size: 14px; opacity: 0.9;">Select from K4 through 8th grade standards</div>
        </button>
        <button class="difficulty-type-btn" onclick="selectDifficultyType('custom')"
          style="padding: 25px; font-size: 20px; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; border: none; border-radius: 15px; cursor: pointer; box-shadow: 0 4px 15px rgba(245, 87, 108, 0.4); transition: all 0.3s;">
          <div style="font-size: 32px; margin-bottom: 10px;">⚙️</div>
          <div style="font-weight: bold; margin-bottom: 5px;">Custom Level Difficulty</div>
          <div style="font-size: 14px; opacity: 0.9;">Set your own custom difficulty ranges</div>
        </button>
      </div>
      <div class="step-navigation">
        <button class="nav-btn back" onclick="goToStep(3)">Back</button>
      </div>
    </div>

    <!-- Step 5: Grade Level Math Difficulty -->
    <div class="step-content" id="step-5">
      <h2>Grade Level Math Difficulty</h2>
      <p>Select the grade level that matches your student's math curriculum:</p>

      <!-- Compact Explanation Guide -->
      <div class="difficulty-explanation collapsed">
        <div class="explanation-header" onclick="toggleGradeLevelExplanation()">
          <span class="explanation-title-compact">Grade Level Info</span>
          <button class="explanation-toggle-btn" onclick="event.stopPropagation(); toggleGradeLevelExplanation()"
            aria-label="Toggle explanation">
            <span class="toggle-icon">ℹ</span>
          </button>
        </div>
        <div class="explanation-content" id="grade-level-explanation-content">
          <p><strong>Grade Level Difficulty:</strong> Each grade level generates math problems that match Common Core
            math standards for that grade. Simply select a grade level to get age-appropriate problems automatically
            configured for your student's curriculum.</p>
        </div>
      </div>

      <div style="margin: 30px 0;">
        <label for="grade-level-select"
          style="display: block; margin-bottom: 12px; font-weight: 600; color: #333; font-size: 15px;">Select Grade
          Level:</label>
        <select id="grade-level-select" onchange="selectGradeLevelFromDropdown(this.value)"
          style="width: 100%; max-width: 400px; padding: 14px 16px; font-size: 16px; border: 2px solid #e0e0e0; border-radius: 8px; background: white; color: #333; cursor: pointer; transition: all 0.3s; font-family: inherit;">
          <option value="">-- Select a grade level --</option>
          <option value="k4">K4 - Pre-K</option>
          <option value="k5">K5 - Kindergarten</option>
          <option value="1">1st Grade</option>
          <option value="2">2nd Grade</option>
          <option value="3">3rd Grade</option>
          <option value="4">4th Grade</option>
          <option value="5">5th Grade</option>
          <option value="6">6th Grade</option>
          <option value="7">7th Grade</option>
          <option value="8">8th Grade</option>
        </select>
      </div>

      <div id="grade-level-examples"
        style="display: none; margin: 20px 0; padding: 16px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; border-left: 4px solid #667eea;">
        <div style="font-weight: 600; color: #667eea; margin-bottom: 10px; font-size: 14px;">Example Problems for <span
            id="selected-grade-name"></span>:</div>
        <div id="grade-examples-content"
          style="color: #495057; font-size: 14px; line-height: 1.8; font-family: 'Comic Sans MS', cursive, sans-serif;">
        </div>
      </div>

      <div class="bottom-actions-container">
        <button class="nav-btn generate" onclick="generateWorksheet()">Generate Worksheet!</button>
        <button class="nav-btn save" onclick="saveWorksheetSettings()">Save Worksheet Settings</button>
      </div>
      <div class="step-navigation">
        <button class="nav-btn back" onclick="goToStep(4)">Back</button>
      </div>
    </div>

    <!-- Step 6: Custom Level Difficulty (formerly step 4) -->
    <div class="step-content" id="step-6">
      <h2>Difficulty Range</h2>

      <!-- Compact Explanation Guide -->
      <div class="difficulty-explanation collapsed">
        <div class="explanation-header" onclick="toggleExplanation()">
          <span class="explanation-title-compact">Answer Range Info</span>
          <button class="explanation-toggle-btn" onclick="event.stopPropagation(); toggleExplanation()"
            aria-label="Toggle explanation">
            <span class="toggle-icon">ℹ</span>
          </button>
        </div>
        <div class="explanation-content" id="explanation-content">
          <p><strong>Min/Max:</strong> The smallest and largest answers your problems will have.</p>
          <p><strong>Example:</strong> Min: 1, Max: 10 → All answers between 1-10 (e.g., 3+6=9, 8-3=5, 2×5=10, 8÷2=4)
          </p>
          <p class="explanation-note-compact">💡 Click difficulty cards to select, ⚙️ to customize ranges.</p>
        </div>
      </div>
      <div class="difficulty-modes">
        <div class="difficulty-mode" id="mode-easy" onclick="selectDifficulty('easy')">
          <div class="settings-icon" onclick="event.stopPropagation(); openDifficultySettings('easy')">⚙️</div>
          <h4>Easy</h4>
          <p id="easy-range">1-20</p>
        </div>
        <div class="difficulty-mode" id="mode-medium" onclick="selectDifficulty('medium')">
          <div class="settings-icon" onclick="event.stopPropagation(); openDifficultySettings('medium')">⚙️</div>
          <h4>Medium</h4>
          <p id="medium-range">1-50</p>
        </div>
        <div class="difficulty-mode" id="mode-hard" onclick="selectDifficulty('hard')">
          <div class="settings-icon" onclick="event.stopPropagation(); openDifficultySettings('hard')">⚙️</div>
          <h4>Hard</h4>
          <p id="hard-range">5-199</p>
        </div>
        <div class="difficulty-mode" id="mode-expert" onclick="selectDifficulty('expert')">
          <div class="settings-icon" onclick="event.stopPropagation(); openDifficultySettings('expert')">⚙️</div>
          <h4>Expert</h4>
          <p id="expert-range">25-999</p>
        </div>
      </div>
      <div id="difficulty-warning-display" class="difficulty-warning-display" style="display: none;">
        <div class="warning-icon">⚠️</div>
        <div class="warning-content">
          <strong>Variety Warning:</strong>
          <span id="difficulty-warning-text"></span>
        </div>
      </div>

      <!-- Compact Number Mode Section -->
      <div class="number-mode-section collapsed">
        <div class="explanation-header" onclick="toggleNumberModeInfo()">
          <span class="explanation-title-compact">Number Mode (Optional)</span>
          <button class="explanation-toggle-btn" onclick="event.stopPropagation(); toggleNumberModeInfo()"
            aria-label="Toggle Number Mode info">
            <span class="toggle-icon">ℹ</span>
          </button>
        </div>
        <div class="explanation-content" id="number-mode-info-content">
          <p><strong>Number Mode:</strong> Focus practice on a specific number. All problems will include your selected
            number or its multiples within the answer range.</p>
          <p><strong>Example (Number Mode 5, Multiples):</strong> 5+10=15, 20-5=15, 5×3=15, 30÷5=6 (all use multiples of
            5)</p>
          <p style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #dee2e6;"><strong>Exact Number
              Mode:</strong> When enabled, every problem must contain the exact number you selected. Perfect for
            mastering specific number facts like "5 times tables" or "subtracting 7".</p>
          <p><strong>Example (Exact Number Mode 5):</strong> 5+8=13, 12-5=7, 5×4=20, 25÷5=5 (the number 5 appears in
            every problem)</p>
        </div>
        <div class="number-mode-controls-compact">
          <label class="checkbox-label">
            <input type="checkbox" id="number-mode-enabled" onchange="toggleNumberMode()">
            <span>Enable Number Mode</span>
          </label>
          <div id="number-mode-input-container" style="display: none;">
            <label>Practice Number:</label>
            <input type="number" id="number-mode-value" min="1" max="100" value="5" onchange="updateNumberMode()">
            <span id="number-mode-preview"></span>
          </div>
          <div id="number-mode-exact-container" style="display: none; margin-top: 8px;">
            <label class="checkbox-label">
              <input type="checkbox" id="number-mode-exact" onchange="updateNumberMode()">
              <span style="font-size: 12px; color: #495057;"><strong>Require exact number in every problem</strong>
                (e.g., 3×2, 3×7, 10-3)</span>
            </label>
          </div>
        </div>
      </div>

      <div class="bottom-actions-container">
        <button class="nav-btn generate" onclick="generateWorksheet()">Generate Worksheet!</button>
        <button class="nav-btn save" onclick="saveWorksheetSettings()">Save Worksheet Settings</button>
      </div>
      <div class="step-navigation">
        <button class="nav-btn back" onclick="goToStep(4)">Back</button>
      </div>
    </div>
  </div>

  <div class="difficulty-settings-modal" id="difficulty-settings-modal">
    <div class="settings-modal-content">
      <h3 id="settings-modal-title">Customize Difficulty</h3>
      <div class="settings-input-group"><label>Minimum Number</label><input type="number" id="settings-min" min="1">
      </div>
      <div class="settings-input-group"><label>Maximum Number</label><input type="number" id="settings-max" min="2">
      </div>
      <button class="modal-close-btn" onclick="closeDifficultySettings()">Save & Close</button>
    </div>
  </div>

  <div class="preview-modal" id="preview-modal">
    <div class="preview-content">
      <button class="preview-close" onclick="closePreview()">×</button>
      <h2>Worksheet Preview</h2>
      <div class="preview-worksheet" id="preview-worksheet"></div>
    </div>
  </div>

  <script>
    // ============================================================================
    // CONSTANTS
    // ============================================================================
    const CONSTANTS = {
      MAX_GENERATION_ATTEMPTS: 150,
      MAX_FALLBACK_ATTEMPTS: 50,
      MAX_FINAL_ATTEMPTS: 100, // Reduced from 300 to improve performance
      SEED_MULTIPLIER: 9301,
      SEED_ADDEND: 49297,
      SEED_MODULUS: 233280,
      SEED_RANGE: 1000000,
      DEFAULT_ROWS: 5,
      DEFAULT_COLS: 6,
      DEFAULT_MIN: 2,
      DEFAULT_MAX: 12,
      DEFAULT_NUMBER_MODE_VALUE: 5,
      OPERATION_MAP: { add: '+', sub: '-', mul: '*', div: '/' },
      OPERATION_NAMES: { add: 'Addition', sub: 'Subtraction', mul: 'Multiplication', div: 'Division' },
      TOTAL_STEPS: 6, // Step 1: Operations, 2: Layout, 3: Distribution, 4: Difficulty Type, 5: Grade Level/Custom Difficulty
      MAX_ANSWER: 999999 // Maximum 6-digit number (no 7-digit numbers allowed)
    };

    // ============================================================================
    // GLOBAL STATE
    // ============================================================================
    let currentStep = 1; // Start at step 1 (Operations Selection)
    let selectedOperations = [];
    let gridExplicitlySelected = false; // Track if user has explicitly selected a grid
    let previewInProgress = false; // Flag to prevent multiple simultaneous preview calls
    let generateInProgress = false; // Flag to prevent multiple simultaneous generation calls
    let pendingGeneration = null; // Tracks pending generation action ('generate' or 'preview')
    let config = {
      rows: CONSTANTS.DEFAULT_ROWS,
      cols: CONSTANTS.DEFAULT_COLS,
      min: CONSTANTS.DEFAULT_MIN,
      max: CONSTANTS.DEFAULT_MAX,
      mode: 'random',
      operators: [],
      customCounts: {},
      distribution: 'random-mix'
    };
    let currentDifficulty = 'medium';
    let difficultySettings = {
      easy: { min: 1, max: 20 },
      medium: { min: 1, max: 50 },
      hard: { min: 5, max: 199 },
      expert: { min: 25, max: 999999 }  // Can go up to 6 digits but capped at 999,999 
    };
    let currentSettingsMode = null;

    // Grade Level Difficulty Settings (K4 - 8th Grade)
    // Updated to match provided examples exactly
    const gradeLevelSettings = {
      k4: {
        name: 'Pre-K',
        // Examples: 2×2, 3×1 | 2+1, 3+2 | 5−2, 4−1 | 6÷3, 4÷2
        operandMin: 1, operandMax: 6,
        answerMax: 10,
        multiplicationTable: 3,  // Up to 3×3
        divisionDividendMax: 8,
        divisionDivisorMax: 4,
        operations: ['+', '-', '*', '/'],
        description: 'Basic counting and simple arithmetic'
      },
      k5: {
        name: 'Kindergarten',
        // Examples: 2×4, 3×3 | 5+4, 6+3 | 9−4, 8−3 | 10÷5, 12÷3
        operandMin: 1, operandMax: 12,
        answerMax: 20,
        multiplicationTable: 5,  // Up to 5×5
        divisionDividendMax: 12,
        divisionDivisorMax: 5,
        operations: ['+', '-', '*', '/'],
        description: 'Basic arithmetic with numbers up to 12'
      },
      '1': {
        name: '1st Grade',
        // Examples: 4×3, 5×2 | 12+5, 14+6 | 18−6, 15−7 | 14÷2, 16÷4
        operandMin: 2, operandMax: 25,
        answerMax: 50,
        multiplicationTable: 6,  // Up to 6×6
        divisionDividendMax: 18,
        divisionDivisorMax: 4,
        operations: ['+', '-', '*', '/'],
        description: 'Addition, subtraction with numbers up to 25'
      },
      '2': {
        name: '2nd Grade',
        // Examples: 6×4, 7×3 | 25+18, 36+24 | 45−18, 60−24 | 20÷5, 24÷6
        operandMin: 3, operandMax: 72,
        answerMax: 100,
        multiplicationTable: 8,  // Up to 8×8
        divisionDividendMax: 30,
        divisionDivisorMax: 6,
        operations: ['+', '-', '*', '/'],
        description: 'Arithmetic with numbers up to 100'
      },
      '3': {
        name: '3rd Grade',
        // Examples: 9×6, 8×7, 12×4 | 145+230, 360+125 | 450−230, 600−185 | 36÷6, 42÷7
        operandMin: 4, operandMax: 840,
        answerMax: 1000,
        multiplicationTable: 12,  // Up to 12×12
        divisionDividendMax: 48,
        divisionDivisorMax: 8,
        operations: ['+', '-', '*', '/'],
        description: 'Multi-digit operations up to 1,000'
      },
      '4': {
        name: '4th Grade',
        // Examples: 15×6, 18×7, 24×8 | 1,240+860, 2,350+1,425 | 3,200−1,450 | 84÷7, 96÷8, 144÷12
        operandMin: 6, operandMax: 7200,
        answerMax: 10000,
        multiplicationTable: 24,  // Operands up to 24
        divisionDividendMax: 144,
        divisionDivisorMax: 12,
        operations: ['+', '-', '*', '/'],
        description: 'Multi-digit operations up to 10,000'
      },
      '5': {
        name: '5th Grade',
        // Examples: 25×12, 36×14, 48×15 | 12,450+8,360, 25,800+14,200 | 24,500−8,360 | 250÷5, 360÷9, 420÷6
        operandMin: 12, operandMax: 55000,
        answerMax: 100000,
        multiplicationTable: 48,  // Operands up to 48
        divisionDividendMax: 420,
        divisionDivisorMax: 9,
        operations: ['+', '-', '*', '/'],
        description: 'Advanced multi-digit operations up to 100,000'
      },
      '6': {
        name: '6th Grade',
        // Examples: 60×24, 72×35, 84×40 | 145,000+268,000 | 450,000−185,000 | 600÷6, 720÷8, 900÷9
        operandMin: 24, operandMax: 900000,
        answerMax: 999999,
        multiplicationTable: 84,  // Operands up to 84
        divisionDividendMax: 900,
        divisionDivisorMax: 9,
        operations: ['+', '-', '*', '/'],
        description: 'Complex operations up to 999,999'
      },
      '7': {
        name: '7th Grade',
        // Examples: 120×45, 150×32, 200×18 | 245,000+182,500 | 425,000−182,500 | 1,200÷12, 1,440÷12, 1,800÷15
        operandMin: 18, operandMax: 788000,
        answerMax: 999999,
        multiplicationTable: 200,  // Operands up to 200
        divisionDividendMax: 1800,
        divisionDivisorMax: 15,
        operations: ['+', '-', '*', '/'],
        description: 'Advanced operations up to 999,999'
      },
      '8': {
        name: '8th Grade',
        // Examples: 240×36, 360×45, 480×60 | 524,000+236,000 | 845,000−236,000 | 2,400÷24, 3,600÷30, 4,800÷40
        operandMin: 36, operandMax: 968000,
        answerMax: 999999,
        multiplicationTable: 480,  // Operands up to 480
        divisionDividendMax: 4800,
        divisionDivisorMax: 40,
        operations: ['+', '-', '*', '/'],
        description: 'Complex operations up to 999,999'
      }
    };
    let selectedGradeLevel = null;
    let difficultyType = null; // 'grade-level' or 'custom'

    // Number Mode state
    let numberModeEnabled = false;
    let numberModeValue = CONSTANTS.DEFAULT_NUMBER_MODE_VALUE;
    let numberModeExact = false;

    document.addEventListener('DOMContentLoaded', () => {
      updateStepIndicator();
      updateGridPreview();
      selectDifficulty('medium');
      initializeTemplates();
    });

    // ============================================================================
    // NAVIGATION & UI LOGIC
    // ============================================================================

    /**
     * Centralized state reset function
     * Resets all application state to initial values
     */
    function resetWorksheetState() {
      currentStep = 1;
      selectedOperations = [];
      gridExplicitlySelected = false;
      previewInProgress = false;
      generateInProgress = false;
      pendingGeneration = null;
      config = {
        rows: CONSTANTS.DEFAULT_ROWS,
        cols: CONSTANTS.DEFAULT_COLS,
        min: CONSTANTS.DEFAULT_MIN,
        max: CONSTANTS.DEFAULT_MAX,
        mode: 'random',
        operators: [],
        customCounts: {},
        distribution: 'random-mix'
      };
      currentDifficulty = 'medium';
      difficultySettings = {
        easy: { min: 1, max: 20 },
        medium: { min: 1, max: 50 },
        hard: { min: 5, max: 199 },
        expert: { min: 25, max: 999999 }
      };
      currentSettingsMode = null;
      selectedGradeLevel = null;
      difficultyType = null;
      numberModeEnabled = false;
      numberModeValue = CONSTANTS.DEFAULT_NUMBER_MODE_VALUE;
      numberModeExact = false;
    }

    /**
     * Initialize the worksheet creation flow
     * Resets state and navigates to step 1 (Operations Selection)
     */
    function showCreateWorksheet() {
      const mainMenu = document.getElementById('main-menu');
      const setupScreen = document.getElementById('setup-screen');

      if (!mainMenu || !setupScreen) {
        console.error('Required DOM elements not found');
        return;
      }

      mainMenu.style.display = 'none';
      setupScreen.style.display = 'block';

      // Hide load container if it exists
      const loadContainer = document.getElementById('load-worksheets-container');
      if (loadContainer) {
        loadContainer.style.display = 'none';
        loadContainer.classList.remove('active');
      }

      // Reset state using centralized function
      resetWorksheetState();

      updateStepIndicator();
      showStep(1);
    }

    /**
     * Initialize the worksheet loading flow
     */
    function showLoadWorksheet() {
      const mainMenu = document.getElementById('main-menu');
      const setupScreen = document.getElementById('setup-screen');

      if (!mainMenu || !setupScreen) {
        console.error('Required DOM elements not found');
        return;
      }

      mainMenu.style.display = 'none';
      setupScreen.style.display = 'block';
      currentStep = 1; // Start at step 1 for consistency
      loadSavedWorksheets();
    }

    function goToMainMenu() {
      try {
        const setupScreen = document.getElementById('setup-screen');
        const mainMenu = document.getElementById('main-menu');
        if (setupScreen) setupScreen.style.display = 'none';
        if (mainMenu) mainMenu.style.display = 'block';
      } catch (error) {
        console.error('Error in goToMainMenu:', error);
      }
    }

    function goToStep(step) {
      try {
        // CRITICAL: Before navigating away from step 1, sync operations from UI
        // This ensures we capture any selections before they might be lost
        if (currentStep === 1) {
          syncOperationsFromUI();
        }

        // Skip step 3 when there's only one operation
        if (step === 3 && selectedOperations.length === 1) {
          // If going forward (from step 2), skip to step 4 (Difficulty Type Selection)
          if (currentStep < 3) {
            goToStep(4);
            return;
          }
          // If going backward (from step 4, 5, or 6), skip to step 2
          if (currentStep > 3) {
            goToStep(2);
            return;
          }
        }

        currentStep = step;
        updateStepIndicator();
        showStep(step);

        // CRITICAL: After navigating to step 4, sync operations again
        // This ensures state is correct when user clicks Generate/Preview
        if (step === 4) {
          syncOperationsFromUI();
        }

        // Ensure setup-screen is visible when navigating steps
        const setupScreen = document.getElementById('setup-screen');
        if (setupScreen) setupScreen.style.display = 'block';
        const mainMenu = document.getElementById('main-menu');
        if (mainMenu) mainMenu.style.display = 'none';
      } catch (error) {
        console.error('Error in goToStep:', error);
      }
    }

    /**
     * Shows the specified step and hides others
     * @param {number} step - Step number (1-4)
     */
    function showStep(step) {
      try {
        // CRITICAL: When showing step 1, 4, 5, or 6, ensure operations are synced from UI
        // This prevents state desync issues
        if (step === 1 || step === 4 || step === 5 || step === 6) {
          syncOperationsFromUI();
        }

        // For step 2, check if grid is selected and enable/disable continue button
        if (step === 2) {
          const continueBtn = document.getElementById('step2-continue');
          if (continueBtn) {
            // Check if a template is actually selected
            const hasSelectedTemplate = document.querySelector('.template-item.selected') !== null;
            // Only enable if a template is selected (not just default values)
            continueBtn.disabled = !hasSelectedTemplate;
          }
        }

        // Step 1 is at index 0 (id="step-1"), step 2 is at index 1 (id="step-2"), etc.
        document.querySelectorAll('.step-content').forEach((el) => {
          const stepId = el.id;
          const stepNum = stepId ? parseInt(stepId.replace('step-', '')) : 0;
          el.classList.toggle('active', stepNum === step);
        });

        if (step === 2) {
          const templateSection = document.querySelector('.template-section');
          const customControls = document.getElementById('custom-layout-controls');
          if (templateSection) templateSection.style.display = 'block';
          if (customControls) customControls.style.display = 'none';

          // Restore selected template based on current config.rows and config.cols
          // Only restore if it matches a template (not custom values)
          const rows = config.rows || parseInt(document.getElementById('rows')?.value) || 0;
          const cols = config.cols || parseInt(document.getElementById('cols')?.value) || 0;

          // Clear all selections first
          document.querySelectorAll('.template-item').forEach(item => item.classList.remove('selected'));

          // Restore selection ONLY if user has explicitly selected a grid before
          // This prevents restoring default values (5x6) when user hasn't selected anything
          if (gridExplicitlySelected) {
            const templateMap = {
              '4x5': { rows: 4, cols: 5 },
              '5x6': { rows: 5, cols: 6 },
              '6x7': { rows: 6, cols: 7 },
              '7x8': { rows: 7, cols: 8 }
            };

            // Find and restore matching template
            for (const [key, value] of Object.entries(templateMap)) {
              if (value.rows === rows && value.cols === cols) {
                const templateItem = document.querySelector(`[onclick*="selectTemplate(${rows}, ${cols})"]`);
                if (templateItem) {
                  templateItem.classList.add('selected');
                  break;
                }
              }
            }
          }
        }
        if (step === 5) {
          // CRITICAL: Sync operations before showing grade level step
          syncOperationsFromUI();
          // Update grade level examples if a grade is already selected
          if (selectedGradeLevel) {
            updateGradeLevelExamples(selectedGradeLevel);
          }
          // Grade level mode doesn't use warnings like custom difficulty
        }
        if (step === 6) {
          // CRITICAL: Sync operations before showing custom difficulty step
          syncOperationsFromUI();
          // Update warnings when showing difficulty step
          if (typeof updateDifficultyWarning === 'function') updateDifficultyWarning();
        }
        // Ensure setup-screen is visible
        const setupScreen = document.getElementById('setup-screen');
        if (setupScreen) setupScreen.style.display = 'block';
      } catch (error) {
        console.error('Error in showStep:', error);
      }
    }

    /**
     * Updates the step indicator dots to show current progress
     */
    function updateStepIndicator() {
      const indicator = document.getElementById('step-indicator');
      if (!indicator) return;

      indicator.innerHTML = '';
      // Now we have 4 steps: 1 (Operations), 2 (Layout), 3 (Distribution), 4 (Difficulty)
      for (let i = 1; i <= CONSTANTS.TOTAL_STEPS; i++) {
        const dot = document.createElement('div');
        dot.className = 'step-dot';
        if (i < currentStep) {
          dot.classList.add('completed');
        } else if (i === currentStep) {
          dot.classList.add('active');
        }
        indicator.appendChild(dot);
      }
    }

    // Step 1: Operations
    /**
     * Toggles an operation selection and updates UI state
     * @param {string} op - Operation to toggle ('add', 'sub', 'mul', 'div')
     */
    function toggleOperation(op) {
      const btn = document.querySelector(`.operation-btn.${op}`);
      if (!btn) {
        console.error('Operation button not found for:', op);
        return;
      }

      const index = selectedOperations.indexOf(op);
      if (index > -1) {
        // Deselect operation
        selectedOperations.splice(index, 1);
        btn.classList.remove('selected');
      } else {
        // Select operation (max 4)
        if (selectedOperations.length < 4) {
          selectedOperations.push(op);
          btn.classList.add('selected');
        }
      }

      // Update continue button state
      const continueBtn = document.getElementById('step1-continue');
      if (continueBtn) {
        continueBtn.disabled = selectedOperations.length === 0;
      }

      // Update warnings when operations change
      if (typeof updateDifficultyWarning === 'function') updateDifficultyWarning();
      // Update Number Mode preview when operations change
      if (typeof updateNumberModePreview === 'function') updateNumberModePreview();
    }

    // Step 2: Grid
    function adjustGridValue(field, delta) {
      const input = document.getElementById(field);
      if (!input) return;
      const val = parseInt(input.value) || 0, min = parseInt(input.min) || 1, max = parseInt(input.max) || 30;
      input.value = Math.max(min, Math.min(max, val + delta));
      config.rows = parseInt(document.getElementById('rows').value) || 5;
      config.cols = parseInt(document.getElementById('cols').value) || 6;
      gridExplicitlySelected = true; // Mark that user has explicitly adjusted grid values
      updateGridPreview();
      // Enable continue button when grid values are adjusted
      const continueBtn = document.getElementById('step2-continue');
      if (continueBtn) continueBtn.disabled = false;
    }

    function selectTemplate(rows, cols) {
      document.getElementById('rows').value = rows; document.getElementById('cols').value = cols;
      config.rows = rows;
      config.cols = cols;
      gridExplicitlySelected = true; // Mark that user has explicitly selected a grid
      document.querySelectorAll('.template-item').forEach(item => item.classList.remove('selected'));
      event.currentTarget.classList.add('selected');
      document.getElementById('custom-layout-controls').style.display = 'none';
      document.querySelector('.template-section').style.display = 'block';
      updateGridPreview();
      // Enable continue button when grid is selected
      const continueBtn = document.getElementById('step2-continue');
      if (continueBtn) continueBtn.disabled = false;
    }

    function showCustomLayout() {
      document.querySelector('.template-section').style.display = 'none';
      document.getElementById('custom-layout-controls').style.display = 'flex';
      document.querySelectorAll('.template-item').forEach(item => item.classList.remove('selected'));
    }

    function initializeTemplates() {
      [{ id: 'template-4x5', r: 4, c: 5 }, { id: 'template-5x6', r: 5, c: 6 }, { id: 'template-6x7', r: 6, c: 7 }, { id: 'template-7x8', r: 7, c: 8 }].forEach(t => {
        const grid = document.querySelector(`#${t.id} .template-cells-grid`);
        if (grid) for (let i = 0; i < t.r * t.c; i++) grid.appendChild(document.createElement('div')).className = 'template-cell';
      });
    }

    function updateGridPreview() {
      const rows = parseInt(document.getElementById('rows').value) || 5;
      const cols = parseInt(document.getElementById('cols').value) || 6;
      const preview = document.getElementById('grid-preview');
      preview.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
      preview.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
      preview.innerHTML = '';
      for (let i = 0; i < rows * cols; i++) preview.appendChild(document.createElement('div')).className = 'grid-preview-cell';
      document.getElementById('preview-info').textContent = `${rows * cols} problem${rows * cols !== 1 ? 's' : ''} (${rows} × ${cols})`;
      config.rows = rows; config.cols = cols;
      updateProblemCounter();
      // Update warnings when grid size changes
      if (typeof updateDifficultyWarning === 'function') updateDifficultyWarning();
      // Note: Continue button is enabled by selectTemplate() or adjustGridValue(), not here
    }

    // Step 3: Distribution
    function selectDistribution(mode) {
      config.distribution = mode;
      document.querySelectorAll('.distribution-btn').forEach(btn => btn.classList.remove('selected'));
      event.target.classList.add('selected');
      const panel = document.getElementById('custom-distribution-panel');
      if (mode === 'custom') { panel.style.display = 'block'; if (getAssignedCount() === 0) applyEvenSplit(); }
      else panel.style.display = 'none';
      updateProblemCounter();
    }

    function updateProblemCounter() {
      document.getElementById('total-badge').textContent = config.rows * config.cols;
      if (config.distribution === 'custom') updateProgressBar();
    }

    function adjustCount(type, delta) {
      const el = document.getElementById(`count-${type}`);
      if (el) { el.value = Math.max(0, (parseInt(el.value) || 0) + delta); onCountChange(); }
    }

    function onCountChange() {
      ['add', 'sub', 'mul', 'div'].forEach(t => {
        const row = document.getElementById(`row-${t}`), val = parseInt(document.getElementById(`count-${t}`).value);
        if (row) row.classList.toggle('has-problems', val > 0);
      });
      updateProgressBar(); validateStep3();
    }

    function getAssignedCount() {
      return ['add', 'sub', 'mul', 'div'].reduce((s, t) => s + (parseInt(document.getElementById(`count-${t}`).value) || 0), 0);
    }

    function updateProgressBar() {
      const total = config.rows * config.cols, assigned = getAssignedCount();
      const bar = document.getElementById('progress-fill');
      if (bar) { bar.style.width = `${Math.min(100, (assigned / total) * 100)}%`; bar.classList.toggle('over', assigned > total); }
      document.getElementById('assigned-count').textContent = `${assigned} assigned`;
      document.getElementById('remaining-count').textContent = (total - assigned >= 0 ? `${total - assigned} remaining` : `${Math.abs(total - assigned)} over!`);
    }

    function quickFill(act) {
      if (act === 'clear') ['add', 'sub', 'mul', 'div'].forEach(t => document.getElementById(`count-${t}`).value = 0);
      else {
        const t = act.replace('fill-remaining-', ''), rem = config.rows * config.cols - getAssignedCount();
        const el = document.getElementById(`count-${t}`);
        if (rem > 0 && el) el.value = (parseInt(el.value) || 0) + rem;
      }
      onCountChange();
    }

    function applyEvenSplit() {
      const total = config.rows * config.cols, ops = selectedOperations.length;
      if (ops === 0) return;
      let rem = total % ops, base = Math.floor(total / ops);
      selectedOperations.forEach(op => {
        const el = document.getElementById(`count-${op}`);
        if (el) { el.value = base + (rem > 0 ? 1 : 0); rem--; }
      });
      onCountChange();
    }

    function validateStep3() {
      const btn = document.getElementById('step3-continue');
      if (config.distribution === 'custom' && btn) btn.disabled = getAssignedCount() !== config.rows * config.cols;
    }

    // Validation Helper: Calculate maximum unique problems
    function calculateMaxUniqueProblems(op, min, max) {
      // Calculate the maximum possible unique problems for each operation type
      // NEW SYSTEM: min/max refer to ANSWER range, not operand range

      if (op === '+') {
        // Addition: n1 + n2 where answer (n1 + n2) is in [min, max]
        // For each answer 'a' in [min, max], we need n1 + n2 = a with n1, n2 >= 1
        // Unique pairs (accounting for commutativity): ceil(a/2) for a >= 2
        let count = 0;
        for (let a = min; a <= max; a++) {
          if (a >= 2) {
            // For answer 'a', unique pairs: (1,a-1), (2,a-2), ..., (floor(a/2), ceil(a/2))
            count += Math.floor(a / 2);
          } else if (a === 1) {
            // For answer 1, we need n1 + n2 = 1, but n1, n2 >= 1 means no valid pairs
            // Unless we allow 0, but we'll skip for now
            count += 0;
          }
        }
        return count;
      } else if (op === '-') {
        // Subtraction: n1 - n2 where answer (n1 - n2) is in [min, max] and n1 > n2
        // For each answer 'a' in [min, max], we need n1 - n2 = a with n1 > n2
        // This means n1 = n2 + a, where n2 >= 1 and n1 can be arbitrarily large
        // To keep problems reasonable, we can limit n2 to a reasonable range
        // For practical purposes, if answer is 'a', we can have many pairs
        // Let's count: for each 'a', pairs are (1+a,1), (2+a,2), ..., (max_a, max_a - a)
        // We'll use a practical upper limit for n2 (e.g., 100 or 2*max)
        const maxOperand = Math.max(max * 2, 50); // Reasonable upper limit for operands
        let count = 0;
        for (let a = min; a <= max; a++) {
          if (a >= 1) {
            // For answer 'a', n1 = n2 + a where n2 >= 1 and n1 <= maxOperand
            // So n2 can range from 1 to (maxOperand - a)
            count += Math.max(0, maxOperand - a);
          }
        }
        return count;
      } else if (op === '*') {
        // Multiplication: n1 * n2 where answer (n1 * n2) is in [min, max]
        // For each answer 'a' in [min, max], find all factor pairs (n1, n2) where n1 * n2 = a
        // Unique pairs accounting for commutativity
        let count = 0;
        for (let a = min; a <= max; a++) {
          if (a >= 1) {
            // Count unique factor pairs of 'a'
            const pairs = new Set();
            for (let n1 = 1; n1 * n1 <= a; n1++) {
              if (a % n1 === 0) {
                const n2 = a / n1;
                if (n1 <= n2) {
                  pairs.add(`${n1},${n2}`);
                } else {
                  pairs.add(`${n2},${n1}`);
                }
              }
            }
            count += pairs.size;
          }
        }
        return count;
      } else if (op === '/' || op === '÷') {
        // Division: n1 / n2 where answer (n1 / n2) is in [min, max] with clean division
        // For each answer 'a' in [min, max], we need n1 / n2 = a (clean division)
        // This means n1 = a * n2, where n2 >= 2 (avoid division by 1 for variety)
        // To keep problems reasonable, we can limit n2 to a reasonable range
        const maxDivisor = Math.max(Math.floor(max), 20); // Reasonable upper limit for divisors
        let count = 0;
        for (let a = min; a <= max; a++) {
          if (a >= 1) {
            // For answer 'a', we can have n2 from 2 to maxDivisor
            // Each n2 gives a unique division: (a*n2) / n2 = a
            // But we should only count if the dividend (a*n2) is reasonable
            for (let n2 = 2; n2 <= maxDivisor; n2++) {
              const n1 = a * n2;
              // Only count if dividend is reasonable (e.g., <= 500)
              if (n1 <= 500) {
                count++;
              }
            }
          }
        }
        return count;
      }
      return 0;
    }

    // Step 4: Difficulty
    function updateDifficultyWarning() {
      const warningDisplay = document.getElementById('difficulty-warning-display');
      const warningText = document.getElementById('difficulty-warning-text');

      if (!warningDisplay || !warningText || selectedOperations.length === 0) {
        if (warningDisplay) warningDisplay.style.display = 'none';
        return;
      }

      const totalProblems = config.rows * config.cols;
      const min = config.min;
      const max = config.max;
      let warnings = [];
      const estimatedPerOp = Math.ceil(totalProblems / selectedOperations.length);

      for (const op of selectedOperations) {
        const opSymbol = CONSTANTS.OPERATION_MAP[op];
        const maxUnique = calculateMaxUniqueProblems(opSymbol, min, max);
        const opName = CONSTANTS.OPERATION_NAMES[op];

        if (estimatedPerOp > maxUnique) {
          warnings.push(`${opName} may have repeated problems (only ${maxUnique} unique possible, need ~${estimatedPerOp})`);
        } else if (estimatedPerOp > maxUnique * 0.8) {
          warnings.push(`${opName} variety is limited (${Math.round(estimatedPerOp / maxUnique * 100)}% of max unique)`);
        }
      }

      if (warnings.length > 0) {
        warningText.textContent = warnings.join('. ') + '. Consider increasing the answer range for better variety.';
        warningDisplay.style.display = 'flex';
      } else {
        warningDisplay.style.display = 'none';
      }
    }

    function toggleExplanation() {
      // Specifically target the difficulty-explanation in step-6 (Custom Difficulty page)
      const explanation = document.querySelector('#step-6 .difficulty-explanation');
      const content = document.getElementById('explanation-content');

      if (explanation && content) {
        if (explanation.classList.contains('collapsed')) {
          // Expand
          explanation.classList.remove('collapsed');
          // Set a large max-height for expansion
          content.style.maxHeight = '1000px';
        } else {
          // Collapse
          explanation.classList.add('collapsed');
          // Set max-height to 0 for collapse
          content.style.maxHeight = '0px';
        }
      }
    }

    // Step 4: Difficulty Type Selection
    function selectDifficultyType(type) {
      difficultyType = type;
      if (type === 'grade-level') {
        goToStep(5);
      } else if (type === 'custom') {
        goToStep(6);
      }
    }

    // Step 5: Grade Level Selection
    function selectGradeLevel(grade) {
      selectedGradeLevel = grade;

      // Update dropdown selection
      const dropdown = document.getElementById('grade-level-select');
      if (dropdown) {
        dropdown.value = grade;
      }

      const gradeSettings = gradeLevelSettings[grade];
      if (gradeSettings) {
        // Grade-level mode uses operand ranges, not answer ranges
        // Set placeholder values for validation only (actual generation uses operand ranges)
        config.min = 1;
        config.max = gradeSettings.answerMax;
        updateGradeLevelExamples(grade); // Update examples when grade level changes
      }
    }

    // Function to handle dropdown selection
    function selectGradeLevelFromDropdown(grade) {
      if (grade) {
        selectGradeLevel(grade);
      } else {
        selectedGradeLevel = null;
        const examplesBox = document.getElementById('grade-level-examples');
        if (examplesBox) examplesBox.style.display = 'none';
      }
    }

    // Function to generate and display grade level examples
    function updateGradeLevelExamples(grade) {
      const examplesBox = document.getElementById('grade-level-examples');
      const gradeNameSpan = document.getElementById('selected-grade-name');
      const examplesContent = document.getElementById('grade-examples-content');

      if (!examplesBox || !gradeNameSpan || !examplesContent) return;

      const gradeSettings = gradeLevelSettings[grade];
      if (!gradeSettings) return;

      // Update grade name
      gradeNameSpan.textContent = gradeSettings.name;

      // Map selectedOperations to operation symbols
      const operationMap = {
        'add': '+',
        'sub': '-',
        'mul': '*',
        'div': '/'
      };

      // Filter operations based on user's selected operations
      const availableOperations = gradeSettings.operations || [];
      const selectedOps = selectedOperations.length > 0
        ? selectedOperations.map(op => operationMap[op]).filter(op => op && availableOperations.includes(op))
        : availableOperations; // If no operations selected, show all available

      // Generate example problems based on selected operations for this grade
      const examples = [];
      const operations = selectedOps.length > 0 ? selectedOps : availableOperations;
      const operandMin = gradeSettings.operandMin || 1;
      const operandMax = gradeSettings.operandMax || 100;

      // Generate at least 3 example problems (up to 4)
      let exampleCount = 0;
      const minExamples = 3;
      const maxExamples = Math.min(4, operations.length);

      // First pass: generate one example per operation
      for (let i = 0; i < operations.length && exampleCount < maxExamples; i++) {
        const op = operations[i];
        try {
          // Generate a simple example problem for this operation
          let example = '';

          if (op === '+') {
            const n1 = Math.max(operandMin, Math.min(operandMax, Math.floor(operandMin + (operandMax - operandMin) * 0.3)));
            const n2 = Math.max(operandMin, Math.min(operandMax, Math.floor(operandMin + (operandMax - operandMin) * 0.2)));
            const ans = n1 + n2;
            if (ans <= gradeSettings.answerMax) {
              example = `${n1.toLocaleString('en-US')} + ${n2.toLocaleString('en-US')} = ${ans.toLocaleString('en-US')}`;
            }
          } else if (op === '-') {
            const n1 = Math.max(operandMin + 1, Math.min(operandMax, Math.floor(operandMin + (operandMax - operandMin) * 0.5)));
            const n2 = Math.max(operandMin, Math.min(n1 - 1, Math.floor(operandMin + (operandMax - operandMin) * 0.2)));
            const ans = n1 - n2;
            if (ans >= 1 && ans <= gradeSettings.answerMax) {
              example = `${n1.toLocaleString('en-US')} - ${n2.toLocaleString('en-US')} = ${ans.toLocaleString('en-US')}`;
            }
          } else if (op === '*' || op === '×') {
            // Use multiplication table limits for examples
            const multLimit = gradeSettings.multiplicationTable || gradeSettings.multiplicationTables || 12;
            const n1 = Math.max(1, Math.floor(Math.random() * multLimit) + 1);
            const n2 = Math.max(1, Math.floor(Math.random() * multLimit) + 1);
            const ans = n1 * n2;
            if (ans <= gradeSettings.answerMax) {
              example = `${n1.toLocaleString('en-US')} × ${n2.toLocaleString('en-US')} = ${ans.toLocaleString('en-US')}`;
            }
          } else if (op === '/' || op === '÷') {
            // Use grade-specific division limits for examples
            const divDividendMax = gradeSettings.divisionDividendMax || operandMax;
            const divDivisorMax = gradeSettings.divisionDivisorMax || Math.floor(Math.sqrt(operandMax));
            const n2 = Math.max(2, Math.floor(Math.random() * (divDivisorMax - 1)) + 2);
            const maxQuotient = Math.floor(divDividendMax / n2);
            const ans = Math.max(1, Math.floor(Math.random() * maxQuotient) + 1);
            const n1 = ans * n2;
            if (n1 <= divDividendMax && ans <= gradeSettings.answerMax) {
              example = `${n1.toLocaleString('en-US')} ÷ ${n2.toLocaleString('en-US')} = ${ans.toLocaleString('en-US')}`;
            }
          }

          if (example) {
            examples.push(example);
            exampleCount++;
          }
        } catch (e) {
          console.warn('Error generating example for operation', op, e);
        }
      }

      // Ensure we have at least 3 examples by generating additional ones if needed
      const minExamplesRequired = 3;
      if (examples.length < minExamplesRequired && operations.length > 0) {
        // Generate additional examples by cycling through operations with different offsets
        for (let cycle = 1; examples.length < minExamplesRequired && cycle < 3; cycle++) {
          for (let i = 0; i < operations.length && examples.length < minExamplesRequired; i++) {
            const op = operations[i];
            try {
              let example = '';

              if (op === '+') {
                const n1 = Math.max(operandMin, Math.min(operandMax, Math.floor(operandMin + (operandMax - operandMin) * (0.3 + cycle * 0.2))));
                const n2 = Math.max(operandMin, Math.min(operandMax, Math.floor(operandMin + (operandMax - operandMin) * (0.2 + cycle * 0.15))));
                const ans = n1 + n2;
                if (ans <= gradeSettings.answerMax) {
                  example = `${n1.toLocaleString('en-US')} + ${n2.toLocaleString('en-US')} = ${ans.toLocaleString('en-US')}`;
                }
              } else if (op === '-') {
                const n1 = Math.max(operandMin + 1, Math.min(operandMax, Math.floor(operandMin + (operandMax - operandMin) * (0.5 + cycle * 0.15))));
                const n2 = Math.max(operandMin, Math.min(n1 - 1, Math.floor(operandMin + (operandMax - operandMin) * (0.2 + cycle * 0.15))));
                const ans = n1 - n2;
                if (ans >= 1 && ans <= gradeSettings.answerMax) {
                  example = `${n1.toLocaleString('en-US')} - ${n2.toLocaleString('en-US')} = ${ans.toLocaleString('en-US')}`;
                }
              } else if (op === '*' || op === '×') {
                // Use multiplication table limits
                const multLimit = gradeSettings.multiplicationTable || gradeSettings.multiplicationTables || 12;
                const n1 = Math.max(1, Math.floor(Math.random() * multLimit) + 1);
                const n2 = Math.max(1, Math.floor(Math.random() * multLimit) + 1);
                const ans = n1 * n2;
                if (ans <= gradeSettings.answerMax) {
                  example = `${n1.toLocaleString('en-US')} × ${n2.toLocaleString('en-US')} = ${ans.toLocaleString('en-US')}`;
                }
              } else if (op === '/' || op === '÷') {
                // Use grade-specific division limits
                const divDividendMax = gradeSettings.divisionDividendMax || operandMax;
                const divDivisorMax = gradeSettings.divisionDivisorMax || Math.floor(Math.sqrt(operandMax));
                const n2 = Math.max(2, Math.floor(Math.random() * (divDivisorMax - 1)) + 2);
                const maxQuotient = Math.floor(divDividendMax / n2);
                const ans = Math.max(1, Math.floor(Math.random() * maxQuotient) + 1);
                const n1 = ans * n2;
                if (n1 <= divDividendMax && ans <= gradeSettings.answerMax) {
                  example = `${n1.toLocaleString('en-US')} ÷ ${n2.toLocaleString('en-US')} = ${ans.toLocaleString('en-US')}`;
                }
              }

              if (example && !examples.includes(example)) {
                examples.push(example);
              }
            } catch (e) {
              // Continue if error
            }
          }
        }
      }

      // Display examples with clear, visible separation lines
      if (examples.length >= minExamplesRequired) {
        // Use a larger, more visible separator with increased spacing
        const separator = '<span style="color: #5dade2; font-weight: bold; margin: 0 14px; font-size: 18px; vertical-align: middle;">|</span>';
        examplesContent.innerHTML = examples.slice(0, Math.min(4, examples.length)).join(separator);
        examplesBox.style.display = 'block';
      } else if (examples.length > 0) {
        // If we have examples but less than 3, show what we have
        const separator = '<span style="color: #5dade2; font-weight: bold; margin: 0 14px; font-size: 18px; vertical-align: middle;">|</span>';
        examplesContent.innerHTML = examples.join(separator);
        examplesBox.style.display = 'block';
      } else {
        examplesBox.style.display = 'none';
      }
    }

    function toggleGradeLevelExplanation() {
      const explanation = document.querySelector('#step-5 .difficulty-explanation');
      const content = document.getElementById('grade-level-explanation-content');
      if (explanation && content) {
        if (explanation.classList.contains('collapsed')) {
          explanation.classList.remove('collapsed');
          content.style.maxHeight = '1000px';
        } else {
          explanation.classList.add('collapsed');
          content.style.maxHeight = '0px';
        }
      }
    }

    function updateGradeLevelWarning() {
      const warningDisplay = document.getElementById('grade-level-warning-display');
      const warningText = document.getElementById('grade-level-warning-text');
      if (!warningDisplay || !warningText || selectedOperations.length === 0) return;

      const total = config.rows * config.cols;
      const min = config.min;
      const max = config.max;
      const ops = selectedOperations.length;
      const estimatedPerOp = Math.ceil(total / ops);
      const answerRange = max - min + 1;

      let warnings = [];
      selectedOperations.forEach(op => {
        const opName = CONSTANTS.OPERATION_NAMES[op];
        let maxUnique = 0;
        if (op === 'add') maxUnique = Math.min(answerRange, Math.floor((max - min) * 2));
        else if (op === 'sub') maxUnique = Math.min(answerRange, Math.floor((max - min) * 2));
        else if (op === 'mul') {
          const factors = [];
          for (let i = 1; i <= Math.sqrt(max); i++) {
            for (let j = i; j <= max / i; j++) {
              const product = i * j;
              if (product >= min && product <= max) factors.push([i, j]);
            }
          }
          maxUnique = factors.length;
        } else if (op === 'div') {
          const combos = [];
          for (let divisor = 2; divisor <= Math.sqrt(max); divisor++) {
            for (let quotient = Math.ceil(min / divisor); quotient <= Math.floor(max / divisor); quotient++) {
              const dividend = divisor * quotient;
              if (dividend >= min && dividend <= max) combos.push([dividend, divisor]);
            }
          }
          maxUnique = combos.length;
        }

        if (estimatedPerOp > maxUnique) {
          warnings.push(`${opName}: Approximately ${estimatedPerOp} problems needed, but only ${maxUnique} unique problems possible.`);
        }
      });

      if (warnings.length > 0) {
        warningText.textContent = warnings.join(' ');
        warningDisplay.style.display = 'flex';
      } else {
        warningDisplay.style.display = 'none';
      }
    }

    function selectDifficulty(mode) {
      currentDifficulty = mode;
      document.querySelectorAll('.difficulty-mode').forEach(el => el.classList.remove('selected'));
      document.getElementById(`mode-${mode}`).classList.add('selected');
      const s = difficultySettings[mode]; config.min = s.min; config.max = s.max;
      document.getElementById(`${mode}-range`).textContent = `${s.min}-${s.max}`;
      updateDifficultyWarning();
      updateNumberModePreview(); // Update preview when difficulty changes
    }

    // Number Mode Functions (works with both grade level and custom difficulty pages)
    function toggleNumberMode() {
      // Check which page we're on (grade level uses -grade suffix)
      const enabledCheckbox = document.getElementById('number-mode-enabled') || document.getElementById('number-mode-enabled-grade');
      numberModeEnabled = enabledCheckbox ? enabledCheckbox.checked : false;

      const container = document.getElementById('number-mode-input-container') || document.getElementById('number-mode-input-container-grade');
      const exactContainer = document.getElementById('number-mode-exact-container') || document.getElementById('number-mode-exact-container-grade');

      if (numberModeEnabled) {
        if (container) container.style.display = 'flex';
        if (exactContainer) exactContainer.style.display = 'block';
        updateNumberModePreview();
      } else {
        if (container) container.style.display = 'none';
        if (exactContainer) exactContainer.style.display = 'none';
        const preview = document.getElementById('number-mode-preview') || document.getElementById('number-mode-preview-grade');
        if (preview) preview.textContent = '';
        // Reset exact mode when disabling
        numberModeExact = false;
        const exactCheckbox = document.getElementById('number-mode-exact') || document.getElementById('number-mode-exact-grade');
        if (exactCheckbox) exactCheckbox.checked = false;
      }
    }

    function toggleNumberModeInfo() {
      const section = document.querySelector('.number-mode-section');
      const content = document.getElementById('number-mode-info-content');

      if (section && content) {
        if (section.classList.contains('collapsed')) {
          section.classList.remove('collapsed');
          content.style.maxHeight = '200px';
        } else {
          section.classList.add('collapsed');
          content.style.maxHeight = '0px';
        }
      }
    }

    function updateNumberMode() {
      // Handle both grade level and custom difficulty pages
      const input = document.getElementById('number-mode-value') || document.getElementById('number-mode-value-grade');
      const exactCheckbox = document.getElementById('number-mode-exact') || document.getElementById('number-mode-exact-grade');
      const value = input ? (parseInt(input.value) || 5) : 5;
      numberModeValue = Math.max(1, Math.min(100, value)); // Clamp between 1-100
      if (input) input.value = numberModeValue;
      if (exactCheckbox) numberModeExact = exactCheckbox.checked;
      updateNumberModePreview();
    }

    /**
     * Updates the Number Mode preview examples to show what problems will be generated
     * Educational: Shows clear examples that help users understand the feature
     */
    function updateNumberModePreview() {
      if (!numberModeEnabled) {
        const preview = document.getElementById('number-mode-preview') || document.getElementById('number-mode-preview-grade');
        if (preview) preview.textContent = '';
        return;
      }

      // Handle both grade level and custom difficulty pages
      const preview = document.getElementById('number-mode-preview') || document.getElementById('number-mode-preview-grade');
      if (!preview) return;

      // Get difficulty range - use grade level if selected, otherwise use custom difficulty
      let min, max;
      if (difficultyType === 'grade-level' && selectedGradeLevel) {
        const gradeSettings = gradeLevelSettings[selectedGradeLevel];
        // Grade-level mode uses operand ranges, but for preview we use answerMax as max
        min = gradeSettings ? 1 : 1;
        max = gradeSettings ? gradeSettings.answerMax : 20;
      } else {
        const difficulty = difficultySettings[currentDifficulty];
        min = difficulty ? difficulty.min : 1;
        max = difficulty ? difficulty.max : 20;
      }
      const examples = [];

      // Generate educational examples based on selected operations and mode
      if (numberModeExact) {
        // Exact Number Mode: Show examples where the exact number appears
        if (selectedOperations.includes('add')) {
          examples.push(`${numberModeValue}+${Math.max(1, numberModeValue)}`);
        }
        if (selectedOperations.includes('sub')) {
          examples.push(`${numberModeValue * 2}-${numberModeValue}`);
        }
        if (selectedOperations.includes('mul')) {
          examples.push(`${numberModeValue}×${Math.max(2, Math.floor(numberModeValue / 2))}`);
        }
        if (selectedOperations.includes('div')) {
          examples.push(`${numberModeValue * 2}÷${numberModeValue}`);
        }
      } else {
        // Multiples Mode: Show examples with multiples
        if (selectedOperations.includes('add')) {
          examples.push(`${numberModeValue}+${numberModeValue * 2}`);
        }
        if (selectedOperations.includes('sub')) {
          examples.push(`${numberModeValue * 4}-${numberModeValue * 2}`);
        }
        if (selectedOperations.includes('mul')) {
          examples.push(`${numberModeValue}×${numberModeValue}`);
        }
        if (selectedOperations.includes('div')) {
          examples.push(`${numberModeValue * 6}÷${numberModeValue * 2}`);
        }
      }

      if (examples.length > 0) {
        const previewText = numberModeExact
          ? `→ Exact ${numberModeValue}: ${examples.slice(0, 2).join(', ')}`
          : `→ Multiples of ${numberModeValue}: ${examples.slice(0, 2).join(', ')}`;
        preview.textContent = previewText;
      } else {
        const modeText = numberModeExact
          ? `All problems include the exact number ${numberModeValue}`
          : `All problems use multiples of ${numberModeValue}`;
        preview.textContent = `→ ${modeText}`;
      }
    }

    function openDifficultySettings(mode) {
      currentSettingsMode = mode;
      document.getElementById('settings-modal-title').textContent = `Customize ${mode.charAt(0).toUpperCase() + mode.slice(1)} Mode`;
      document.getElementById('settings-min').value = difficultySettings[mode].min;
      document.getElementById('settings-max').value = difficultySettings[mode].max;
      document.getElementById('difficulty-settings-modal').classList.add('active');
    }

    function closeDifficultySettings() {
      const min = parseInt(document.getElementById('settings-min').value), max = parseInt(document.getElementById('settings-max').value);
      if (min >= 1 && max >= min) {
        difficultySettings[currentSettingsMode] = { min, max };
        document.getElementById(`${currentSettingsMode}-range`).textContent = `${min}-${max}`;
        if (currentDifficulty === currentSettingsMode) { config.min = min; config.max = max; }
        updateDifficultyWarning();
      }
      document.getElementById('difficulty-settings-modal').classList.remove('active');
    }

    // Save/Load Logic
    /**
     * Safely loads saved worksheets from localStorage with error handling
     * @returns {Array} Array of saved worksheets, or empty array on error
     */
    function safeLoadSavedWorksheets() {
      try {
        const stored = localStorage.getItem('savedWorksheets');
        if (!stored) return [];
        const parsed = JSON.parse(stored);
        if (!Array.isArray(parsed)) return [];
        return parsed;
      } catch (error) {
        console.error('Error parsing saved worksheets:', error);
        return [];
      }
    }

    function saveWorksheetSettings() {
      const s = {
        operations: selectedOperations, rows: config.rows, cols: config.cols,
        distribution: config.distribution, difficulty: currentDifficulty, difficultySettings: { ...difficultySettings },
        difficultyType: difficultyType, // Save whether grade-level or custom
        selectedGradeLevel: selectedGradeLevel, // Save selected grade level if applicable
        customCounts: config.distribution === 'custom' ? {
          add: parseInt(document.getElementById('count-add').value) || 0, sub: parseInt(document.getElementById('count-sub').value) || 0,
          mul: parseInt(document.getElementById('count-mul').value) || 0, div: parseInt(document.getElementById('count-div').value) || 0
        } : null,
        numberMode: { enabled: numberModeEnabled, value: numberModeValue, exact: numberModeExact }
      };
      const saved = safeLoadSavedWorksheets(); // Use safe loading helper
      const name = prompt('Enter a name for this worksheet:', `Worksheet ${saved.length + 1}`);
      if (name) {
        s.name = name;
        s.date = new Date().toLocaleDateString();
        saved.push(s);
        try {
          localStorage.setItem('savedWorksheets', JSON.stringify(saved));
          alert('Saved!');
        } catch (error) {
          console.error('Error saving worksheet:', error);
          alert('Error saving worksheet. Please try again.');
        }
      }
    }

    function loadSavedWorksheets() {
      // Use safe loading helper
      const saved = safeLoadSavedWorksheets();

      if (saved.length === 0) {
        alert('No saved worksheets.');
        goToMainMenu();
        return;
      }

      // Create a dedicated container for the load screen (don't overwrite step-1)
      let loadContainer = document.getElementById('load-worksheets-container');
      if (!loadContainer) {
        // Create container if it doesn't exist
        loadContainer = document.createElement('div');
        loadContainer.id = 'load-worksheets-container';
        loadContainer.className = 'step-content';
        const setupScreen = document.getElementById('setup-screen');
        if (setupScreen) {
          setupScreen.insertBefore(loadContainer, setupScreen.firstChild);
        }
      }

      // Build HTML safely using DOM methods to prevent XSS
      loadContainer.innerHTML = '<h2>Load Worksheet</h2><div class="saved-worksheets"></div><div class="step-navigation"><button class="nav-btn back" onclick="goToMainMenu()">Back</button></div>';
      const savedWorksheetsDiv = loadContainer.querySelector('.saved-worksheets');

      saved.forEach((ws, i) => {
        const itemDiv = document.createElement('div');
        itemDiv.className = 'saved-worksheet-item';
        itemDiv.onclick = () => loadWorksheet(i);

        const h4 = document.createElement('h4');
        h4.textContent = ws.name || 'Unnamed Worksheet'; // Use textContent to prevent XSS
        itemDiv.appendChild(h4);

        const p = document.createElement('p');
        const opsText = (ws.operations && Array.isArray(ws.operations)) ? ws.operations.join(', ') : 'Unknown';
        p.textContent = `Ops: ${opsText} | ${ws.rows || '?'}x${ws.cols || '?'}`;
        itemDiv.appendChild(p);

        if (savedWorksheetsDiv) savedWorksheetsDiv.appendChild(itemDiv);
      });

      // Hide all step contents and show load container
      document.querySelectorAll('.step-content').forEach(step => {
        step.classList.remove('active');
        step.style.display = 'none';
      });
      loadContainer.classList.add('active');
      loadContainer.style.display = 'block';
      updateStepIndicator();
    }

    function loadWorksheet(idx) {
      try {
        const savedWorksheets = safeLoadSavedWorksheets();
        if (!savedWorksheets || !savedWorksheets[idx]) {
          alert('Error: Worksheet not found. Please try again.');
          return;
        }

        const ws = savedWorksheets[idx];

        // Hide load container immediately
        const loadContainer = document.getElementById('load-worksheets-container');
        if (loadContainer) {
          loadContainer.style.display = 'none';
          loadContainer.classList.remove('active');
        }

        // Validate and set operations FIRST (before any navigation)
        selectedOperations = ws.operations || [];
        config.rows = ws.rows || 5;
        config.cols = ws.cols || 6;
        config.distribution = ws.distribution || 'random-mix';
        currentDifficulty = ws.difficulty || 'medium';
        difficultySettings = ws.difficultySettings || { easy: { min: 1, max: 20 }, medium: { min: 1, max: 50 }, hard: { min: 5, max: 199 }, expert: { min: 25, max: 999999 } };

        // Restore difficulty type and grade level
        difficultyType = ws.difficultyType || null;
        selectedGradeLevel = ws.selectedGradeLevel || null;
        if (difficultyType === 'grade-level' && selectedGradeLevel) {
          const gradeSettings = gradeLevelSettings[selectedGradeLevel];
          if (gradeSettings) {
            config.min = 1;
            config.max = gradeSettings.answerMax;
          }
        } else if (currentDifficulty) {
          const s = difficultySettings[currentDifficulty];
          if (s) {
            config.min = s.min;
            config.max = s.max;
          }
        }

        // Restore Number Mode settings
        if (ws.numberMode) {
          numberModeEnabled = ws.numberMode.enabled || false;
          numberModeValue = ws.numberMode.value || 5;
          numberModeExact = ws.numberMode.exact || false;
        } else {
          numberModeEnabled = false;
          numberModeValue = 5;
          numberModeExact = false;
        }

        // Determine if step 3 should be skipped
        const shouldSkipStep3 = selectedOperations.length === 1;

        // Step 1: Restore operation buttons
        currentStep = 1;
        updateStepIndicator();
        showStep(1);

        // Wait for step 1 DOM to be ready
        setTimeout(() => {
          try {
            // Clear and restore operation button selections
            const allOperationButtons = document.querySelectorAll('.operation-btn');
            allOperationButtons.forEach(btn => {
              if (btn && btn.classList) {
                btn.classList.remove('selected');
              }
            });

            selectedOperations.forEach(op => {
              const btn = document.querySelector(`.operation-btn.${op}`);
              if (btn && btn.classList) {
                btn.classList.add('selected');
              }
            });

            // Step 2: Restore grid settings
            goToStep(2);

            setTimeout(() => {
              try {
                const rowsInput = document.getElementById('rows');
                const colsInput = document.getElementById('cols');
                if (rowsInput) rowsInput.value = ws.rows || 5;
                if (colsInput) colsInput.value = ws.cols || 6;

                // Restore grid selection if it matches a template
                gridExplicitlySelected = true; // Mark as selected since we're loading saved settings
                if (typeof updateGridPreview === 'function') {
                  updateGridPreview();
                }

                // Step 3: Restore distribution (skip if only one operation)
                if (shouldSkipStep3) {
                  // Skip directly to step 4
                  goToStep(4);

                  // After step 4, navigate to final difficulty step
                  setTimeout(() => {
                    restoreDifficultyAndNumberMode(ws);
                  }, 100);
                } else {
                  // Go to step 3 and restore distribution
                  goToStep(3);

                  setTimeout(() => {
                    try {
                      // Restore distribution selection
                      const distributionButtons = document.querySelectorAll('.distribution-btn');
                      distributionButtons.forEach(btn => {
                        if (btn && btn.classList) {
                          btn.classList.remove('selected');
                        }
                      });

                      const distributionMap = {
                        'random-mix': '🎲 Random Mix',
                        'every-other': '🔄 Every Other Mix',
                        'half-half': '⚖️ Half and Half',
                        'custom': '🎯 Custom'
                      };

                      const targetText = distributionMap[config.distribution];
                      if (targetText) {
                        distributionButtons.forEach(btn => {
                          if (btn && btn.textContent && btn.textContent.includes(targetText)) {
                            if (btn.classList) {
                              btn.classList.add('selected');
                            }
                          }
                        });
                      }

                      // Show/hide custom distribution panel
                      const customPanel = document.getElementById('custom-distribution-panel');
                      if (customPanel) {
                        if (config.distribution === 'custom') {
                          customPanel.style.display = 'block';
                          if (ws.customCounts) {
                            ['add', 'sub', 'mul', 'div'].forEach(t => {
                              const countInput = document.getElementById(`count-${t}`);
                              if (countInput && ws.customCounts[t] !== undefined) {
                                countInput.value = ws.customCounts[t];
                              }
                            });
                            try {
                              if (typeof getAssignedCount === 'function' && getAssignedCount() === 0) {
                                if (typeof applyEvenSplit === 'function') {
                                  applyEvenSplit();
                                }
                              }
                            } catch (e) {
                              // Silently continue if even split fails
                            }
                          }
                        } else {
                          customPanel.style.display = 'none';
                        }
                      }

                      // Update problem counter
                      try {
                        if (typeof updateProblemCounter === 'function') {
                          updateProblemCounter();
                        }
                      } catch (e) {
                        // Silently continue if counter update fails
                      }

                      // Navigate to step 4, then to final difficulty step
                      goToStep(4);

                      setTimeout(() => {
                        restoreDifficultyAndNumberMode(ws);
                      }, 100);
                    } catch (e) {
                      console.error('Error restoring distribution:', e);
                      // Continue to difficulty step even if distribution restore fails
                      goToStep(4);
                      setTimeout(() => {
                        restoreDifficultyAndNumberMode(ws);
                      }, 100);
                    }
                  }, 100);
                }
              } catch (e) {
                console.error('Error restoring grid settings:', e);
                alert('Error loading worksheet settings. Some settings may not be restored.');
              }
            }, 100);
          } catch (e) {
            console.error('Error restoring operations:', e);
            alert('Error loading worksheet settings. Please try again.');
          }
        }, 100);
      } catch (error) {
        console.error('Error loading worksheet:', error);
        alert('Error loading worksheet. Please try again.');
      }
    }

    /**
     * Helper function to restore difficulty settings and number mode
     * Called after navigating to step 4
     */
    function restoreDifficultyAndNumberMode(ws) {
      try {
        // Navigate based on difficulty type
        if (ws.difficultyType === 'grade-level' && ws.selectedGradeLevel) {
          goToStep(5);
          setTimeout(() => {
            if (typeof selectGradeLevel === 'function') {
              selectGradeLevel(ws.selectedGradeLevel);
            }
            // Restore Number Mode for grade level page
            setTimeout(() => {
              restoreNumberModeUI();
            }, 50);
          }, 100);
        } else {
          goToStep(6);
          setTimeout(() => {
            if (typeof selectDifficulty === 'function') {
              selectDifficulty(ws.difficulty || 'medium');
            }
            // Restore Number Mode for custom difficulty page
            setTimeout(() => {
              restoreNumberModeUI();
            }, 50);
          }, 100);
        }
      } catch (e) {
        console.error('Error restoring difficulty settings:', e);
        alert('Error loading difficulty settings. Please check your settings manually.');
      }
    }

    /**
     * Helper function to restore Number Mode UI elements
     */
    function restoreNumberModeUI() {
      try {
        const checkbox = document.getElementById('number-mode-enabled') || document.getElementById('number-mode-enabled-grade');
        const input = document.getElementById('number-mode-value') || document.getElementById('number-mode-value-grade');
        const exactCheckbox = document.getElementById('number-mode-exact') || document.getElementById('number-mode-exact-grade');

        if (checkbox) checkbox.checked = numberModeEnabled;
        if (input) input.value = numberModeValue;
        if (exactCheckbox) exactCheckbox.checked = numberModeExact;

        if (typeof toggleNumberMode === 'function') {
          toggleNumberMode();
        }
        if (typeof updateNumberMode === 'function') {
          updateNumberMode();
        }
      } catch (e) {
        console.error('Error restoring Number Mode UI:', e);
        // Silently continue - Number Mode is optional
      }
    }

    // Preview
    function previewWorksheet() {
      // Prevent multiple simultaneous preview calls
      if (previewInProgress) {
        console.warn('Preview already in progress, please wait...');
        return;
      }

      // CRITICAL: Sync operations from UI before preview
      syncOperationsFromUI();

      // Validate parameters before preview
      const validation = validateWorksheetParameters();
      if (!validation.valid) {
        pendingGeneration = 'preview';
        showValidationNotification(validation);
        return;
      }

      if (validation.warnings.length > 0) {
        pendingGeneration = 'preview';
        showValidationNotification(validation);
        return;
      }

      // Use setTimeout to prevent UI blocking
      previewInProgress = true;
      setTimeout(() => {
        try {
          executePreviewWorksheet();
        } catch (error) {
          console.error('Error in preview:', error);
          alert('There was an error generating the preview. Please try again.');
        } finally {
          previewInProgress = false;
        }
      }, 0);
    }

    function executePreviewWorksheet() {
      // CRITICAL: Ensure operations are synced before preview
      syncOperationsFromUI();

      // CRITICAL: Sync difficulty settings from current difficulty mode or grade level
      // This ensures config.min and config.max match the selected difficulty
      if (difficultyType === 'grade-level' && selectedGradeLevel) {
        const gradeSettings = gradeLevelSettings[selectedGradeLevel];
        if (gradeSettings) {
          // Grade-level mode uses operand ranges, not answer ranges
          // Set placeholder values for validation only (actual generation uses operand ranges)
          config.min = 1;
          config.max = gradeSettings.answerMax;
        }
      } else {
        const currentDifficultySettings = difficultySettings[currentDifficulty];
        if (currentDifficultySettings) {
          config.min = currentDifficultySettings.min;
          config.max = currentDifficultySettings.max;
        }
      }

      const container = document.getElementById('preview-worksheet');
      const tempConfig = { ...config, operators: selectedOperations.map(op => CONSTANTS.OPERATION_MAP[op]) };
      if (config.distribution === 'custom') {
        tempConfig.customCounts = {};
        ['add', 'sub', 'mul', 'div'].forEach(t => tempConfig.customCounts[{ add: '+', sub: '-', mul: '*', div: '/' }[t]] = parseInt(document.getElementById(`count-${t}`).value) || 0);
        tempConfig.mode = 'custom';
      } else tempConfig.mode = config.distribution === 'random-mix' ? 'random' : config.distribution;

      calculateOptimalPrintSpacing(tempConfig.rows, tempConfig.cols);
      document.documentElement.style.setProperty('--print-cols', tempConfig.cols);

      const problems = generateProblemsList(tempConfig, tempConfig.rows * tempConfig.cols);

      let html = `<div class="preview-worksheet-container"><div class="header"><h1>Math Worksheet</h1><p><label>Name:</label><input type="text"><label>Date:</label><input type="text"></p></div>`;
      html += `<div class="problems-grid" style="grid-template-columns: repeat(${tempConfig.cols}, var(--print-problem-width, 1.2in)); gap: var(--print-gap, 0.1in);">`;
      problems.forEach((p, i) => {
        const formatted = formatProblemForHTML(p, i);
        html += `<div class="${formatted.problemClass}" data-number="#${i + 1}" data-answer="${formatted.answer}" style="width: var(--print-problem-width); height: var(--print-problem-height);"><div class="math-expression">${formatted.expressionHTML}</div><input type="number" placeholder="?"></div>`;
      });
      html += `</div></div>`;
      container.innerHTML = html;
      document.getElementById('preview-modal').classList.add('active');
      setTimeout(calculateOptimalPreviewScale, 100);
    }

    function calculateOptimalPreviewScale() {
      const container = document.querySelector('.preview-worksheet-container'), content = document.querySelector('.preview-content');
      if (!container || !content) return;
      const scale = Math.min((content.offsetWidth - 40) / 816, (content.offsetHeight - 100) / 1056, 0.95);
      container.style.transform = `scale(${scale})`;
    }

    function closePreview() { document.getElementById('preview-modal').classList.remove('active'); }
    window.addEventListener('resize', () => { if (document.getElementById('preview-modal').classList.contains('active')) setTimeout(calculateOptimalPreviewScale, 150); });

    // Validation & Smart Assistant Functions

    /**
     * Syncs selectedOperations array from the UI state
     * This ensures operations are always up-to-date even if state gets out of sync
     * Buttons are always in DOM (just hidden via CSS when step not active)
     * @returns {Array} The synced selectedOperations array
     */
    function syncOperationsFromUI() {
      const operations = [];
      // Buttons are always in DOM (hidden via CSS when step not active)
      // querySelectorAll will find them even if hidden
      const operationButtons = document.querySelectorAll('.operation-btn');

      // If buttons aren't found at all, something is wrong - preserve state
      if (operationButtons.length === 0) {
        console.warn('Operation buttons not found in DOM - preserving existing operations');
        return selectedOperations;
      }

      // Extract selected operations from UI buttons
      operationButtons.forEach(btn => {
        if (btn && btn.classList && btn.classList.contains('selected')) {
          // Extract operation from button class (e.g., 'operation-btn add' -> 'add')
          const classes = btn.className.split(' ');
          const opClass = classes.find(cls => ['add', 'sub', 'mul', 'div'].includes(cls));
          if (opClass && !operations.includes(opClass)) {
            operations.push(opClass);
          }
        }
      });

      // CRITICAL LOGIC: 
      // - If on step 1: Always sync to match UI (user can change selections)
      // - If on other steps: 
      //   * If UI shows operations: Sync them (UI is source of truth)
      //   * If UI shows NO operations but we have state: Preserve state (buttons hidden but state valid)
      //   * If UI shows NO operations and NO state: Clear (shouldn't happen)
      if (currentStep === 1) {
        // On step 1: always sync to match UI exactly (user is actively selecting)
        selectedOperations = operations;
      } else {
        // On other steps: preserve state if UI shows no selections but we have state
        if (operations.length > 0) {
          // UI shows selected operations - sync them (UI is source of truth)
          selectedOperations = operations;
        } else if (selectedOperations.length > 0) {
          // UI shows no selections but we have state - preserve state
          // This happens when step 1 is hidden (buttons exist but 'selected' class might not be visible)
          // State is still valid from when user selected on step 1
          return selectedOperations;
        } else {
          // No operations in UI and no state - clear (shouldn't happen, but be safe)
          selectedOperations = operations;
        }
      }

      return selectedOperations;
    }

    /**
     * Validates worksheet parameters before generation
     * @returns {Object} Validation result with valid flag, errors, and warnings
     */
    function validateWorksheetParameters() {
      // CRITICAL: Sync operations from UI state before validation
      // This ensures we always have the correct operations even if state was cleared
      syncOperationsFromUI();

      const totalProblems = config.rows * config.cols;
      const min = config.min;
      const max = config.max;
      const warnings = [];
      const errors = [];

      // Check if any operations are selected (after syncing from UI)
      if (selectedOperations.length === 0) {
        errors.push('Please select at least one math operation.');
        return { valid: false, errors, warnings: [] };
      }

      // Check difficulty range (answer range)
      if (min >= max) {
        errors.push('Minimum answer must be less than maximum answer.');
        return { valid: false, errors, warnings: [] };
      }

      if (min < 1) {
        errors.push('Minimum answer must be at least 1.');
        return { valid: false, errors, warnings: [] };
      }

      // Check custom distribution counts
      if (config.distribution === 'custom') {
        const customCounts = {
          '+': parseInt(document.getElementById('count-add')?.value) || 0,
          '-': parseInt(document.getElementById('count-sub')?.value) || 0,
          '*': parseInt(document.getElementById('count-mul')?.value) || 0,
          '/': parseInt(document.getElementById('count-div')?.value) || 0
        };
        const totalCustom = customCounts['+'] + customCounts['-'] + customCounts['*'] + customCounts['/'];
        if (totalCustom !== totalProblems) {
          errors.push(`Custom distribution total (${totalCustom}) must equal total problems (${totalProblems}).`);
          return { valid: false, errors, warnings: [] };
        }
      }

      // Check each selected operation for maximum unique problems
      for (const op of selectedOperations) {
        const opSymbol = CONSTANTS.OPERATION_MAP[op];
        const maxUnique = calculateMaxUniqueProblems(opSymbol, min, max);
        const opName = CONSTANTS.OPERATION_NAMES[op];

        if (config.distribution === 'custom') {
          const count = parseInt(document.getElementById(`count-${op}`)?.value) || 0;
          if (count > maxUnique) {
            errors.push(`${opName}: Requested ${count} problems, but only ${maxUnique} unique problems are possible with answer range ${min}-${max}. Please increase the answer range or reduce the problem count.`);
          } else if (count > maxUnique * 0.8) {
            warnings.push(`${opName}: Requesting ${count} problems (${Math.round(count / maxUnique * 100)}% of maximum unique). You may see some repeated problems.`);
          }
        } else {
          // For non-custom distributions, estimate problems per operation
          const estimatedProblems = Math.ceil(totalProblems / selectedOperations.length);
          if (estimatedProblems > maxUnique) {
            errors.push(`${opName}: With ${totalProblems} total problems and ${selectedOperations.length} operation(s), approximately ${estimatedProblems} ${opName.toLowerCase()} problems are needed, but only ${maxUnique} unique problems are possible with answer range ${min}-${max}. Please increase the answer range (e.g., ${min}-${Math.max(max + 10, max * 2)}) or reduce the grid size.`);
          } else if (estimatedProblems > maxUnique * 0.8) {
            warnings.push(`${opName}: Approximately ${estimatedProblems} problems needed (${Math.round(estimatedProblems / maxUnique * 100)}% of maximum unique). You may see some repeated problems. Consider increasing the answer range to ${min}-${Math.max(max + 5, Math.ceil(max * 1.5))} for better variety.`);
          }
        }
      }

      return { valid: errors.length === 0, errors, warnings };
    }

    function showValidationNotification(validation) {
      // Remove any existing notification modal
      const existing = document.getElementById('validation-notification-modal');
      if (existing) {
        existing.remove();
      }

      // Create notification modal
      const modal = document.createElement('div');
      modal.id = 'validation-notification-modal';
      modal.className = 'validation-modal';
      modal.innerHTML = `
        <div class="validation-modal-content">
          <div class="validation-header">
            <h3>${validation.errors.length > 0 ? '⚠️ Configuration Error' : 'ℹ️ Important Notice'}</h3>
            <button class="modal-close-btn" onclick="closeValidationNotification()">×</button>
          </div>
          <div class="validation-body">
            ${validation.errors.length > 0 ? `
              <div class="validation-section errors">
                <h4>Errors Found:</h4>
                <ul>
                  ${validation.errors.map(e => `<li>${e}</li>`).join('')}
                </ul>
                <p class="validation-note"><strong>Please fix these errors before generating the worksheet.</strong></p>
              </div>
            ` : ''}
            ${validation.warnings.length > 0 ? `
              <div class="validation-section warnings">
                <h4>⚠️ Recommendations:</h4>
                <ul>
                  ${validation.warnings.map(w => `<li>${w}</li>`).join('')}
                </ul>
                <p class="validation-note">You can still generate the worksheet, but you may see repeated problems. For the best variety, consider adjusting your settings.</p>
              </div>
            ` : ''}
          </div>
          <div class="validation-actions">
            ${validation.errors.length > 0 ? `
              <button class="validation-btn primary" onclick="closeValidationNotification()">I'll Fix the Settings</button>
            ` : `
              <button class="validation-btn secondary" onclick="closeValidationNotification()">Cancel</button>
              <button class="validation-btn primary" onclick="proceedWithGeneration()">Generate Anyway</button>
            `}
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      setTimeout(() => modal.classList.add('active'), 10);
    }

    function closeValidationNotification() {
      const modal = document.getElementById('validation-notification-modal');
      if (modal) {
        modal.classList.remove('active');
        setTimeout(() => modal.remove(), 300);
      }
    }

    function proceedWithGeneration() {
      closeValidationNotification();
      if (pendingGeneration === 'generate') {
        if (!generateInProgress) {
          generateInProgress = true;
          try {
            executeGenerateWorksheet();
          } finally {
            generateInProgress = false;
          }
        }
      } else if (pendingGeneration === 'preview') {
        // Use setTimeout to prevent UI blocking
        if (!previewInProgress) {
          previewInProgress = true;
          setTimeout(() => {
            try {
              executePreviewWorksheet();
            } catch (error) {
              console.error('Error in preview:', error);
              alert('There was an error generating the preview. Please try again.');
            } finally {
              previewInProgress = false;
            }
          }, 0);
        }
      }
      pendingGeneration = null;
    }

    // ============================================================================
    // WORKSHEET GENERATION CORE
    // ============================================================================

    /**
     * Main worksheet generation function
     * Validates parameters and initiates generation
     */
    function generateWorksheet() {
      // CRITICAL: Sync operations from UI before generating
      syncOperationsFromUI();

      // CRITICAL: Set config.min and config.max based on difficulty type
      // NOTE: For grade-level mode, we use capped values to prevent freeze in validation loops
      // The actual grade-level constraints are enforced by generateGradeLevelProblem via useGradeLevel flag
      if (difficultyType === 'grade-level' && selectedGradeLevel) {
        // Grade Level mode: use capped values for validation loops
        // The generateGradeLevelProblem function will use the actual grade settings
        const gradeSettings = gradeLevelSettings[selectedGradeLevel];
        if (gradeSettings) {
          config.min = gradeSettings.operandMin || 1;
          // Cap config.max to prevent freeze in fallback/validation loops
          // The actual problem difficulty is controlled by generateGradeLevelProblem
          config.max = Math.min(1000, gradeSettings.operandMax);
        }
      } else {
        // Custom difficulty mode: use difficultySettings
        const currentDifficultySettings = difficultySettings[currentDifficulty];
        if (currentDifficultySettings) {
          config.min = currentDifficultySettings.min;
          config.max = currentDifficultySettings.max;
        }
      }

      // Map operation names to symbols
      config.operators = selectedOperations.map(op => CONSTANTS.OPERATION_MAP[op]);

      // Handle custom distribution
      if (config.distribution === 'custom') {
        config.customCounts = {
          '+': parseInt(document.getElementById('count-add')?.value) || 0,
          '-': parseInt(document.getElementById('count-sub')?.value) || 0,
          '*': parseInt(document.getElementById('count-mul')?.value) || 0,
          '/': parseInt(document.getElementById('count-div')?.value) || 0
        };
        config.mode = 'custom';
      } else {
        config.mode = config.distribution === 'random-mix' ? 'random' : config.distribution;
      }

      // Validate parameters before generation
      const validation = validateWorksheetParameters();
      if (!validation.valid || validation.warnings.length > 0) {
        pendingGeneration = 'generate';
        showValidationNotification(validation);
        return;
      }

      generateInProgress = true;
      try {
        executeGenerateWorksheet();
      } finally {
        generateInProgress = false;
      }
    }

    /**
     * Executes the worksheet generation process
     */
    function executeGenerateWorksheet() {
      try {
        // CRITICAL: Final sync of operations before generation
        syncOperationsFromUI();

        // Final validation - ensure operations are set
        if (selectedOperations.length === 0) {
          console.error('No operations selected - syncing from UI');
          syncOperationsFromUI();
          if (selectedOperations.length === 0) {
            alert('Error: No math operations selected. Please go back to Step 1 and select at least one operation.');
            return;
          }
        }

        calculateOptimalPrintSpacing(config.rows, config.cols);
        document.documentElement.style.setProperty('--print-cols', config.cols);

        openWorksheetInNewTab();

        // Keep setup-screen visible after generating worksheet
        const setupScreen = document.getElementById('setup-screen');
        const mainMenu = document.getElementById('main-menu');
        if (setupScreen) setupScreen.style.display = 'block';
        if (mainMenu) mainMenu.style.display = 'none';
        showStep(currentStep);
      } catch (error) {
        console.error('Error generating worksheet:', error);
        alert('There was an error generating the worksheet. Please try again.');
      }
    }

    // ============================================================================
    // PROBLEM GENERATION HELPERS
    // ============================================================================

    /**
     * Creates a normalized key for a problem to detect duplicates
     * Handles commutative operations (addition, multiplication) and multi-step equations
     * @param {Object} p - Problem object
     * @param {string} op - Operation symbol
     * @returns {string} Normalized key for duplicate detection
     */
    /**
     * Creates a normalized key for a problem to detect duplicates
     * Handles commutative operations (addition, multiplication)
     * @param {Object} p - Problem object
     * @param {string} op - Operation symbol
     * @returns {string} Normalized key for duplicate detection
     */
    function getProblemKey(p, op) {
      // For addition and multiplication (commutative), normalize by sorting numbers
      if (op === '+' || op === '*') {
        const sorted = [p.n1, p.n2].sort((a, b) => a - b);
        return `${op}${sorted[0]}${sorted[1]}`;
      }

      // For subtraction and division (not commutative), use exact order
      return `${op}${p.n1}${p.n2}`;
    }

    /**
     * Calculates the correct answer for a problem and validates it
     * @param {Object} p - Problem object
     * @param {string} op - Operation symbol
     * @returns {number|null} Correct answer or null if invalid
     */
    function calculateAnswer(p, op) {
      if (!p || !op) return null;

      if (op === '+') {
        return p.n1 + p.n2;
      } else if (op === '-') {
        const answer = p.n1 - p.n2;
        // Ensure no negative results
        if (p.n1 < p.n2 || answer < 0) {
          return null;
        }
        return answer;
      } else if (op === '*') {
        return p.n1 * p.n2;
      } else if (op === '/' || op === '÷') {
        if (p.n2 === 0) {
          return null; // Division by zero
        }
        const answer = Math.floor(p.n1 / p.n2);
        // Ensure clean division with no remainder
        if (p.n1 % p.n2 !== 0 || p.n1 !== answer * p.n2) {
          return null;
        }
        return answer;
      }

      return null;
    }

    /**
     * Formats a problem for HTML rendering (single-step only)
     * @param {Object} p - Problem object
     * @param {number} index - Problem index (0-based)
     * @returns {Object} Object with expressionHTML, problemClass, and answer
     */
    /**
     * Format a number with comma separators for thousands
     * @param {number} num - Number to format
     * @returns {string} Formatted number string with commas
     */
    function formatNumberWithCommas(num) {
      if (typeof num !== 'number' || isNaN(num)) return String(num);
      return num.toLocaleString('en-US');
    }

    function formatProblemForHTML(p, index) {
      // Single-step: vertical layout (e.g., "5\n+ 3")
      // Format numbers with comma separators for thousands
      const formattedN1 = formatNumberWithCommas(p.n1);
      const formattedN2 = formatNumberWithCommas(p.n2);
      const expressionHTML = `${formattedN1}\n${p.sym} ${formattedN2}<span class="operator-line"></span>`;

      return {
        expressionHTML,
        problemClass: 'problem',
        answer: p.ans || 0
      };
    }

    /**
     * Generates a list of unique math problems based on configuration
     * @param {Object} cfg - Configuration object with min, max, operators, mode, etc.
     * @param {number} total - Total number of problems to generate
     * @returns {Array} Array of problem objects
     */
    function generateProblemsList(cfg, total) {
      // Safety check: prevent excessive problem generation that could freeze the browser
      if (total > 200) {
        console.warn('Requested problem count exceeds safe limit (200). Capping at 200.');
        total = 200;
      }

      // Generate a unique random seed for this worksheet generation
      // This ensures each worksheet generation produces different problems
      const generationSeed = Math.floor(Math.random() * CONSTANTS.SEED_RANGE) + (Date.now() % CONSTANTS.SEED_RANGE);

      // Add timeout protection for very large problem sets
      const generationStartTime = Date.now();
      const MAX_GENERATION_TIME = 10000; // 10 seconds max

      // NUMBER MODE: Prepare settings for problem generation
      const numberModeSettings = {
        enabled: numberModeEnabled,
        value: numberModeValue,
        exact: numberModeExact
      };

      // Helper function to get a seeded random number for consistent but varied generation
      let seedCounter = generationSeed;
      function seededRandom() {
        seedCounter = (seedCounter * CONSTANTS.SEED_MULTIPLIER + CONSTANTS.SEED_ADDEND) % CONSTANTS.SEED_MODULUS;
        return seedCounter / CONSTANTS.SEED_MODULUS;
      }

      const pool = [];
      if (cfg.mode === 'custom') {
        for (let op in cfg.customCounts) for (let i = 0; i < cfg.customCounts[op]; i++) pool.push(op);
        shuffleArray(pool);
      }
      else if (cfg.mode === 'every-other') {
        // Add some randomness to the starting operator
        const startOffset = Math.floor(seededRandom() * cfg.operators.length);
        for (let i = 0; i < total; i++) {
          pool.push(cfg.operators[(startOffset + i) % cfg.operators.length]);
        }
      }
      else if (cfg.mode === 'half-half') {
        const half = Math.floor(total / 2);
        for (let i = 0; i < half; i++) pool.push(cfg.operators[0]);
        for (let i = 0; i < total - half; i++) pool.push(cfg.operators[1] || cfg.operators[0]);
        shuffleArray(pool);
      }
      else {
        // Random mode: use seeded random for more variety
        for (let i = 0; i < total; i++) {
          pool.push(cfg.operators[Math.floor(seededRandom() * cfg.operators.length)]);
        }
      }

      const problems = [];
      const usedKeys = new Set(); // Track normalized problem keys
      const usedAnswers = new Map(); // Track answers to ensure variety (used for smart answer selection)

      // Check if we're using grade-level mode
      const useGradeLevel = difficultyType === 'grade-level' && selectedGradeLevel;
      let maxSameAnswer, answerRange;

      if (useGradeLevel) {
        // Grade-level mode: Use operand ranges, not answer ranges
        const gradeSettings = gradeLevelSettings[selectedGradeLevel];
        answerRange = gradeSettings.answerMax - 1 + 1; // Approximate answer range
        maxSameAnswer = Math.max(1, Math.ceil(total / Math.max(answerRange / 3, 5)));
      } else {
        // Custom difficulty mode: Use answer ranges
        answerRange = cfg.max - cfg.min + 1;
        maxSameAnswer = Math.max(1, Math.ceil(total / Math.max(answerRange / 3, 5)));
      }

      const usedDivisionCombos = new Set(); // Track division combinations (n1÷n2) for better variety

      for (let i = 0; i < total; i++) {
        // Timeout check to prevent freezing
        if (Date.now() - generationStartTime > MAX_GENERATION_TIME) {
          console.warn('Problem generation taking too long, using fallback for remaining problems');
          // Generate simple fallback problems for remaining slots - RESPECT NUMBER MODE
          while (problems.length < total) {
            const remainingOp = pool[problems.length] || pool[0];
            let fallbackP;
            const nmVal = numberModeSettings.enabled && numberModeSettings.exact ? numberModeSettings.value : 1;
            if (remainingOp === '+') {
              fallbackP = { n1: nmVal, n2: 1 + (problems.length % 10), ans: nmVal + 1 + (problems.length % 10), sym: '+', op: remainingOp };
            } else if (remainingOp === '-') {
              const n2Val = Math.max(1, Math.floor(nmVal / 2) + (problems.length % 5));
              fallbackP = { n1: nmVal + n2Val, n2: nmVal, ans: n2Val, sym: '−', op: remainingOp };
            } else if (remainingOp === '*' || remainingOp === '×') {
              fallbackP = { n1: nmVal, n2: 1 + (problems.length % 10), ans: nmVal * (1 + (problems.length % 10)), sym: '×', op: remainingOp };
            } else {
              const ansVal = 1 + (problems.length % 10);
              fallbackP = { n1: nmVal * ansVal, n2: nmVal, ans: ansVal, sym: '÷', op: remainingOp };
            }
            problems.push(fallbackP);
          }
          break;
        }

        const op = pool[i];
        let p, key, attempts = 0;
        let validProblem = false;

        // Generate single-step equation
        while (!validProblem && attempts < CONSTANTS.MAX_GENERATION_ATTEMPTS) {
          const uniqueOffset = attempts + i * 10 + (generationSeed % 1000);

          // Use grade-level generator if in grade-level mode, otherwise use custom difficulty generator
          if (useGradeLevel) {
            p = generateGradeLevelProblem(op, selectedGradeLevel, uniqueOffset, usedAnswers, numberModeSettings);
          } else {
            p = generateProblemData(op, cfg.min, cfg.max, uniqueOffset, usedAnswers, numberModeSettings);
          }

          // Validate answer is mathematically correct
          const correctAnswer = calculateAnswer(p, op);
          if (correctAnswer === null) {
            attempts++;
            continue; // Invalid problem - regenerate
          }

          // Verify answer matches
          if (p.ans !== correctAnswer) {
            p.ans = correctAnswer;
          }

          key = getProblemKey(p, op);
          attempts++;

          // Check for duplicates
          if (usedKeys.has(key)) {
            continue;
          }

          // For division, check exact combination
          if ((op === '÷' || op === '/') && usedDivisionCombos.has(`${p.n1}÷${p.n2}`)) {
            continue;
          }

          // Check answer variety
          const answerCount = usedAnswers.get(p.ans) || 0;
          if (answerCount >= maxSameAnswer) {
            continue;
          }

          // All checks passed
          validProblem = true;
        }

        // Fallback: If we couldn't find a unique problem, try smarter strategies
        if (!validProblem) {
          let fallbackAttempts = 0;
          while (fallbackAttempts < CONSTANTS.MAX_FALLBACK_ATTEMPTS) {
            // Use problem index AND generation seed to ensure each problem tries different combinations
            // The generation seed ensures uniqueness across different worksheet generations
            // Pass answer usage map for smarter fallback generation
            const fallbackOffset = fallbackAttempts + i * 20 + (generationSeed % 2000);
            p = useGradeLevel
              ? generateGradeLevelProblem(op, selectedGradeLevel, fallbackOffset, usedAnswers, numberModeSettings)
              : generateProblemData(op, cfg.min, cfg.max, fallbackOffset, usedAnswers, numberModeSettings);

            // For division, add extra randomization to ensure variety
            if (op === '÷' || op === '/') {
              // Try different divisors and quotients with TRUE RANDOMNESS
              // Use random selection to ensure we use ALL numbers in range
              // FIXED: Cap divisor range to prevent freeze on high grade levels
              const maxDivisorForRange = Math.min(1000, cfg.max, Math.max(12, Math.floor(cfg.max / 3)));
              const divisors = [];
              // Generate valid divisors from 2 to maxDivisorForRange (capped at 1000 to prevent freeze)
              for (let d = 2; d <= maxDivisorForRange; d++) {
                const maxQ = Math.floor(cfg.max / d);
                const minQ = Math.max(1, Math.ceil(cfg.min / d));
                // Only include divisors that can produce at least one valid division
                if (maxQ >= minQ && maxQ >= 1) {
                  divisors.push(d);
                }
              }

              if (divisors.length > 0) {
                // Use TRULY RANDOM selection instead of systematic patterns
                const randomDivisorIndex = getRandomInt(0, divisors.length - 1);
                p.n2 = divisors[randomDivisorIndex];
                const maxQuotient = Math.floor(cfg.max / p.n2);
                const minQuotient = Math.max(1, Math.ceil(cfg.min / p.n2));
                if (maxQuotient >= minQuotient) {
                  // Use TRUE RANDOM selection from entire quotient range
                  // This ensures we use ALL possible quotients, not just patterns
                  // For range 20-100 with divisor 5: quotients can be 4-20, giving n1 = 20-100
                  p.ans = getRandomInt(minQuotient, maxQuotient);
                  p.n1 = p.ans * p.n2;
                  if (p.n1 >= cfg.min && p.n1 <= cfg.max) {
                    // Valid division generated
                  } else {
                    fallbackAttempts++;
                    continue;
                  }
                } else {
                  fallbackAttempts++;
                  continue;
                }
              } else {
                fallbackAttempts++;
                continue;
              }
            }

            key = getProblemKey(p, op);

            // Check if this is still a duplicate (check both key and division combo)
            if (!usedKeys.has(key)) {
              // For division, also check the exact combination
              if ((op === '÷' || op === '/') && usedDivisionCombos.has(`${p.n1}÷${p.n2}`)) {
                fallbackAttempts++;
                continue; // This division combo was already used
              }

              // Verify answer
              if (op === '+') {
                p.ans = p.n1 + p.n2;
              } else if (op === '-') {
                if (p.n1 < p.n2) {
                  const temp = p.n1;
                  p.n1 = p.n2;
                  p.n2 = temp;
                }
                p.n2 = Math.min(p.n2, p.n1 - 1);
                p.ans = p.n1 - p.n2;
              } else if (op === '*') {
                p.ans = p.n1 * p.n2;
              } else { // Division
                if (p.n2 === 0) p.n2 = 2;
                p.ans = Math.floor(p.n1 / p.n2);
                p.n1 = p.ans * p.n2; // Ensure clean division
              }

              // Re-generate key after potential recalculation and check again
              key = getProblemKey(p, op);

              // Final duplicate check after recalculation
              if (!usedKeys.has(key) &&
                (!(op === '÷' || op === '/') || !usedDivisionCombos.has(`${p.n1}÷${p.n2}`))) {
                validProblem = true;
                break;
              } else {
                // Recalculation created a duplicate, try again
                fallbackAttempts++;
                continue;
              }
            }
            fallbackAttempts++;
          }

          // If still no valid problem after extensive attempts, try one more aggressive approach
          // BUT ensure it's still unique - never allow duplicates
          if (!validProblem) {
            // Try generating with maximum randomization, but still check for duplicates
            let finalAttempts = 0;
            while (!validProblem && finalAttempts < CONSTANTS.MAX_FALLBACK_ATTEMPTS * 2) {
              const finalOffset = finalAttempts + i * 100 + (generationSeed % 10000);
              p = useGradeLevel
                ? generateGradeLevelProblem(op, selectedGradeLevel, finalOffset, usedAnswers, numberModeSettings)
                : generateProblemData(op, cfg.min, cfg.max, finalOffset, usedAnswers, numberModeSettings);

              // Verify answer
              if (op === '+') {
                p.ans = p.n1 + p.n2;
              } else if (op === '-') {
                if (p.n1 < p.n2) {
                  const temp = p.n1;
                  p.n1 = p.n2;
                  p.n2 = temp;
                }
                p.n2 = Math.min(p.n2, p.n1 - 1);
                p.ans = p.n1 - p.n2;
              } else if (op === '*') {
                p.ans = p.n1 * p.n2;
              } else { // Division
                if (p.n2 === 0) p.n2 = 2;
                p.ans = Math.floor(p.n1 / p.n2);
                p.n1 = p.ans * p.n2; // Ensure clean division
              }

              key = getProblemKey(p, op);

              // CRITICAL: Check for duplicates - never allow the same problem twice
              if (!usedKeys.has(key)) {
                // For division, also check exact combination
                if ((op === '÷' || op === '/')) {
                  if (!usedDivisionCombos.has(`${p.n1}÷${p.n2}`) && !usedDivisionCombos.has(`${p.n1}/${p.n2}`)) {
                    validProblem = true;
                    break;
                  }
                } else {
                  validProblem = true;
                  break;
                }
              }

              finalAttempts++;
            }

            // If STILL no valid unique problem found, generate a simple fallback problem
            // We MUST always generate exactly the requested number of problems
            if (!validProblem) {
              console.warn(`Could not generate unique problem ${i + 1} for operation ${op} with constraints. Using fallback...`);
              // Generate a simple fallback problem that meets basic requirements - RESPECT NUMBER MODE
              const nmVal = numberModeSettings.enabled && numberModeSettings.exact ? numberModeSettings.value : 1;
              const variation = (i % 10) + 1;

              if (useGradeLevel) {
                const gradeSettings = gradeLevelSettings[selectedGradeLevel];
                if (op === '+') {
                  p = { n1: nmVal, n2: variation, ans: nmVal + variation, sym: '+' };
                } else if (op === '-') {
                  p = { n1: nmVal + variation, n2: nmVal, ans: variation, sym: '−' };
                } else if (op === '*' || op === '×') {
                  p = { n1: nmVal, n2: variation, ans: nmVal * variation, sym: '×' };
                } else {
                  p = { n1: nmVal * variation, n2: nmVal, ans: variation, sym: '÷' };
                }
                // Ensure operands are within grade range
                const opMin = gradeSettings.operandMin || 1;
                const opMax = gradeSettings.operandMax || 10;
                p.n1 = Math.max(opMin, Math.min(opMax, p.n1));
                p.n2 = Math.max(opMin, Math.min(opMax, p.n2));
                if (op === '+') p.ans = p.n1 + p.n2;
                else if (op === '-') { p.ans = p.n1 - p.n2; if (p.ans < 0) { p.n1 = p.n2 + 1; p.ans = 1; } }
                else if (op === '*' || op === '×') {
                  // Ensure larger number is always first (n1 >= n2) for multiplication
                  if (p.n1 < p.n2) {
                    const temp = p.n1;
                    p.n1 = p.n2;
                    p.n2 = temp;
                  }
                  p.ans = p.n1 * p.n2;
                }
                else { p.ans = Math.floor(p.n1 / p.n2); p.n1 = p.ans * p.n2; }
              } else {
                // Custom difficulty mode fallback - USE NUMBER MODE VALUE
                if (op === '+') {
                  p = { n1: nmVal, n2: variation, ans: nmVal + variation, sym: '+' };
                } else if (op === '-') {
                  p = { n1: nmVal + variation, n2: nmVal, ans: variation, sym: '−' };
                } else if (op === '*' || op === '×') {
                  p = { n1: nmVal, n2: variation, ans: nmVal * variation, sym: '×' };
                } else {
                  p = { n1: nmVal * variation, n2: nmVal, ans: variation, sym: '÷' };
                }
                // Ensure answer is in range
                if (op === '+') p.ans = Math.min(cfg.max, p.n1 + p.n2);
                else if (op === '-') { if (p.ans < cfg.min) { p.n1 = cfg.min + 1; p.n2 = cfg.min; p.ans = 1; } }
                else if (op === '*' || op === '×') p.ans = Math.min(cfg.max, p.n1 * p.n2);
                else { p.ans = Math.floor(p.n1 / p.n2); p.n1 = p.ans * p.n2; }
              }
              p.op = op;
              validProblem = true; // Mark as valid so it gets added
            }
          }
        }

        // Final answer verification before adding
        if (op === '+') {
          p.ans = p.n1 + p.n2;
        } else if (op === '-') {
          if (p.n1 < p.n2) {
            const temp = p.n1;
            p.n1 = p.n2;
            p.n2 = temp;
          }
          p.ans = p.n1 - p.n2;
        } else if (op === '*') {
          p.ans = p.n1 * p.n2;
        } else {
          if (p.n2 === 0) p.n2 = 2;
          p.ans = Math.floor(p.n1 / p.n2);
          p.n1 = p.ans * p.n2;
        }

        // Store operation with problem for final validation
        p.op = op;

        // Final answer verification before adding (double-check)
        if (op === '+') {
          p.ans = p.n1 + p.n2; // Recalculate to ensure accuracy
        } else if (op === '-') {
          // CRITICAL: Ensure n1 >= n2 (no negative results)
          if (p.n1 < p.n2) {
            // Swap values to ensure valid subtraction
            const temp = p.n1;
            p.n1 = Math.max(p.n2, p.n2 + 1);
            p.n2 = Math.min(temp, p.n1 - 1);
          }
          p.n2 = Math.min(p.n2, p.n1 - 1); // Ensure n2 < n1
          p.n2 = Math.max(cfg.min, Math.min(p.n2, p.n1 - 1)); // Keep within bounds
          p.ans = p.n1 - p.n2;
          // Final safety check
          if (p.ans < 0 || p.n1 < p.n2) {
            p.n1 = getRandomInt(cfg.min + 3, cfg.max);
            p.n2 = getRandomInt(cfg.min, Math.min(p.n1 - 1, cfg.max));
            p.ans = p.n1 - p.n2;
          }
        } else if (op === '*') {
          // Ensure larger number is always first (n1 >= n2) for multiplication
          if (p.n1 < p.n2) {
            const temp = p.n1;
            p.n1 = p.n2;
            p.n2 = temp;
          }
          p.ans = p.n1 * p.n2; // Recalculate to ensure accuracy
        } else { // Division
          if (p.n2 === 0) {
            p.n2 = Math.max(cfg.min, 2); // Prevent division by zero
          }
          p.ans = Math.floor(p.n1 / p.n2);
          p.n1 = p.ans * p.n2; // Ensure clean division with no remainder
          // Verify clean division
          if (p.n1 % p.n2 !== 0 || p.n1 / p.n2 !== p.ans) {
            p.n1 = p.ans * p.n2; // Recalculate n1 to ensure perfect division
          }
        }

        usedKeys.add(key);
        usedAnswers.set(p.ans, (usedAnswers.get(p.ans) || 0) + 1);

        // Track division combinations for better variety
        if (op === '÷' || op === '/') {
          usedDivisionCombos.add(`${p.n1}÷${p.n2}`);
        }

        problems.push(p);
      }

      // Final validation pass: verify ALL problems have mathematically correct answers
      // Rebuild used keys/combos from current problems to check against during recalculation
      const finalUsedKeys = new Set();
      const finalUsedDivisionCombos = new Set();
      for (let j = 0; j < problems.length; j++) {
        const pj = problems[j];
        const opj = pj.op || pool[j];
        const keyj = getProblemKey(pj, opj);
        finalUsedKeys.add(keyj);
        if (opj === '÷' || opj === '/') {
          finalUsedDivisionCombos.add(`${pj.n1}÷${pj.n2}`);
          finalUsedDivisionCombos.add(`${pj.n1}/${pj.n2}`);
        }
      }

      for (let i = 0; i < problems.length; i++) {
        const p = problems[i];
        const op = p.op || pool[i]; // Use stored op or fallback to pool
        const originalKey = getProblemKey(p, op);
        const originalDivCombo = (op === '÷' || op === '/') ? `${p.n1}÷${p.n2}` : null;

        // Recalculate answer to ensure 100% accuracy with integer precision
        if (op === '+') {
          p.ans = Math.floor(p.n1 + p.n2); // Ensure integer
          // Verify
          if (p.ans !== (p.n1 + p.n2)) {
            p.ans = p.n1 + p.n2; // Should always be integer for addition
          }
        } else if (op === '-') {
          // CRITICAL VALIDATION: Ensure no negative results
          if (p.n1 < p.n2) {
            // Auto-fix: ensure n1 is always > n2
            const minN1 = p.n2 + 1;
            p.n1 = Math.max(minN1, Math.max(p.n1, p.n2 + 1));
            if (p.n1 > cfg.max) {
              // If n1 exceeds max, reduce n2 instead
              p.n1 = cfg.max;
              p.n2 = getRandomInt(cfg.min, Math.min(p.n1 - 1, cfg.max));
            }
          }
          p.ans = Math.floor(p.n1 - p.n2); // Ensure integer
          // Final check - should NEVER be negative
          if (p.ans < 0 || p.n1 <= p.n2) {
            // Emergency fix: regenerate valid subtraction
            p.n1 = getRandomInt(Math.max(cfg.min + 2, cfg.min + 1), cfg.max);
            p.n2 = getRandomInt(cfg.min, Math.min(p.n1 - 1, cfg.max));
            p.ans = p.n1 - p.n2;
          }
          // Cap at 6 digits
          p.ans = Math.min(p.ans, CONSTANTS.MAX_ANSWER);
        } else if (op === '*') {
          // Ensure operands are valid before calculation
          if (isNaN(p.n1) || !isFinite(p.n1)) p.n1 = cfg.min;
          if (isNaN(p.n2) || !isFinite(p.n2)) p.n2 = cfg.min;
          // Ensure larger number is always first (n1 >= n2) for multiplication
          if (p.n1 < p.n2) {
            const temp = p.n1;
            p.n1 = p.n2;
            p.n2 = temp;
          }
          p.ans = Math.floor(p.n1 * p.n2); // Ensure integer
          // Verify
          if (p.ans !== (p.n1 * p.n2)) {
            p.ans = p.n1 * p.n2; // Should always be integer for multiplication
          }
          // If product exceeds limit, adjust operands
          if (p.ans > CONSTANTS.MAX_ANSWER) {
            if (p.n1 >= p.n2) {
              p.n1 = Math.floor(CONSTANTS.MAX_ANSWER / p.n2);
            } else {
              p.n2 = Math.floor(CONSTANTS.MAX_ANSWER / p.n1);
            }
            p.ans = p.n1 * p.n2;
          }
          // Cap at 6 digits
          p.ans = Math.min(p.ans, CONSTANTS.MAX_ANSWER);
        } else { // Division
          // CRITICAL: Only fix if division is actually invalid to prevent creating duplicates
          // Check if division is already valid before making changes
          const isCurrentlyValid = (p.n2 !== 0 && p.n2 >= cfg.min && p.n2 <= cfg.max &&
            p.n1 >= cfg.min && p.n1 <= cfg.max &&
            p.n1 % p.n2 === 0 &&
            Math.floor(p.n1 / p.n2) === p.ans);

          if (!isCurrentlyValid) {
            // Store original values before recalculation
            const originalN1 = p.n1;
            const originalN2 = p.n2;
            const originalAns = p.ans;

            // Only fix if invalid
            if (p.n2 === 0 || p.n2 < cfg.min) {
              p.n2 = Math.max(cfg.min, 2); // Prevent division by zero
            }

            // Ensure perfect division (no remainder) - but preserve original values if possible
            if (p.n1 % p.n2 !== 0) {
              // Need to fix - recalculate
              const quotient = Math.floor(p.n1 / p.n2);
              p.ans = quotient;
              p.n1 = p.ans * p.n2; // Recalculate n1 to ensure perfect division
            } else {
              // Division is clean, just verify answer matches
              p.ans = Math.floor(p.n1 / p.n2);
            }

            // Only regenerate if values are out of range - but be careful not to create duplicates
            // NOTE: ans (quotient) doesn't need to be >= cfg.min, only n1 and n2 need to be in range
            if (p.n1 < cfg.min || p.n1 > cfg.max || p.n2 < 2 || p.n2 > cfg.max || p.ans < 1) {
              // Generate new values with TRUE RANDOMNESS - allow larger divisors for larger ranges
              // CRITICAL: Must check for duplicates when generating new values
              let regenAttempts = 0;
              let foundUnique = false;

              while (!foundUnique && regenAttempts < CONSTANTS.MAX_FALLBACK_ATTEMPTS * 4) {
                const safeMaxDivisor = Math.min(1000, cfg.max, Math.max(12, Math.floor(cfg.max / 3)));
                // RESPECT NUMBER MODE: If exact mode, use the practice number as divisor
                if (numberModeSettings.enabled && numberModeSettings.exact) {
                  p.n2 = numberModeSettings.value;
                } else {
                  p.n2 = getRandomInt(2, safeMaxDivisor);
                }
                const maxQuotient = Math.floor(cfg.max / p.n2);
                const minQuotient = Math.max(1, Math.ceil(cfg.min / p.n2));
                if (maxQuotient >= minQuotient) {
                  // Use TRUE RANDOM selection from entire quotient range
                  p.ans = getRandomInt(minQuotient, maxQuotient);
                  p.n1 = p.ans * p.n2;

                  // Check if this new combination is unique
                  const newKey = getProblemKey(p, op);
                  const newDivCombo = `${p.n1}÷${p.n2}`;

                  // Remove original from tracking sets temporarily for checking
                  finalUsedKeys.delete(originalKey);
                  if (originalDivCombo) {
                    finalUsedDivisionCombos.delete(originalDivCombo);
                    finalUsedDivisionCombos.delete(`${originalN1}/${originalN2}`);
                  }

                  // Check if new combination is unique (excluding current problem)
                  const isUnique = !finalUsedKeys.has(newKey) &&
                    !finalUsedDivisionCombos.has(newDivCombo) &&
                    !finalUsedDivisionCombos.has(`${p.n1}/${p.n2}`);

                  // Restore original to tracking sets
                  finalUsedKeys.add(originalKey);
                  if (originalDivCombo) {
                    finalUsedDivisionCombos.add(originalDivCombo);
                  }

                  if (isUnique && p.n1 >= cfg.min && p.n1 <= cfg.max && p.n2 >= 2 && p.n2 <= cfg.max) {
                    foundUnique = true;
                    // Update tracking sets with new values
                    finalUsedKeys.delete(originalKey);
                    finalUsedKeys.add(newKey);
                    if (originalDivCombo) {
                      finalUsedDivisionCombos.delete(originalDivCombo);
                      finalUsedDivisionCombos.delete(`${originalN1}/${originalN2}`);
                    }
                    finalUsedDivisionCombos.add(newDivCombo);
                    finalUsedDivisionCombos.add(`${p.n1}/${p.n2}`);
                    break;
                  }
                }
                regenAttempts++;
              }

              // If we couldn't find a unique replacement, try to preserve original if possible
              if (!foundUnique) {
                // Try to fix original values minimally without creating duplicates
                if (originalN1 >= cfg.min && originalN1 <= cfg.max && originalN2 >= 2 && originalN2 <= cfg.max) {
                  p.n1 = originalN1;
                  p.n2 = originalN2;
                  if (originalN1 % originalN2 === 0) {
                    p.ans = Math.floor(originalN1 / originalN2);
                  } else {
                    p.ans = Math.floor(originalN1 / originalN2);
                    p.n1 = p.ans * p.n2;
                  }
                }
              }
            } else {
              // Values are in range, just verify they're still unique (might have changed)
              const newKey = getProblemKey(p, op);
              const newDivCombo = `${p.n1}÷${p.n2}`;

              // Remove original from tracking sets temporarily
              finalUsedKeys.delete(originalKey);
              if (originalDivCombo) {
                finalUsedDivisionCombos.delete(originalDivCombo);
                finalUsedDivisionCombos.delete(`${originalN1}/${originalN2}`);
              }

              // Check if recalculated combination is unique
              const isUnique = !finalUsedKeys.has(newKey) &&
                !finalUsedDivisionCombos.has(newDivCombo) &&
                !finalUsedDivisionCombos.has(`${p.n1}/${p.n2}`);

              if (isUnique) {
                // Update tracking sets
                finalUsedKeys.add(newKey);
                finalUsedDivisionCombos.add(newDivCombo);
                finalUsedDivisionCombos.add(`${p.n1}/${p.n2}`);
              } else {
                // Recalculation created a duplicate - restore original
                p.n1 = originalN1;
                p.n2 = originalN2;
                p.ans = originalAns;
                finalUsedKeys.add(originalKey);
                if (originalDivCombo) {
                  finalUsedDivisionCombos.add(originalDivCombo);
                }
              }
            }
          }
          // If valid, leave it alone - don't recalculate!
        }

        // Ensure answer is always an integer (no decimals)
        p.ans = Math.floor(p.ans);
      }

      // FINAL DUPLICATE REMOVAL PASS: Ensure absolutely no duplicates exist
      const seenKeys = new Set();
      const seenDivisionCombos = new Set();

      for (let i = 0; i < problems.length; i++) {
        const p = problems[i];
        const op = p.op || pool[i];
        const key = getProblemKey(p, op);

        // Check for duplicate key
        if (seenKeys.has(key)) {
          // This is a duplicate - regenerate a unique problem
          let regenAttempts = 0;
          let foundUnique = false;

          while (!foundUnique && regenAttempts < CONSTANTS.MAX_FINAL_ATTEMPTS) {
            const uniqueOffset = regenAttempts + i * 50 + (generationSeed % 10000);
            const newP = useGradeLevel
              ? generateGradeLevelProblem(op, selectedGradeLevel, uniqueOffset, usedAnswers, numberModeSettings)
              : generateProblemData(op, cfg.min, cfg.max, uniqueOffset, usedAnswers, numberModeSettings);

            // Verify answer
            if (op === '+') {
              newP.ans = newP.n1 + newP.n2;
            } else if (op === '-') {
              if (newP.n1 < newP.n2) {
                const temp = newP.n1;
                newP.n1 = newP.n2;
                newP.n2 = temp;
              }
              newP.ans = newP.n1 - newP.n2;
            } else if (op === '*') {
              newP.ans = newP.n1 * newP.n2;
            } else { // Division
              if (newP.n2 === 0) newP.n2 = 2;
              newP.ans = Math.floor(newP.n1 / newP.n2);
              newP.n1 = newP.ans * newP.n2; // Ensure clean division
            }

            const newKey = getProblemKey(newP, op);
            const newDivCombo = (op === '÷' || op === '/') ? `${newP.n1}÷${newP.n2}` : null;

            // Check if unique (check both key and division combo)
            if (!seenKeys.has(newKey)) {
              if ((op === '÷' || op === '/')) {
                if (!seenDivisionCombos.has(newDivCombo) && !seenDivisionCombos.has(`${newP.n1}/${newP.n2}`)) {
                  // Unique division problem found
                  newP.op = op;
                  problems[i] = newP;
                  seenKeys.add(newKey);
                  seenDivisionCombos.add(newDivCombo);
                  seenDivisionCombos.add(`${newP.n1}/${newP.n2}`);
                  foundUnique = true;
                }
              } else {
                // Unique non-division problem found
                newP.op = op;
                problems[i] = newP;
                seenKeys.add(newKey);
                foundUnique = true;
              }
            }

            regenAttempts++;
          }

          if (!foundUnique) {
            console.warn(`Could not generate unique replacement for duplicate problem ${i + 1}. Keeping original but may be duplicate.`);
            // At least mark it as seen so we don't create more duplicates
            seenKeys.add(key);
            if ((op === '÷' || op === '/')) {
              seenDivisionCombos.add(`${p.n1}÷${p.n2}`);
              seenDivisionCombos.add(`${p.n1}/${p.n2}`);
            }
          }
        } else {
          // Not a duplicate - mark as seen
          seenKeys.add(key);
          if ((op === '÷' || op === '/')) {
            const divCombo = `${p.n1}÷${p.n2}`;
            // Check for duplicate division combo even if key is different (shouldn't happen, but be safe)
            if (seenDivisionCombos.has(divCombo) || seenDivisionCombos.has(`${p.n1}/${p.n2}`)) {
              // Division combo duplicate found - regenerate
              let regenAttempts = 0;
              let foundUnique = false;

              while (!foundUnique && regenAttempts < 300) {
                const uniqueOffset = regenAttempts + i * 50 + (generationSeed % 10000);
                const newP = useGradeLevel
                  ? generateGradeLevelProblem(op, selectedGradeLevel, uniqueOffset, null, numberModeSettings)
                  : generateProblemData(op, cfg.min, cfg.max, uniqueOffset, null, numberModeSettings);

                if (op === '+') {
                  newP.ans = newP.n1 + newP.n2;
                } else if (op === '-') {
                  if (newP.n1 < newP.n2) {
                    const temp = newP.n1;
                    newP.n1 = newP.n2;
                    newP.n2 = temp;
                  }
                  newP.ans = newP.n1 - newP.n2;
                } else if (op === '*') {
                  newP.ans = newP.n1 * newP.n2;
                } else {
                  if (newP.n2 === 0) newP.n2 = 2;
                  newP.ans = Math.floor(newP.n1 / newP.n2);
                  newP.n1 = newP.ans * newP.n2;
                }

                const newKey = getProblemKey(newP, op);
                const newDivCombo = `${newP.n1}÷${newP.n2}`;

                if (!seenKeys.has(newKey) && !seenDivisionCombos.has(newDivCombo) && !seenDivisionCombos.has(`${newP.n1}/${newP.n2}`)) {
                  newP.op = op;
                  problems[i] = newP;
                  seenKeys.add(newKey);
                  seenDivisionCombos.add(newDivCombo);
                  seenDivisionCombos.add(`${newP.n1}/${newP.n2}`);
                  foundUnique = true;
                }

                regenAttempts++;
              }
            } else {
              seenDivisionCombos.add(divCombo);
              seenDivisionCombos.add(`${p.n1}/${p.n2}`);
            }
          }
        }
      }

      return problems;
    }

    /**
     * Validates and corrects a problem to ensure mathematical correctness
     * Also validates Number Mode constraints if applicable
     * @param {Object} p - Problem object with n1, n2, ans, sym
     * @param {string} op - Operation symbol
     * @param {number} min - Minimum answer value
     * @param {number} max - Maximum answer value
     * @param {Object} numberMode - Optional Number Mode settings to validate against
     * @returns {Object} Validated problem with isValid flag
     */
    function validateProblem(p, op, min, max, numberMode = null) {
      // NEW SYSTEM: min/max refer to ANSWER range, not operand range
      let { n1, n2, ans, sym } = p;
      let isValid = false;

      const numberModeEnabled = numberMode && numberMode.enabled;
      const numberModeValue = numberMode ? numberMode.value : 1;
      const numberModeExact = numberMode && numberMode.exact;

      if (op === '+') {
        // For addition: ans = n1 + n2, verify answer is in [min, max] range
        ans = n1 + n2; // Recalculate to ensure accuracy
        // CRITICAL: Never allow answers to exceed 6 digits (999,999)
        ans = Math.min(ans, CONSTANTS.MAX_ANSWER);
        isValid = (ans >= min && ans <= max);

        // Validate Number Mode constraints
        if (isValid && numberModeEnabled) {
          if (numberModeExact) {
            // Exact mode: one operand must be exactly numberModeValue
            isValid = isValid && (n1 === numberModeValue || n2 === numberModeValue);
          } else {
            // Multiples mode: at least one operand should be a multiple (or answer should be)
            isValid = isValid && (
              (n1 % numberModeValue === 0) ||
              (n2 % numberModeValue === 0) ||
              (ans % numberModeValue === 0)
            );
          }
        }
      }
      else if (op === '-') {
        // For subtraction: ans = n1 - n2, verify answer is in [min, max] range and n1 > n2
        if (n1 <= n2) {
          // Fix invalid subtraction - ensure n1 is always larger
          n1 = n2 + ans; // Recalculate n1 based on desired answer
        }
        ans = n1 - n2; // Recalculate to ensure accuracy
        // CRITICAL: Never allow answers to exceed 6 digits (999,999)
        ans = Math.min(ans, CONSTANTS.MAX_ANSWER);
        isValid = (n1 > n2) && (ans >= min && ans <= max);

        // Validate Number Mode constraints
        if (isValid && numberModeEnabled) {
          if (numberModeExact) {
            isValid = isValid && (n1 === numberModeValue || n2 === numberModeValue);
          } else {
            isValid = isValid && (
              (n1 % numberModeValue === 0) ||
              (n2 % numberModeValue === 0) ||
              (ans % numberModeValue === 0)
            );
          }
        }
      }
      else if (op === '*') {
        // For multiplication: ans = n1 * n2, verify answer is in [min, max] range
        // Ensure larger number is always first (n1 >= n2) for multiplication
        if (n1 < n2) {
          const temp = n1;
          n1 = n2;
          n2 = temp;
        }
        ans = n1 * n2; // Recalculate to ensure accuracy
        // CRITICAL: Never allow answers to exceed 6 digits (999,999)
        ans = Math.min(ans, CONSTANTS.MAX_ANSWER);
        isValid = (ans >= min && ans <= max);

        // Validate Number Mode constraints
        if (isValid && numberModeEnabled) {
          if (numberModeExact) {
            isValid = isValid && (n1 === numberModeValue || n2 === numberModeValue);
          } else {
            isValid = isValid && (
              (n1 % numberModeValue === 0) ||
              (n2 % numberModeValue === 0)
            );
          }
        }
      }
      else { // Division
        // For division: ans = n1 / n2, verify answer is in [min, max] range and division is clean
        if (n2 === 0) {
          n2 = 2; // Prevent division by zero, use at least 2
          n1 = ans * n2; // Recalculate n1
        }
        if (n1 % n2 !== 0) {
          // Ensure clean division - recalculate n1
          n1 = ans * n2;
        }
        ans = Math.floor(n1 / n2); // Ensure integer answer
        // CRITICAL: Never allow answers to exceed 6 digits (999,999)
        ans = Math.min(ans, CONSTANTS.MAX_ANSWER);
        isValid = (n2 !== 0 && n2 >= 2) && // n2 should be at least 2 (avoid division by 1)
          (n1 === ans * n2) && (n1 % n2 === 0) && // Clean division
          (ans >= min && ans <= max); // Answer (quotient) in range

        // Recalculate n1 to ensure perfect division
        if (isValid) {
          n1 = ans * n2; // Ensure n1 is exactly ans * n2
        }

        // Validate Number Mode constraints
        if (isValid && numberModeEnabled) {
          if (numberModeExact) {
            // For division, exact mode typically means divisor is exact number
            isValid = isValid && (n1 === numberModeValue || n2 === numberModeValue);
          } else {
            isValid = isValid && (
              (n1 % numberModeValue === 0) ||
              (n2 % numberModeValue === 0)
            );
          }
        }
      }

      // CRITICAL: Ensure all values are integers before returning
      return {
        n1: Math.floor(n1),
        n2: Math.floor(n2),
        ans: Math.floor(ans),
        sym,
        isValid
      };
    }

    /**
     * Generates a problem for custom difficulty mode (not grade-level)
     * This function properly handles numberModeExact to ensure the exact number appears in every problem
     * @param {string} op - Operation symbol (+, -, *, /)
     * @param {number} min - Minimum answer value
     * @param {number} max - Maximum answer value
     * @param {number} attemptOffset - Offset for random seed variation
     * @param {Map} answerUsageMap - Map tracking answer usage for variety
     * @param {Object} numberMode - Number Mode settings
     * @returns {Object} Problem object with n1, n2, ans, sym
     */
    function generateProblemData(op, min, max, attemptOffset = 0, answerUsageMap = null, numberMode = null) {
      const numberModeEnabled = numberMode && numberMode.enabled;
      const numberModeValue = numberMode ? numberMode.value : 1;
      const numberModeExact = numberMode && numberMode.exact;

      let n1, n2, ans, sym;

      // Simple seeded random for variety
      let localSeed = attemptOffset * 1000 + Math.floor(Math.random() * 100000);
      const getSeededRandomInt = (minVal, maxVal) => {
        if (minVal > maxVal) { const temp = minVal; minVal = maxVal; maxVal = temp; }
        if (minVal === maxVal) return minVal;
        localSeed = (localSeed * CONSTANTS.SEED_MULTIPLIER + CONSTANTS.SEED_ADDEND) % CONSTANTS.SEED_MODULUS;
        const random = localSeed / CONSTANTS.SEED_MODULUS;
        return Math.floor(minVal + random * (maxVal - minVal + 1));
      };

      if (op === '+') {
        if (numberModeEnabled && numberModeExact) {
          // EXACT MODE: One operand must be exactly numberModeValue
          const useN1 = (attemptOffset % 2 === 0);
          if (useN1) {
            n1 = numberModeValue;
            n2 = getSeededRandomInt(Math.max(1, min - n1), Math.max(1, max - n1));
          } else {
            n2 = numberModeValue;
            n1 = getSeededRandomInt(Math.max(1, min - n2), Math.max(1, max - n2));
          }
        } else {
          n1 = getSeededRandomInt(1, Math.floor(max / 2));
          n2 = getSeededRandomInt(1, Math.floor(max / 2));
        }
        ans = n1 + n2;
        sym = '+';
      }
      else if (op === '-') {
        if (numberModeEnabled && numberModeExact) {
          // EXACT MODE: One operand must be exactly numberModeValue
          // For subtraction: n1 - n2 = ans (where n1 > n2)
          const useN2 = (attemptOffset % 2 === 0);
          if (useN2) {
            // n2 (subtrahend) is the exact number: n1 - 5 = ans
            n2 = numberModeValue;
            const ansValue = getSeededRandomInt(1, Math.min(50, max));
            n1 = n2 + ansValue; // n1 = 5 + ans, so n1 - 5 = ans
            ans = ansValue;
          } else {
            // n1 (minuend) is the exact number: 5 - n2 = ans
            n1 = numberModeValue;
            n2 = getSeededRandomInt(1, Math.max(1, n1 - 1));
            ans = n1 - n2;
          }
        } else {
          n1 = getSeededRandomInt(min + 1, max);
          n2 = getSeededRandomInt(1, n1 - 1);
          ans = n1 - n2;
        }
        // Don't swap - we already ensured n1 > n2 in exact mode
        if (!numberModeExact && n1 < n2) { const temp = n1; n1 = n2; n2 = temp; ans = n1 - n2; }
        sym = '−';
      }
      else if (op === '*' || op === '×') {
        if (numberModeEnabled && numberModeExact) {
          // EXACT MODE: One operand must be exactly numberModeValue
          const useN1 = (attemptOffset % 2 === 0);
          if (useN1) {
            n1 = numberModeValue;
            n2 = getSeededRandomInt(1, Math.min(50, Math.floor(max / n1)));
          } else {
            n2 = numberModeValue;
            n1 = getSeededRandomInt(1, Math.min(50, Math.floor(max / n2)));
          }
        } else {
          const sqrtMax = Math.floor(Math.sqrt(max));
          n1 = getSeededRandomInt(2, sqrtMax);
          n2 = getSeededRandomInt(2, sqrtMax);
        }
        ans = n1 * n2;
        sym = '×';
      }
      else if (op === '/' || op === '÷') {
        if (numberModeEnabled && numberModeExact) {
          // EXACT MODE: One operand (divisor) must be exactly numberModeValue
          n2 = numberModeValue;
          ans = getSeededRandomInt(1, Math.min(50, Math.floor(max)));
          n1 = ans * n2;
        } else {
          n2 = getSeededRandomInt(2, Math.min(20, Math.floor(Math.sqrt(max))));
          ans = getSeededRandomInt(1, Math.floor(max / n2));
          n1 = ans * n2;
        }
        sym = '÷';
      }

      // Ensure all values are valid
      n1 = Math.max(1, Math.floor(n1 || 1));
      n2 = Math.max(1, Math.floor(n2 || 1));
      ans = Math.floor(ans || 0);

      return { n1, n2, ans, sym, op, isValid: true };
    }

    /**
     * Checks if a number is "too round" (has too many trailing zeros or simple patterns)
     * For grades 7-12, we want to avoid round numbers
     * @param {number} num - Number to check
     * @param {number} strictnessLevel - 0=reject 4+ zeros, 1=reject 3+ zeros, 2=penalize 2+ zeros
     * @returns {boolean} True if number is too round (should be rejected/penalized)
     */
    function isTooRound(num, strictnessLevel = 0) {
      if (num === 0) return false; // 0 is acceptable

      // Tier 0 (strictest): Reject if ends with 0000+ (4+ trailing zeros)
      if (num % 10000 === 0) return true;

      // Tier 1: Reject if ends with 000 (3 trailing zeros) for grades 9-12, optional for 7-8
      if (strictnessLevel <= 1 && num % 1000 === 0) return true;

      // Tier 2: Penalize if ends with 00 or 0 (2+ trailing zeros)
      if (strictnessLevel <= 2 && num % 100 === 0) return true;
      if (strictnessLevel <= 2 && num % 10 === 0) return true;

      // Optional: Reject if all digits identical (e.g., 777777) or simple repeats (e.g., 123123)
      const str = String(num);
      if (str.length >= 4) {
        // Check if all digits are the same
        if (/^(\d)\1+$/.test(str)) return true;
        // Check for simple repeating patterns (e.g., 123123, 456456)
        if (str.length === 6) {
          const half = str.substring(0, 3);
          if (str === half + half) return true;
        }
      }

      return false;
    }

    /**
     * Wrapper function that applies "too-round" filtering for grades 7-12
     * This is a post-generation filter that regenerates problems if they contain "too-round" numbers
     * @param {string} op - Operation symbol (+, -, *, /)
     * @param {string} grade - Grade level (k4, k5, '1'-'12')
     * @param {number} attemptOffset - Offset for random seed variation
     * @param {Map} answerUsageMap - Map tracking answer usage for variety
     * @param {Object} numberMode - Number Mode settings (optional)
     * @returns {Object} Problem object with n1, n2, ans, sym, isValid
     */
    function generateGradeLevelProblem(op, grade, attemptOffset = 0, answerUsageMap = null, numberMode = null) {
      const gradeSettings = gradeLevelSettings[grade];
      const shouldFilterRoundNumbers = gradeSettings && gradeSettings.avoidRoundNumbers;

      // For grades 7-12, apply post-generation filtering for "too-round" numbers
      if (shouldFilterRoundNumbers) {
        const MAX_ROUND_FILTER_ATTEMPTS = 50; // Reduced from 200 to prevent freezing
        let attempt = 0;
        let strictnessLevel = 0; // Start with strictest (reject 4+ zeros)

        while (attempt < MAX_ROUND_FILTER_ATTEMPTS) {
          // Generate candidate problem
          const candidate = generateGradeLevelProblemCore(op, grade, attemptOffset + attempt, answerUsageMap, numberMode);

          // Validate hard constraints first (6-digit limit, integer division, etc.)
          if (candidate.n1 > CONSTANTS.MAX_ANSWER || candidate.n2 > CONSTANTS.MAX_ANSWER || candidate.ans > CONSTANTS.MAX_ANSWER) {
            attempt++;
            continue; // Regenerate if exceeds 6 digits
          }

          // For division, ensure it's exact (and n2 is not zero)
          if ((op === '/' || op === '÷') && (candidate.n2 === 0 || candidate.n1 % candidate.n2 !== 0)) {
            attempt++;
            continue;
          }

          // Check for "too-round" numbers based on strictness level
          const gradeNum = parseInt(grade) || (grade === 'k4' ? -1 : grade === 'k5' ? 0 : 1);
          const isHighGrade = gradeNum >= 9; // Grades 9-12 use stricter rules
          const currentStrictness = isHighGrade ? strictnessLevel : Math.max(0, strictnessLevel - 1);

          const n1TooRound = isTooRound(candidate.n1, currentStrictness);
          const n2TooRound = isTooRound(candidate.n2, currentStrictness);
          const ansTooRound = isTooRound(candidate.ans, currentStrictness);

          if (!n1TooRound && !n2TooRound && !ansTooRound) {
            // All numbers pass the roundness check - return this problem
            return candidate;
          }

          attempt++;

          // Tiered relaxation: if we've tried many times, relax the strictness (adjusted for lower max attempts)
          if (attempt === 20 && strictnessLevel === 0) {
            strictnessLevel = 1; // Allow 3 trailing zeros (000)
          } else if (attempt === 35 && strictnessLevel === 1) {
            strictnessLevel = 2; // Only penalize 2+ trailing zeros (00, 0)
          }
        }

        // Fallback: if we couldn't find a non-round problem, generate one more time without filtering
        // (but still enforce 6-digit limit and integer division)
        console.warn(`Could not generate non-round problem for ${grade} ${op} after ${MAX_ROUND_FILTER_ATTEMPTS} attempts, using fallback`);
        return generateGradeLevelProblemCore(op, grade, attemptOffset + MAX_ROUND_FILTER_ATTEMPTS, answerUsageMap, numberMode);
      }

      // For grades K4-6, use core generation without filtering
      return generateGradeLevelProblemCore(op, grade, attemptOffset, answerUsageMap, numberMode);
    }

    /**
     * Core function that generates grade-appropriate math problems based on educational standards
     * Uses operand ranges (not answer ranges) to ensure problems match what students learn at each grade
     * @param {string} op - Operation symbol (+, -, *, /)
     * @param {string} grade - Grade level (k4, k5, '1'-'12')
     * @param {number} attemptOffset - Offset for random seed variation
     * @param {Map} answerUsageMap - Map tracking answer usage for variety
     * @param {Object} numberMode - Number Mode settings (optional)
     * @returns {Object} Problem object with n1, n2, ans, sym, isValid
     */
    function generateGradeLevelProblemCore(op, grade, attemptOffset = 0, answerUsageMap = null, numberMode = null) {
      const gradeSettings = gradeLevelSettings[grade];
      if (!gradeSettings) {
        // Fallback to default grade 1 settings
        return generateGradeLevelProblemCore(op, '1', attemptOffset, answerUsageMap, numberMode);
      }

      // Check if operation is allowed for this grade
      if (!gradeSettings.operations.includes(op)) {
        // Operation not allowed - return a valid fallback operation
        const allowedOp = gradeSettings.operations[0] || '+';
        return generateGradeLevelProblemCore(allowedOp, grade, attemptOffset, answerUsageMap, numberMode);
      }

      const operandMin = gradeSettings.operandMin;
      const operandMax = gradeSettings.operandMax;
      const numberModeEnabled = numberMode && numberMode.enabled;
      const numberModeValue = numberMode ? numberMode.value : 1;
      const numberModeExact = numberMode && numberMode.exact;

      let n1, n2, ans, sym;

      // Helper function for random int with offset for variation
      // Uses Linear Congruential Generator for better distribution
      // Use Math.random() once for initial entropy (faster than Date.now() called repeatedly)
      let localSeed = attemptOffset * 1000 + Math.floor(Math.random() * 100000);
      const getSeededRandomInt = (min, max) => {
        // Edge case: handle invalid range
        if (min > max) {
          const temp = min;
          min = max;
          max = temp;
        }
        if (min === max) return min;

        // LCG parameters (same as main seededRandom)
        localSeed = (localSeed * CONSTANTS.SEED_MULTIPLIER + CONSTANTS.SEED_ADDEND) % CONSTANTS.SEED_MODULUS;
        const random = localSeed / CONSTANTS.SEED_MODULUS;
        return Math.floor(min + random * (max - min + 1));
      };

      // Helper function to get random multiple
      const getRandomMultiple = (minVal, maxVal) => {
        if (!numberModeEnabled) return getSeededRandomInt(minVal, maxVal);
        const minMultiple = Math.ceil(minVal / numberModeValue) * numberModeValue;
        const maxMultiple = Math.floor(maxVal / numberModeValue) * numberModeValue;
        if (minMultiple > maxMultiple) return numberModeValue;
        const multipleCount = Math.floor((maxMultiple - minMultiple) / numberModeValue) + 1;
        const index = getSeededRandomInt(0, multipleCount - 1);
        return minMultiple + (index * numberModeValue);
      };

      if (op === '+') {
        // Addition: Operands within grade range, ensuring consistent and well-balanced problems
        // Real math teachers create problems with operands that are similar in magnitude

        // Determine appropriate ratio based on number size (MUCH tighter for consistency)
        const getMaxRatio = (num) => {
          if (num <= 20) return 1.5;      // Very tight: e.g., 12 + 8 (not 20 + 1)
          if (num <= 50) return 1.6;      // Tight: e.g., 35 + 22 (not 50 + 1)
          if (num <= 100) return 1.7;     // Moderate: e.g., 58 + 37 (examples show 58+37)
          if (num <= 500) return 1.8;     // Consistent: e.g., 468 + 357 (examples show 468+357)
          if (num <= 1000) return 1.9;    // For larger numbers: e.g., 900 + 476
          if (num <= 10000) return 2.0;   // Four-digit: e.g., 7486 + 3927 (examples show similar)
          if (num <= 100000) return 2.0;  // Five-digit: e.g., 48735 + 26419
          return 2.0;                      // For very large numbers: keep consistent
        };

        // Helper to ensure operands are from similar ranges (within 60-70% of each other)
        const getConsistentPair = (center, rangeSize, maxRatio) => {
          const minVal = Math.max(operandMin, Math.ceil(center / maxRatio));
          const maxVal = Math.min(operandMax, Math.floor(center * maxRatio));
          return { min: minVal, max: maxVal };
        };

        if (numberModeEnabled && numberModeExact) {
          // Exact number mode: one operand must be exactly numberModeValue
          const useN1 = (attemptOffset % 2 === 0);
          if (useN1) {
            n1 = numberModeValue;
            const maxRatio = getMaxRatio(numberModeValue);
            const pair = getConsistentPair(numberModeValue, 0, maxRatio);
            const minN2 = Math.max(operandMin, pair.min);
            const maxN2 = Math.min(operandMax, gradeSettings.answerMax - numberModeValue, pair.max);
            n2 = getSeededRandomInt(minN2, maxN2);
          } else {
            n2 = numberModeValue;
            const maxRatio = getMaxRatio(numberModeValue);
            const pair = getConsistentPair(numberModeValue, 0, maxRatio);
            const minN1 = Math.max(operandMin, pair.min);
            const maxN1 = Math.min(operandMax, gradeSettings.answerMax - numberModeValue, pair.max);
            n1 = getSeededRandomInt(minN1, maxN1);
          }
        } else if (numberModeEnabled) {
          // Multiples mode: at least one operand is a multiple, but keep them very balanced
          const useN1 = (attemptOffset % 2 === 0);
          if (useN1) {
            n1 = getRandomMultiple(operandMin, Math.min(operandMax, gradeSettings.answerMax - operandMin));
            const maxRatio = getMaxRatio(n1);
            const pair = getConsistentPair(n1, 0, maxRatio);
            const minN2 = Math.max(operandMin, pair.min);
            const maxN2 = Math.min(operandMax, gradeSettings.answerMax - n1, pair.max);
            n2 = getSeededRandomInt(minN2, maxN2);
          } else {
            n2 = getRandomMultiple(operandMin, Math.min(operandMax, gradeSettings.answerMax - operandMin));
            const maxRatio = getMaxRatio(n2);
            const pair = getConsistentPair(n2, 0, maxRatio);
            const minN1 = Math.max(operandMin, pair.min);
            const maxN1 = Math.min(operandMax, gradeSettings.answerMax - n2, pair.max);
            n1 = getSeededRandomInt(minN1, maxN1);
          }
        } else {
          // Normal mode: both operands from similar ranges for maximum consistency
          if (gradeSettings.noCarrying && grade <= '1') {
            // For early grades: avoid carrying (sum of digits < 10)
            n1 = getSeededRandomInt(operandMin, Math.min(5, operandMax));
            n2 = getSeededRandomInt(operandMin, Math.min(9 - n1, operandMax));
          } else {
            // Enhanced consistency: choose both operands from VERY narrow, overlapping ranges
            const strategy = attemptOffset % 3;
            const rangeSize = operandMax - operandMin;

            if (strategy === 0) {
              // Strategy 1: Both from very narrow middle range (most consistent)
              const lowerBound = operandMin + rangeSize * 0.45;
              const upperBound = operandMin + rangeSize * 0.55;
              n1 = getSeededRandomInt(Math.floor(lowerBound), Math.floor(upperBound));
              const maxRatio = getMaxRatio(n1);
              const pair = getConsistentPair(n1, 0, maxRatio);
              const minN2 = Math.max(Math.floor(n1 / maxRatio), pair.min, operandMin);
              const maxN2 = Math.min(Math.floor(n1 * maxRatio), gradeSettings.answerMax - n1, pair.max, operandMax);
              n2 = getSeededRandomInt(minN2, maxN2);
            } else if (strategy === 1) {
              // Strategy 2: Choose center value, then both operands VERY close to it
              const center = operandMin + rangeSize * 0.5;
              const variance = rangeSize * 0.08; // MUCH narrower variance for consistency
              n1 = getSeededRandomInt(Math.floor(center - variance), Math.floor(center + variance));
              const maxRatio = getMaxRatio(n1);
              const pair = getConsistentPair(n1, variance, maxRatio);
              const minN2 = Math.max(Math.floor(n1 / maxRatio), pair.min, operandMin);
              const maxN2 = Math.min(Math.floor(n1 * maxRatio), gradeSettings.answerMax - n1, pair.max, operandMax);
              n2 = getSeededRandomInt(minN2, maxN2);
            } else {
              // Strategy 3: Overlapping VERY tight ranges for maximum consistency
              const rangeStart = operandMin + rangeSize * 0.47;
              const rangeEnd = operandMin + rangeSize * 0.53;
              n1 = getSeededRandomInt(Math.floor(rangeStart), Math.floor(rangeEnd));
              const maxRatio = getMaxRatio(n1);
              const pair = getConsistentPair(n1, rangeEnd - rangeStart, maxRatio);
              const minN2 = Math.max(Math.floor(n1 / maxRatio), pair.min, operandMin);
              const maxN2 = Math.min(Math.floor(n1 * maxRatio), gradeSettings.answerMax - n1, pair.max, operandMax);
              n2 = getSeededRandomInt(minN2, maxN2);
            }
          }
        }
        ans = n1 + n2;
        // CRITICAL: Never allow answers to exceed 6 digits (999,999)
        ans = Math.min(ans, CONSTANTS.MAX_ANSWER);
        sym = '+';
      }
      else if (op === '-') {
        // Subtraction: n1 > n2, both within grade range, ensuring consistent and well-balanced differences
        // Real math teachers create problems like 47 - 23, not 59 - 1

        // Determine appropriate ratio based on number size (MUCH tighter for consistency)
        const getMaxRatio = (num) => {
          if (num <= 20) return 1.5;      // Very tight: e.g., 19 - 8 (examples show 19-8)
          if (num <= 50) return 1.6;      // Tight: e.g., 42 - 29 (examples show 84-29)
          if (num <= 100) return 1.7;     // Moderate: e.g., 84 - 29 (examples show 84-29)
          if (num <= 500) return 1.8;     // Consistent: e.g., 468 - 357 (examples show 900-476)
          if (num <= 1000) return 1.9;    // For larger numbers: e.g., 900 - 476
          if (num <= 10000) return 2.0;   // Four-digit: e.g., 12000 - 4783
          if (num <= 100000) return 2.0;  // Five-digit: e.g., 90506 - 47839
          return 2.0;                      // For very large numbers: keep consistent
        };

        // Helper to ensure operands are from similar ranges for consistent subtraction
        const getConsistentPair = (center, maxRatio, isSubtraction) => {
          if (isSubtraction) {
            // For subtraction: n2 should be 40-70% of n1 for consistent differences
            const minN2 = Math.max(operandMin, Math.ceil(center / maxRatio), Math.floor(center * 0.4));
            const maxN2 = Math.min(operandMax, Math.floor(center * 0.75), center - 1);
            return { min: minN2, max: maxN2 };
          } else {
            const minVal = Math.max(operandMin, Math.ceil(center / maxRatio));
            const maxVal = Math.min(operandMax, Math.floor(center * maxRatio));
            return { min: minVal, max: maxVal };
          }
        };

        if (numberModeEnabled && numberModeExact) {
          const useN2 = (attemptOffset % 2 === 0);
          if (useN2) {
            n2 = numberModeValue;
            const maxRatio = getMaxRatio(numberModeValue);
            const minN1 = Math.max(operandMin, numberModeValue + 1, Math.ceil(numberModeValue * 1.4));
            const maxN1 = Math.min(operandMax, Math.floor(numberModeValue * maxRatio));
            n1 = getSeededRandomInt(minN1, maxN1);
          } else {
            n1 = numberModeValue;
            const maxRatio = getMaxRatio(numberModeValue);
            const pair = getConsistentPair(numberModeValue, maxRatio, true);
            n2 = getSeededRandomInt(pair.min, pair.max);
            // Ensure n1 > n2
            if (n2 >= n1) {
              n2 = Math.max(operandMin, Math.floor(n1 * 0.65));
            }
          }
        } else if (numberModeEnabled) {
          const useN2 = (attemptOffset % 2 === 0);
          if (useN2) {
            n2 = getRandomMultiple(operandMin, Math.min(operandMax, operandMax - operandMin));
            const maxRatio = getMaxRatio(n2);
            const minN1 = Math.max(operandMin, n2 + 1, Math.ceil(n2 * 1.4));
            const maxN1 = Math.min(operandMax, Math.floor(n2 * maxRatio));
            n1 = getSeededRandomInt(minN1, maxN1);
          } else {
            n1 = getRandomMultiple(Math.max(operandMin, operandMin * 2), operandMax);
            const maxRatio = getMaxRatio(n1);
            const pair = getConsistentPair(n1, maxRatio, true);
            n2 = getSeededRandomInt(pair.min, pair.max);
          }
        } else {
          // Normal mode: ensure VERY consistent subtraction problems (like 84 - 29, not 100 - 1)
          const strategy = attemptOffset % 3;
          const rangeSize = operandMax - operandMin;

          if (strategy === 0) {
            // Strategy 1: Both from VERY narrow middle range for maximum consistency
            const lowerBound = operandMin + rangeSize * 0.45;
            const upperBound = operandMin + rangeSize * 0.55;
            n1 = getSeededRandomInt(Math.floor(lowerBound), Math.floor(upperBound));
            const maxRatio = getMaxRatio(n1);
            const pair = getConsistentPair(n1, maxRatio, true);
            const minN2 = Math.max(Math.floor(n1 / maxRatio), Math.floor(n1 * 0.4), pair.min, operandMin);
            const maxN2 = Math.min(Math.floor(n1 * 0.75), n1 - 1, pair.max, operandMax);
            n2 = getSeededRandomInt(minN2, maxN2);
          } else if (strategy === 1) {
            // Strategy 2: Choose center value, then both operands VERY close to it with consistent difference
            const center = operandMin + rangeSize * 0.5;
            const variance = rangeSize * 0.08; // MUCH narrower variance for consistency
            n1 = getSeededRandomInt(Math.floor(center - variance), Math.floor(center + variance));
            const maxRatio = getMaxRatio(n1);
            const pair = getConsistentPair(n1, maxRatio, true);
            const minN2 = Math.max(Math.floor(n1 / maxRatio), Math.floor(n1 * 0.4), pair.min, operandMin);
            const maxN2 = Math.min(Math.floor(n1 * 0.75), n1 - 1, pair.max, operandMax);
            n2 = getSeededRandomInt(minN2, maxN2);
          } else {
            // Strategy 3: Overlapping VERY tight ranges with n2 being 40-75% of n1 for consistent differences
            const rangeStart = operandMin + rangeSize * 0.47;
            const rangeEnd = operandMin + rangeSize * 0.53;
            n1 = getSeededRandomInt(Math.floor(rangeStart), Math.floor(rangeEnd));
            const maxRatio = getMaxRatio(n1);
            const pair = getConsistentPair(n1, maxRatio, true);
            const minN2 = Math.max(Math.floor(n1 / maxRatio), Math.floor(n1 * 0.4), pair.min, operandMin);
            const maxN2 = Math.min(Math.floor(n1 * 0.75), n1 - 1, pair.max, operandMax);
            n2 = getSeededRandomInt(minN2, maxN2);
          }
        }
        ans = n1 - n2;
        // CRITICAL: Never allow answers to exceed 6 digits (999,999)
        ans = Math.min(ans, CONSTANTS.MAX_ANSWER);
        sym = '−';
      }
      else if (op === '*') {
        // Multiplication: Use grade-specific multiplication table limits
        const multTable = gradeSettings.multiplicationTable || gradeSettings.multiplicationTables;
        if (multTable) {
          // Use the grade's multiplication table limit
          const maxOperand = Math.min(multTable, 1000); // Cap at 1000 for safety
          n1 = getSeededRandomInt(operandMin || 1, maxOperand);
          n2 = getSeededRandomInt(operandMin || 1, maxOperand);

          if (numberModeEnabled && numberModeExact) {
            if (attemptOffset % 2 === 0) n1 = numberModeValue;
            else n2 = numberModeValue;
          } else if (numberModeEnabled) {
            if (attemptOffset % 2 === 0) {
              n1 = getRandomMultiple(1, maxOperand);
            } else {
              n2 = getRandomMultiple(1, maxOperand);
            }
          }
        } else {
          // For higher grades: Use wider operand ranges BUT ensure product never exceeds 999,999
          // CRITICAL: Always use CONSTANTS.MAX_ANSWER (999,999) as the absolute maximum, not gradeSettings.answerMax
          const effectiveMaxAnswer = Math.min(gradeSettings.answerMax, CONSTANTS.MAX_ANSWER);

          // For grades 5+: Set minimum operand to avoid trivial problems like "434 × 1"
          const gradeNum = parseInt(grade) || (grade === 'k4' ? -1 : grade === 'k5' ? 0 : 1);
          let minMultOperandForGrade = 1;
          if (gradeNum >= 5) {
            // Grade 5: minimum 10, Grade 6: minimum 20, Grade 7+: minimum 30
            minMultOperandForGrade = gradeNum >= 7 ? 30 : (gradeNum >= 6 ? 20 : 10);
          }
          const effectiveOperandMin = Math.max(operandMin, minMultOperandForGrade);

          if (numberModeEnabled && numberModeExact) {
            const useN1 = (attemptOffset % 2 === 0);
            if (useN1) {
              n1 = Math.max(numberModeValue, effectiveOperandMin);
              // Ensure n1 * n2 <= 999,999, so n2 <= floor(999,999 / n1)
              const maxN2 = Math.min(operandMax, Math.floor(effectiveMaxAnswer / n1));
              n2 = getSeededRandomInt(effectiveOperandMin, maxN2);
            } else {
              n2 = Math.max(numberModeValue, effectiveOperandMin);
              // Ensure n1 * n2 <= 999,999, so n1 <= floor(999,999 / n2)
              const maxN1 = Math.min(operandMax, Math.floor(effectiveMaxAnswer / n2));
              n1 = getSeededRandomInt(effectiveOperandMin, maxN1);
            }
          } else if (numberModeEnabled) {
            const useN1 = (attemptOffset % 2 === 0);
            if (useN1) {
              // Select n1 such that we can still find a valid n2
              // Max n1 is limited by: n1 * min(operandMax) <= effectiveMaxAnswer, so n1 <= effectiveMaxAnswer / operandMin
              const maxN1ForProduct = Math.min(operandMax, Math.floor(Math.sqrt(effectiveMaxAnswer)));
              n1 = getRandomMultiple(effectiveOperandMin, maxN1ForProduct);
              // Ensure n1 * n2 <= 999,999
              const maxN2 = Math.min(operandMax, Math.floor(effectiveMaxAnswer / n1));
              n2 = getSeededRandomInt(effectiveOperandMin, maxN2);
            } else {
              const maxN2ForProduct = Math.min(operandMax, Math.floor(Math.sqrt(effectiveMaxAnswer)));
              n2 = getRandomMultiple(effectiveOperandMin, maxN2ForProduct);
              // Ensure n1 * n2 <= 999,999
              const maxN1 = Math.min(operandMax, Math.floor(effectiveMaxAnswer / n2));
              n1 = getSeededRandomInt(effectiveOperandMin, maxN1);
            }
          } else {
            // Find factor pairs within range - SMART selection to ensure product <= 999,999
            // For higher grades: Use intelligent strategies for variety and appropriate difficulty
            const strategy = attemptOffset % 4;

            if (strategy === 0) {
              // Strategy 1: Balanced factors (e.g., 300 × 300 = 90,000)
              const targetProduct = Math.min(effectiveMaxAnswer, operandMax * operandMax);
              const balancedFactor = Math.floor(Math.sqrt(targetProduct * 0.7)); // 70% of max for variety
              const variance = Math.floor(balancedFactor * 0.3);
              n1 = getSeededRandomInt(Math.max(effectiveOperandMin, balancedFactor - variance), Math.min(operandMax, balancedFactor + variance));
              const maxN2 = Math.min(operandMax, Math.floor(effectiveMaxAnswer / n1));
              n2 = getSeededRandomInt(Math.max(effectiveOperandMin, Math.floor(n1 * 0.7)), maxN2);
            } else if (strategy === 1) {
              // Strategy 2: Medium × Large (e.g., 150 × 500 = 75,000)
              const mediumFactor = Math.min(operandMax, Math.floor(Math.sqrt(effectiveMaxAnswer * 0.5)));
              n1 = getSeededRandomInt(Math.max(effectiveOperandMin, mediumFactor * 0.5), mediumFactor);
              const maxN2 = Math.min(operandMax, Math.floor(effectiveMaxAnswer / n1));
              n2 = getSeededRandomInt(Math.max(effectiveOperandMin, Math.floor(n1 * 1.5)), maxN2);
            } else if (strategy === 2) {
              // Strategy 3: Large × Medium (e.g., 500 × 150 = 75,000)
              const largeFactor = Math.min(operandMax, Math.floor(Math.sqrt(effectiveMaxAnswer * 1.5)));
              n1 = getSeededRandomInt(Math.max(effectiveOperandMin, largeFactor * 0.7), Math.min(operandMax, largeFactor));
              const maxN2 = Math.min(operandMax, Math.floor(effectiveMaxAnswer / n1));
              n2 = getSeededRandomInt(effectiveOperandMin, Math.min(maxN2, Math.floor(n1 * 0.5)));
            } else {
              // Strategy 4: Smaller balanced pairs (e.g., 200 × 400 = 80,000)
              const smallerFactor = Math.min(operandMax, Math.floor(Math.sqrt(effectiveMaxAnswer * 0.3)));
              n1 = getSeededRandomInt(effectiveOperandMin, smallerFactor);
              const maxN2 = Math.min(operandMax, Math.floor(effectiveMaxAnswer / n1));
              n2 = getSeededRandomInt(Math.max(effectiveOperandMin, Math.floor(n1 * 1.2)), maxN2);
            }

            // Ensure n1 and n2 are valid numbers
            if (isNaN(n1) || n1 < effectiveOperandMin) n1 = effectiveOperandMin;
            if (isNaN(n2) || n2 < effectiveOperandMin) n2 = effectiveOperandMin;
            n1 = Math.max(effectiveOperandMin, Math.min(operandMax, Math.floor(n1)));
            n2 = Math.max(effectiveOperandMin, Math.min(operandMax, Math.floor(n2)));
          }
        }

        // Ensure n1 and n2 are valid before calculation
        if (grade <= '3') {
          // For grades 1-3: minimum is 1 (multiplication tables)
          if (isNaN(n1) || !isFinite(n1)) n1 = operandMin;
          if (isNaN(n2) || !isFinite(n2)) n2 = operandMin;
          const minMultOperand = Math.max(1, operandMin);
          n1 = Math.max(minMultOperand, Math.min(operandMax, Math.floor(n1)));
          n2 = Math.max(minMultOperand, Math.min(operandMax, Math.floor(n2)));
        } else {
          // For grades 4+: use grade-appropriate minimums
          const gradeNum = parseInt(grade) || (grade === 'k4' ? -1 : grade === 'k5' ? 0 : 1);
          let minMultOperand = 1;
          if (gradeNum >= 5) {
            minMultOperand = gradeNum >= 7 ? 30 : (gradeNum >= 6 ? 20 : 10);
          } else if (gradeNum === 4) {
            minMultOperand = 10; // 4th grade: minimum 10 (examples show 36×27)
          }
          const effectiveMinMultOperand = Math.max(minMultOperand, operandMin);
          if (isNaN(n1) || !isFinite(n1) || n1 < effectiveMinMultOperand) n1 = effectiveMinMultOperand;
          if (isNaN(n2) || !isFinite(n2) || n2 < effectiveMinMultOperand) n2 = effectiveMinMultOperand;
          n1 = Math.max(effectiveMinMultOperand, Math.min(operandMax, Math.floor(n1)));
          n2 = Math.max(effectiveMinMultOperand, Math.min(operandMax, Math.floor(n2)));
        }

        // Ensure larger number is always first (n1 >= n2) for multiplication
        // BUT skip swap if exact number mode to preserve the exact number position
        if (!(numberModeEnabled && numberModeExact) && n1 < n2) {
          const temp = n1;
          n1 = n2;
          n2 = temp;
        }

        ans = n1 * n2;
        // CRITICAL: Final safety check - never allow answers to exceed 6 digits (999,999)
        // If somehow it does, adjust operands
        if (ans > CONSTANTS.MAX_ANSWER) {
          // Emergency adjustment: reduce larger operand proportionally
          if (n1 >= n2) {
            n1 = Math.floor(CONSTANTS.MAX_ANSWER / n2);
          } else {
            n2 = Math.floor(CONSTANTS.MAX_ANSWER / n1);
          }
          ans = n1 * n2;
        }
        ans = Math.min(ans, CONSTANTS.MAX_ANSWER);
        sym = '×';
      }
      else if (op === '/' || op === '÷') {
        // Division: n1 is dividend, n2 is divisor, ans is quotient
        // Ensure clean division (no remainders for these worksheets)
        // CRITICAL: Ensure quotient (ans) never exceeds 999,999
        // Use grade-specific division limits from gradeLevelSettings
        const effectiveMaxAnswer = Math.min(gradeSettings.answerMax, CONSTANTS.MAX_ANSWER);

        // Get division-specific limits from grade settings
        const divDividendMax = gradeSettings.divisionDividendMax || operandMax;
        const divDivisorMax = gradeSettings.divisionDivisorMax || Math.floor(Math.sqrt(operandMax));
        const minDivisor = 2;

        if (numberModeEnabled && numberModeExact) {
          n2 = Math.max(numberModeValue, minDivisor);
          n2 = Math.min(n2, divDivisorMax);
          const maxQuotient = Math.min(Math.floor(effectiveMaxAnswer), Math.floor(divDividendMax / n2));
          ans = getSeededRandomInt(1, Math.max(1, maxQuotient));
          n1 = ans * n2;
        } else if (numberModeEnabled) {
          n2 = getRandomMultiple(Math.max(minDivisor, operandMin), divDivisorMax);
          const maxQuotient = Math.min(Math.floor(effectiveMaxAnswer), Math.floor(divDividendMax / n2));
          ans = getSeededRandomInt(1, Math.max(1, maxQuotient));
          n1 = ans * n2;
        } else {
          // Simple division generation using grade-specific limits
          // Divisor from 2 to divDivisorMax, quotient calculated to keep dividend within divDividendMax
          n2 = getSeededRandomInt(minDivisor, divDivisorMax);

          // Calculate max quotient to keep dividend <= divDividendMax
          const maxQuotient = Math.floor(divDividendMax / n2);
          const limitQuotient = Math.min(Math.floor(effectiveMaxAnswer), maxQuotient);

          // Pick quotient (minimum 1)
          ans = getSeededRandomInt(1, Math.max(1, limitQuotient));
          n1 = ans * n2;

          // Ensure all values are valid
          if (isNaN(n2) || n2 < minDivisor) n2 = Math.max(minDivisor, operandMin);
          if (isNaN(ans) || ans < 1) ans = 1;
          n2 = Math.max(minDivisor, Math.min(operandMax, Math.floor(n2)));
          ans = Math.max(1, Math.min(Math.floor(effectiveMaxAnswer), Math.floor(ans)));
          n1 = ans * n2;

          // Final check: Ensure n1 is within operand range (it should be, but verify)
          if (n1 > operandMax) {
            const maxQuotientForRange = Math.floor(operandMax / n2);
            ans = Math.min(ans, maxQuotientForRange);
            n1 = ans * n2;
          }
        }

        // CRITICAL: Final safety check - never allow quotient to exceed 6 digits (999,999)
        ans = Math.min(ans, CONSTANTS.MAX_ANSWER);
        // Recalculate n1 to ensure consistency
        n1 = ans * n2;
        sym = '÷';
      }

      // Ensure all values are integers and valid numbers
      n1 = isNaN(n1) || !isFinite(n1) ? operandMin : Math.floor(n1);
      n2 = isNaN(n2) || !isFinite(n2) ? operandMin : Math.floor(n2);
      ans = isNaN(ans) || !isFinite(ans) ? 1 : Math.floor(ans);

      // Final validation: ensure operands are within grade range
      // For division: ensure divisor (n2) meets grade-appropriate minimum requirement
      const gradeNumFinal = parseInt(grade) || (grade === 'k4' ? -1 : grade === 'k5' ? 0 : 1);
      let minDivisorFinal = 2;
      if (gradeNumFinal >= 7) {
        minDivisorFinal = 30;
      } else if (gradeNumFinal >= 6) {
        minDivisorFinal = 20;
      } else if (gradeNumFinal >= 5) {
        minDivisorFinal = 10;
      } else if (gradeNumFinal >= 4) {
        minDivisorFinal = 10;
      } else {
        minDivisorFinal = 2; // Lower grades: minimum 2
      }
      n1 = Math.max(operandMin, Math.min(operandMax, n1));
      if (op === '/' || op === '÷') {
        n2 = Math.max(Math.max(minDivisorFinal, operandMin), Math.min(operandMax, n2));
      } else if (op === '*') {
        // For multiplication in grades 4+: ensure minimum operands
        let minMultFinal = 1;
        if (gradeNumFinal >= 5) {
          minMultFinal = gradeNumFinal >= 7 ? 30 : (gradeNumFinal >= 6 ? 20 : 10);
        } else if (gradeNumFinal === 4) {
          minMultFinal = 10;
        }
        n2 = Math.max(Math.max(minMultFinal, operandMin), Math.min(operandMax, n2));
        n1 = Math.max(Math.max(minMultFinal, operandMin), Math.min(operandMax, n1));
        // Ensure larger number is always first (n1 >= n2) for multiplication
        if (n1 < n2) {
          const temp = n1;
          n1 = n2;
          n2 = temp;
        }
      } else {
        n2 = Math.max(operandMin, Math.min(operandMax, n2));
      }

      // Recalculate to ensure consistency and mathematical correctness
      if (op === '+') {
        ans = n1 + n2;
      } else if (op === '-') {
        if (n1 <= n2) {
          // Fix invalid subtraction
          const temp = n1;
          n1 = Math.max(n2 + 1, operandMin + 1);
          n2 = Math.min(temp, n1 - 1);
          if (n2 < operandMin) n2 = operandMin;
        }
        ans = n1 - n2;
      } else if (op === '*') {
        // Ensure larger number is always first (n1 >= n2) for multiplication
        if (n1 < n2) {
          const temp = n1;
          n1 = n2;
          n2 = temp;
        }
        ans = n1 * n2;
        // If product exceeds limit, adjust operands proportionally
        if (ans > CONSTANTS.MAX_ANSWER) {
          if (n1 >= n2) {
            n1 = Math.floor(CONSTANTS.MAX_ANSWER / n2);
          } else {
            n2 = Math.floor(CONSTANTS.MAX_ANSWER / n1);
          }
          ans = n1 * n2;
        }
      } else if (op === '/' || op === '÷') {
        // Ensure clean division
        // CRITICAL: For grades 4+: ensure divisor (b) meets grade-appropriate minimum
        const gradeNumRecalc = parseInt(grade) || (grade === 'k4' ? -1 : grade === 'k5' ? 0 : 1);
        let minDivisorRecalc = 2;
        if (gradeNumRecalc >= 7) {
          minDivisorRecalc = 30;
        } else if (gradeNumRecalc >= 6) {
          minDivisorRecalc = 20;
        } else if (gradeNumRecalc >= 5) {
          minDivisorRecalc = 10;
        } else if (gradeNumRecalc >= 4) {
          minDivisorRecalc = 10;
        } else {
          minDivisorRecalc = 2;
        }
        if (n2 === 0 || n2 < minDivisorRecalc) n2 = Math.max(minDivisorRecalc, operandMin);
        ans = Math.floor(n1 / n2);
        n1 = ans * n2; // Recalculate n1 for clean division
      }

      // CRITICAL: Never allow answers to exceed 6 digits (999,999)
      ans = Math.min(ans, CONSTANTS.MAX_ANSWER);

      // Final safety check: ensure all values are still valid
      if (isNaN(n1) || !isFinite(n1)) n1 = operandMin;
      if (isNaN(n2) || !isFinite(n2)) n2 = operandMin;
      if (isNaN(ans) || !isFinite(ans)) ans = 1;

      return {
        n1: Math.floor(n1),
        n2: Math.floor(n2),
        ans: Math.floor(ans),
        sym,
        isValid: true
      };
    }

    function selectSmartAnswer(min, max, answerUsageMap = null) {
      if (!answerUsageMap || answerUsageMap.size === 0) {
        // No usage data, use pure random with slight bias toward middle
        const range = max - min + 1;
        if (range <= 10) {
          // Small range: pure random
          return getRandomInt(min, max);
        } else {
          // Larger range: slight bias toward middle 60% of range for better variety
          const mid = (min + max) / 2;
          const spread = Math.floor(range * 0.3);
          if (Math.random() < 0.7) {
            return getRandomInt(Math.max(min, mid - spread), Math.min(max, mid + spread));
          } else {
            return getRandomInt(min, max);
          }
        }
      }

      // Weighted selection: prefer answers used less frequently
      const candidates = [];
      const weights = [];

      for (let a = min; a <= max; a++) {
        const usage = answerUsageMap.get(a) || 0;
        // Higher weight = less used (inverse relationship)
        // Use exponential decay to strongly prefer less-used answers
        const weight = Math.pow(2, -usage * 2);
        candidates.push(a);
        weights.push(weight);
      }

      // Weighted random selection
      const totalWeight = weights.reduce((sum, w) => sum + w, 0);
      let random = Math.random() * totalWeight;
      for (let i = 0; i < candidates.length; i++) {
        random -= weights[i];
        if (random <= 0) {
          return candidates[i];
        }
      }
      return candidates[candidates.length - 1];
    }

    function generateProblemData(op, min, max, attemptOffset = 0, answerUsageMap = null, numberMode = null) {
      // ENHANCED: Smart math problem generator with professional AI-like intelligence
      // NEW SYSTEM: min/max refer to ANSWER range, not operand range
      // NUMBER MODE: If enabled, all problems must include the selected number or its multiples
      let n1, n2, ans, sym;
      let validated = null;
      let attempts = 0;
      const maxAttempts = 50;

      // Ensure min and max are valid (answer range)
      min = Math.max(1, Math.floor(min)); // Answers must be at least 1
      max = Math.max(min + 1, Math.floor(max)); // Max must be larger than min

      // Number Mode: Extract settings if provided
      const numberModeEnabled = numberMode && numberMode.enabled;
      const numberModeValue = numberMode ? numberMode.value : 1;
      const numberModeExact = numberMode && numberMode.exact; // Require exact number (not just multiples)

      // Helper function: Get nearest multiple of numberModeValue
      const getMultiple = (target) => {
        if (!numberModeEnabled) return target;
        return Math.floor(target / numberModeValue) * numberModeValue;
      };

      // Helper function: Check if a number is a multiple of numberModeValue
      const isMultiple = (num) => {
        if (!numberModeEnabled) return true;
        return num % numberModeValue === 0;
      };

      // Helper function: Get random multiple within range (inclusive)
      const getRandomMultiple = (minVal, maxVal) => {
        if (!numberModeEnabled) return getRandomInt(minVal, maxVal);
        if (minVal > maxVal) return numberModeValue; // Safety fallback
        const minMultiple = Math.ceil(minVal / numberModeValue) * numberModeValue;
        const maxMultiple = Math.floor(maxVal / numberModeValue) * numberModeValue;
        if (minMultiple > maxMultiple) {
          // If no multiples in range, return the closest valid multiple
          return minMultiple <= maxVal ? minMultiple : (maxMultiple >= minVal ? maxMultiple : numberModeValue);
        }
        const multipleCount = Math.floor((maxMultiple - minMultiple) / numberModeValue) + 1;
        const randomIndex = getRandomInt(0, Math.max(0, multipleCount - 1));
        return minMultiple + (randomIndex * numberModeValue);
      };

      // Helper function: Ensure answer respects Number Mode constraints
      const adjustAnswerForNumberMode = (desiredAns) => {
        if (!numberModeEnabled) return desiredAns;
        if (desiredAns % numberModeValue === 0) return desiredAns;
        // Find nearest valid multiple within range
        const lowerMultiple = Math.floor(desiredAns / numberModeValue) * numberModeValue;
        const upperMultiple = Math.ceil(desiredAns / numberModeValue) * numberModeValue;
        // Prefer the one closer to desired answer and within range
        if (lowerMultiple >= min && lowerMultiple <= max) {
          if (upperMultiple >= min && upperMultiple <= max) {
            // Both valid, choose closer
            return (desiredAns - lowerMultiple < upperMultiple - desiredAns) ? lowerMultiple : upperMultiple;
          }
          return lowerMultiple;
        }
        if (upperMultiple >= min && upperMultiple <= max) return upperMultiple;
        // If neither works, get a valid multiple from the range
        return getRandomMultiple(min, max);
      };

      // Calculate difficulty characteristics for smart operand selection
      const range = max - min;
      const difficultyLevel = range <= 20 ? 'easy' : range <= 100 ? 'medium' : range <= 500 ? 'hard' : 'expert';
      const midPoint = (min + max) / 2;

      do {
        if (op === '+') {
          // ENHANCED Addition: Smart answer selection + intelligent operand pairing
          ans = selectSmartAnswer(min, max, answerUsageMap);

          // NUMBER MODE: Ensure answer respects Number Mode constraints
          // removed adjustAnswerForNumberMode for arithmetic correctness (sum doesn't need to be a multiple)
          // CRITICAL: Never allow answers to exceed 6 digits (999,999)
          ans = Math.min(ans, CONSTANTS.MAX_ANSWER);

          // Intelligent operand selection strategies for variety:
          // Strategy 1: Small + Large (e.g., 2 + 8 = 10)
          // Strategy 2: Balanced (e.g., 5 + 5 = 10)
          // Strategy 3: Medium pairs (e.g., 4 + 6 = 10)
          const strategy = (attempts % 3); // Cycle through strategies

          if (ans >= 2) {
            if (numberModeEnabled) {
              if (numberModeExact) {
                // EXACT NUMBER MODE: One operand must be exactly numberModeValue
                // Educational Strategy: Vary which operand is exact for better learning variety
                // If answer is less than numberModeValue, we need special handling
                if (ans < numberModeValue) {
                  // Can't use exact number if answer is smaller - adjust answer
                  ans = numberModeValue;
                  n1 = numberModeValue;
                  n2 = 0; // Special case: numberModeValue + 0 = numberModeValue
                } else {
                  const useN1AsExact = (attempts % 2 === 0);

                  if (useN1AsExact) {
                    // n1 is exactly numberModeValue
                    n1 = numberModeValue;
                    n2 = ans - n1;
                    // Ensure n2 is valid (positive)
                    if (n2 < 1) {
                      // If answer is too small, put exact number in second position
                      n2 = numberModeValue;
                      n1 = ans - n2;
                      // If still invalid, adjust answer
                      if (n1 < 1) {
                        ans = numberModeValue * 2; // Minimum valid answer with exact number
                        n1 = numberModeValue;
                        n2 = numberModeValue;
                      }
                    }
                  } else {
                    // n2 is exactly numberModeValue
                    n2 = numberModeValue;
                    n1 = ans - n2;
                    // Ensure n1 is valid (positive)
                    if (n1 < 1) {
                      // Put exact number in first position instead
                      n1 = numberModeValue;
                      n2 = ans - n1;
                      // If still invalid, adjust answer
                      if (n2 < 1) {
                        ans = numberModeValue * 2;
                        n1 = numberModeValue;
                        n2 = numberModeValue;
                      }
                    }
                  }
                }
              } else {
                // NUMBER MODE (multiples allowed): At least one operand must be a multiple of numberModeValue
                // Strategy: Vary which operand is the multiple
                const useN1AsMultiple = (attempts % 2 === 0);

                if (useN1AsMultiple) {
                  // n1 is a multiple, n2 can be any number
                  const maxN1 = ans - 1;
                  n1 = getRandomMultiple(numberModeValue, maxN1);
                  n2 = ans - n1;
                  // Ensure n2 is also a multiple if possible, otherwise keep it as is
                  if (!isMultiple(n2) && ans >= numberModeValue * 2) {
                    // Try to make both multiples
                    const n1Multiples = [];
                    for (let m = numberModeValue; m <= ans - numberModeValue; m += numberModeValue) {
                      if (isMultiple(ans - m)) {
                        n1Multiples.push(m);
                      }
                    }
                    if (n1Multiples.length > 0) {
                      n1 = n1Multiples[getRandomInt(0, n1Multiples.length - 1)];
                      n2 = ans - n1;
                    }
                  }
                } else {
                  // n2 is a multiple, n1 can be any number
                  const maxN2 = ans - 1;
                  n2 = getRandomMultiple(numberModeValue, maxN2);
                  n1 = ans - n2;
                  // Ensure n1 is also a multiple if possible
                  if (!isMultiple(n1) && ans >= numberModeValue * 2) {
                    const n2Multiples = [];
                    for (let m = numberModeValue; m <= ans - numberModeValue; m += numberModeValue) {
                      if (isMultiple(ans - m)) {
                        n2Multiples.push(m);
                      }
                    }
                    if (n2Multiples.length > 0) {
                      n2 = n2Multiples[getRandomInt(0, n2Multiples.length - 1)];
                      n1 = ans - n2;
                    }
                  }
                }
              }
            } else {
              // Normal mode: original logic
              if (strategy === 0 && ans >= 4) {
                // Small + Large: one small, one large
                const small = Math.max(1, Math.floor(ans * 0.2));
                n1 = getRandomInt(1, Math.min(small + 2, ans - 1));
                n2 = ans - n1;
              } else if (strategy === 1 && ans % 2 === 0 && ans >= 4) {
                // Balanced: as equal as possible
                const half = Math.floor(ans / 2);
                const variation = Math.min(2, Math.floor(ans / 4));
                n1 = getRandomInt(Math.max(1, half - variation), Math.min(ans - 1, half + variation));
                n2 = ans - n1;
              } else {
                // Medium pairs: varied but not extreme
                const quarter = Math.floor(ans / 4);
                n1 = getRandomInt(Math.max(1, quarter), Math.min(ans - 1, ans - quarter));
                n2 = ans - n1;
              }
            }

            // Ensure both operands are valid integers
            n1 = Math.floor(n1);
            n2 = Math.floor(n2);
            if (n1 < 1) n1 = 1;
            if (n2 < 1) n2 = 1;
            if (n1 + n2 !== ans) {
              // Ensure correctness with integers
              n1 = Math.max(1, Math.min(Math.floor(n1), ans - 1));
              n2 = Math.floor(ans - n1);
            }
            // Final integer coercion
            n1 = Math.floor(n1);
            n2 = Math.floor(n2);
          } else if (ans === 1) {
            // Edge case: answer = 1
            if (numberModeEnabled) {
              if (numberModeExact && numberModeValue === 1) {
                // Special case: exact number mode with value 1
                n1 = 1;
                n2 = 0; // Allow 0 for this special case (1 + 0 = 1)
              } else if (numberModeExact && numberModeValue > 1) {
                // Answer too small for exact number mode - adjust answer
                ans = Math.max(min, numberModeValue);
                n1 = numberModeValue;
                n2 = ans - numberModeValue;
                if (n2 < 1) {
                  ans = numberModeValue * 2;
                  n1 = numberModeValue;
                  n2 = numberModeValue;
                }
              } else {
                // Multiples mode: adjust to use smallest valid multiple
                ans = Math.max(min, numberModeValue);
                n1 = numberModeValue;
                n2 = ans - numberModeValue;
                if (n2 < 1) {
                  ans = numberModeValue * 2;
                  n1 = numberModeValue;
                  n2 = numberModeValue;
                }
              }
            } else {
              // Normal mode: use standard fallback
              n1 = 1;
              n2 = 0;
            }
          } else {
            // Fallback: ensure Number Mode constraints if enabled
            if (numberModeEnabled && numberModeExact && ans >= numberModeValue) {
              n1 = numberModeValue;
              n2 = ans - n1;
              if (n2 < 1) {
                n2 = numberModeValue;
                n1 = ans - n2;
              }
            } else {
              n1 = 1;
              n2 = Math.max(0, ans - 1);
            }
          }

          sym = '+';
        }
        else if (op === '-') {
          // ENHANCED Subtraction: Smart answer selection + varied operand relationships
          ans = selectSmartAnswer(min, max, answerUsageMap);

          // NUMBER MODE: Ensure answer respects Number Mode constraints
          // removed adjustAnswerForNumberMode for arithmetic correctness (difference doesn't need to be a multiple)

          // Intelligent operand selection: vary the relationship between n1 and n2
          // Strategy 1: Close operands (e.g., 8 - 3 = 5, more challenging)
          // Strategy 2: Distant operands (e.g., 15 - 10 = 5, easier)
          // Strategy 3: Medium distance (e.g., 12 - 7 = 5, balanced)
          const strategy = (attempts % 3);

          // Calculate appropriate n2 range based on difficulty and answer
          let minN2, maxN2;

          if (difficultyLevel === 'easy') {
            // Easy: keep operands reasonable (1-30 range)
            minN2 = 1;
            maxN2 = Math.min(25, Math.max(5, ans * 3));
          } else if (difficultyLevel === 'medium') {
            // Medium: moderate range
            minN2 = 1;
            maxN2 = Math.min(50, Math.max(8, ans * 4));
          } else {
            // Hard/Expert: wider range
            minN2 = Math.max(1, Math.floor(ans / 2));
            maxN2 = Math.min(200, Math.max(10, ans * 5));
          }

          if (numberModeEnabled) {
            if (numberModeExact) {
              // EXACT NUMBER MODE: One operand must be exactly numberModeValue
              // Educational Strategy: Vary which operand is exact (n1 or n2) for variety
              const useN2AsExact = (attempts % 2 === 0);

              if (useN2AsExact) {
                // n2 (subtrahend) is exactly numberModeValue
                n2 = numberModeValue;
                n1 = n2 + ans; // minuend = subtrahend + difference
                // Verify n1 is valid and larger than n2
                if (n1 <= n2 || n1 < ans + 1) {
                  // Fallback: put exact number in minuend position
                  n1 = Math.max(ans + numberModeValue, numberModeValue * 2);
                  n2 = n1 - ans;
                  // Ensure n2 equals exact number
                  if (n2 !== numberModeValue) {
                    n2 = numberModeValue;
                    n1 = n2 + ans;
                  }
                }
              } else {
                // n1 (minuend) contains the exact number
                // Ensure n1 is at least ans + 1 (since n1 > n2)
                const minN1 = Math.max(ans + 1, numberModeValue);
                // Make n1 a multiple that includes or equals numberModeValue
                if (minN1 <= numberModeValue) {
                  // Use exact number as minuend if valid
                  n1 = numberModeValue;
                  n2 = n1 - ans;
                  if (n2 < 1) {
                    // Answer too large for exact number - use larger multiple
                    n1 = Math.ceil((ans + 1) / numberModeValue) * numberModeValue;
                    if (n1 === ans) n1 += numberModeValue; // Ensure n1 > ans
                    n2 = n1 - ans;
                  }
                } else {
                  // Find smallest valid multiple >= minN1
                  n1 = Math.ceil(minN1 / numberModeValue) * numberModeValue;
                  n2 = n1 - ans;
                  // Ensure n2 is valid
                  if (n2 < 1 || n1 <= ans) {
                    n1 = numberModeValue + ans;
                    n2 = numberModeValue;
                  }
                }
              }
            } else {
              // NUMBER MODE (multiples allowed): n1 and/or n2 should be multiples
              // Ensure n2 range contains multiples
              minN2 = Math.ceil(minN2 / numberModeValue) * numberModeValue;
              maxN2 = Math.floor(maxN2 / numberModeValue) * numberModeValue;
              if (minN2 > maxN2) minN2 = numberModeValue;

              if (strategy === 0) {
                const targetN2 = ans + Math.floor(ans * 0.3);
                n2 = getRandomMultiple(Math.max(minN2, targetN2 - numberModeValue * 2), Math.min(maxN2, targetN2 + numberModeValue * 2));
              } else if (strategy === 1) {
                n2 = getRandomMultiple(Math.max(minN2, ans * 2), maxN2);
              } else {
                const midN2 = ans + Math.floor(ans * 0.7);
                n2 = getRandomMultiple(Math.max(minN2, midN2 - numberModeValue * 2), Math.min(maxN2, midN2 + numberModeValue * 3));
              }
              n1 = n2 + ans; // n1 will be a multiple if both n2 and ans are multiples
            }
          } else {
            // Normal mode
            if (strategy === 0) {
              const targetN2 = ans + Math.floor(ans * 0.3);
              n2 = getRandomInt(Math.max(minN2, targetN2 - 2), Math.min(maxN2, targetN2 + 5));
            } else if (strategy === 1) {
              n2 = getRandomInt(Math.max(minN2, ans * 2), maxN2);
            } else {
              const midN2 = ans + Math.floor(ans * 0.7);
              n2 = getRandomInt(Math.max(minN2, midN2 - 5), Math.min(maxN2, midN2 + 10));
            }
            n1 = n2 + ans;
          }

          n2 = Math.max(minN2, Math.min(maxN2, n2));
          n1 = Math.floor(n2 + ans); // n1 = n2 + ans, guaranteed to be > n2
          // Ensure integers
          n1 = Math.floor(n1);
          n2 = Math.floor(n2);

          sym = '−';
        }
        else if (op === '*') {
          // Use constructive approach for Exact Number Mode to GUARANTEE the number exists
          if (numberModeEnabled && numberModeExact) {
            // EXACT NUMBER MODE: One factor MUST be numberModeValue
            // Fix one operand to be the exact number
            n1 = numberModeValue;

            // Calculate valid range for n2 based on Answer Range [min, max]
            // n1 * n2 >= min  =>  n2 >= min / n1
            // n1 * n2 <= max  =>  n2 <= max / n1
            let minN2 = Math.ceil(min / n1);
            let maxN2 = Math.floor(max / n1);

            // Ensure n2 is at least 1 (or 0 if allowed, but usually 1 for mult)
            minN2 = Math.max(1, minN2);

            // If range is invalid (e.g. min/max are too small for this number), adjust
            if (minN2 > maxN2) {
              // Must expand range to find A valid problem
              maxN2 = Math.max(minN2, maxN2);
              // Or if maxN2 < minN2, it implies min is high. 
              // If n1=10, min=100, max=105. minN2=10, maxN2=10. OK.
              // If n1=10, min=8, max=9. minN2=1, maxN2=0. Invalid.
              if (maxN2 < minN2) {
                maxN2 = minN2; // Force at least one option
              }
            }

            // Pick n2
            n2 = getRandomInt(minN2, maxN2);
            ans = n1 * n2;

            // Randomly swap n1 and n2 so the exact number isn't always first
            if (attempts % 2 === 1) {
              [n1, n2] = [n2, n1];
            }

            // Ensure integers
            n1 = Math.floor(n1);
            n2 = Math.floor(n2);

          } else {
            // Standard or Multiples Logic (Deconstructive: Pick Answer First)
            ans = selectSmartAnswer(min, max, answerUsageMap);

            // NUMBER MODE: Ensure answer respects Number Mode constraints (Multiples Mode)
            // For Multiples Mode, the answer is usually a multiple (e.g. 5, 10, 15)
            // Or one factor is a multiple? Check spec. 
            // Previous logic enforced answer is multiple for 'Multiples Mode' via adjustAnswerForNumberMode
            ans = adjustAnswerForNumberMode(ans);

            // Find all factor pairs
            const factors = [];
            for (let i = 1; i * i <= ans; i++) {
              if (ans % i === 0) {
                // CRITICAL: Ensure integer division
                const factor = Math.floor(ans / i);
                factors.push([i, factor]);
                if (i !== factor) {
                  factors.push([factor, i]);
                }
              }
            }

            if (factors.length > 0) {
              let candidateFactors = factors;
              if (numberModeEnabled) {
                // NUMBER MODE (multiples allowed): Filter factors to include numberModeValue or its multiples
                candidateFactors = factors.filter(([a, b]) =>
                  a % numberModeValue === 0 || b % numberModeValue === 0
                );
                // If no factors include the number mode, use all factors (shouldn't happen if ans is multiple)
                if (candidateFactors.length === 0) {
                  candidateFactors = factors;
                }
              }

              // Intelligent factor selection (Strategies 1-3)
              // Filter out trivial pairs (1 × n) when we have alternatives
              let preferredFactors = candidateFactors;
              if (candidateFactors.length > 2) {
                preferredFactors = candidateFactors.filter(([a, b]) => a !== 1 && b !== 1);
                if (preferredFactors.length === 0) {
                  preferredFactors = candidateFactors;
                }
              }

              // For larger answer ranges, prefer factor pairs close to square root
              if (range > 50 && preferredFactors.length > 1) {
                preferredFactors.sort(([a1, b1], [a2, b2]) => {
                  const ratio1 = Math.min(a1, b1) / Math.max(a1, b1);
                  const ratio2 = Math.min(a2, b2) / Math.max(a2, b2);
                  return ratio2 - ratio1; // Prefer pairs closer to 1:1 ratio
                });
              }

              // Select from preferred factors
              const selectIndex = Math.min(
                Math.floor(Math.random() * Math.min(preferredFactors.length, 3)),
                preferredFactors.length - 1
              );
              n1 = Math.floor(preferredFactors[selectIndex][0]);
              n2 = Math.floor(preferredFactors[selectIndex][1]);
            } else {
              // Fallback (shouldn't happen)
              n1 = numberModeEnabled ? numberModeValue : 1;
              n2 = ans / n1;
            }
          }

          sym = '×';


        }
        else { // Division
          // ENHANCED Division: Smart answer selection + intelligent divisor selection
          ans = selectSmartAnswer(min, max, answerUsageMap);

          // NUMBER MODE: Ensure answer respects Number Mode constraints
          // removed adjustAnswerForNumberMode for arithmetic correctness (quotient doesn't need to be a multiple)

          // Intelligent divisor selection based on difficulty and answer
          let minDivisor, maxDivisor;

          if (difficultyLevel === 'easy') {
            // Easy: common divisors (2-10) for familiarity
            minDivisor = 2;
            maxDivisor = Math.min(10, Math.max(2, Math.floor(ans / 2)));
          } else if (difficultyLevel === 'medium') {
            // Medium: moderate divisors (2-15)
            minDivisor = 2;
            maxDivisor = Math.min(15, Math.max(2, Math.floor(ans * 0.8)));
          } else {
            // Hard/Expert: wider range including larger divisors
            minDivisor = 2;
            maxDivisor = Math.min(25, Math.max(2, Math.floor(ans * 1.2)));
          }

          // NUMBER MODE: Adjust divisor constraints based on Number Mode settings
          if (numberModeEnabled) {
            if (numberModeExact) {
              // EXACT NUMBER MODE: Divisor must be exactly numberModeValue
              // Educational: Use exact number as divisor (e.g., 15 ÷ 5 = 3)
              // Ensure numberModeValue is valid for division (>= 2)
              n2 = Math.max(2, numberModeValue);

              // If numberModeValue is too large (larger than max possible answer?), it might be an issue?
              // But n2 is divisor, ans is quotient. 
              // n1 = ans * n2. 
              // Just ensure n1 doesn't overflow anything critical, but ans is clamped.

              n1 = ans * n2;
            } else {
              // NUMBER MODE (multiples allowed): Prefer divisors that are multiples of numberModeValue
              minDivisor = Math.max(minDivisor, numberModeValue);
              maxDivisor = Math.max(minDivisor, Math.min(maxDivisor, Math.floor(ans)));
              // Ensure divisor range contains multiples
              minDivisor = Math.ceil(minDivisor / numberModeValue) * numberModeValue;
              maxDivisor = Math.floor(maxDivisor / numberModeValue) * numberModeValue;
              if (minDivisor > maxDivisor || minDivisor < 2) {
                minDivisor = numberModeValue;
                maxDivisor = Math.max(minDivisor, Math.min(maxDivisor, Math.floor(ans / numberModeValue) * numberModeValue));
              }

              // Ensure maxDivisor doesn't exceed answer
              maxDivisor = Math.max(minDivisor, Math.min(maxDivisor, Math.floor(ans)));

              // Vary divisor selection strategy for variety
              const strategy = (attempts % 3);

              if (strategy === 0 && maxDivisor >= minDivisor) {
                // Prefer common multiples (numberModeValue, numberModeValue*2, etc.)
                const commonMultiples = [];
                for (let m = minDivisor; m <= maxDivisor; m += numberModeValue) {
                  if (m >= minDivisor && m <= maxDivisor && m <= ans) {
                    commonMultiples.push(m);
                  }
                }
                if (commonMultiples.length > 0) {
                  n2 = commonMultiples[getRandomInt(0, commonMultiples.length - 1)];
                } else {
                  n2 = getRandomMultiple(Math.max(2, minDivisor), maxDivisor);
                }
              } else {
                n2 = getRandomMultiple(Math.max(2, minDivisor), maxDivisor);
              }

              n1 = ans * n2; // dividend = quotient * divisor
              // Ensure n1 is also a multiple (it should be since ans and n2 are multiples)
              if (n1 % numberModeValue !== 0) {
                // Recalculate to ensure all values are multiples
                n1 = Math.floor(n1 / numberModeValue) * numberModeValue;
                ans = Math.floor(n1 / n2);
                // Recalculate n1 to ensure clean division
                n1 = ans * n2;
              }
            }
          } else {
            // Normal mode (no Number Mode)
            maxDivisor = Math.max(minDivisor, Math.min(maxDivisor, Math.floor(ans)));
            const strategy = (attempts % 3);

            if (strategy === 0) {
              // Prefer common divisors (2, 3, 4, 5, 6, 8, 10)
              const commonDivisors = [2, 3, 4, 5, 6, 8, 10].filter(d => d >= minDivisor && d <= maxDivisor && d <= ans);
              if (commonDivisors.length > 0) {
                n2 = commonDivisors[getRandomInt(0, commonDivisors.length - 1)];
              } else {
                n2 = getRandomInt(minDivisor, maxDivisor);
              }
            } else if (strategy === 1) {
              // Prefer medium divisors
              const midDivisor = Math.floor((minDivisor + maxDivisor) / 2);
              const spread = Math.floor((maxDivisor - minDivisor) / 3);
              n2 = getRandomInt(Math.max(minDivisor, midDivisor - spread), Math.min(maxDivisor, midDivisor + spread));
            } else {
              // Full random from range
              n2 = getRandomInt(minDivisor, maxDivisor);
            }

            n1 = ans * n2; // dividend = quotient * divisor
          }

          // Ensure integers and validity
          n1 = Math.floor(n1);
          n2 = Math.floor(n2);
          ans = Math.floor(ans);

          // Final validation: ensure clean division and n2 >= 2
          if (n2 < 2) n2 = 2;
          n1 = ans * n2; // Recalculate to ensure clean division

          sym = '÷';
        }

        // Validate the generated problem (include Number Mode settings for validation)
        validated = validateProblem({ n1, n2, ans, sym }, op, min, max, numberMode);
        attempts++;

      } while (!validated.isValid && attempts < maxAttempts);

      // Use validated values (they should be correct)
      // If validation failed after max attempts, return the last generated values
      // But ensure they're corrected first
      if (!validated || !validated.isValid) {
        // Final correction pass to ensure validity (answer must be in [min, max] range)
        // IMPORTANT: Respect Number Mode constraints in fallback
        if (op === '+') {
          ans = n1 + n2;
          if (ans < min || ans > max) {
            ans = numberModeEnabled ? adjustAnswerForNumberMode(getRandomInt(min, max)) : getRandomInt(min, max);
            if (ans >= 2) {
              if (numberModeEnabled) {
                if (numberModeExact) {
                  // Ensure exact number appears
                  if (ans >= numberModeValue) {
                    n1 = numberModeValue;
                    n2 = ans - n1;
                    if (n2 < 1) {
                      n2 = numberModeValue;
                      n1 = ans - n2;
                    }
                  } else {
                    ans = numberModeValue;
                    n1 = numberModeValue;
                    n2 = 0;
                  }
                } else {
                  // Use multiples
                  n1 = getRandomMultiple(1, ans - 1);
                  n2 = ans - n1;
                }
              } else {
                n1 = getRandomInt(1, ans - 1);
                n2 = ans - n1;
              }
            } else {
              n1 = 1;
              n2 = ans - 1;
            }
          }
        } else if (op === '-') {
          ans = n1 - n2;
          if (ans < min || ans > max || n1 <= n2) {
            ans = numberModeEnabled ? adjustAnswerForNumberMode(getRandomInt(min, max)) : getRandomInt(min, max);
            const maxN2 = Math.min(50, Math.max(10, ans * 2));
            if (numberModeEnabled && numberModeExact) {
              n2 = numberModeValue;
              n1 = n2 + ans;
            } else if (numberModeEnabled) {
              n2 = getRandomMultiple(1, maxN2);
              n1 = n2 + ans;
            } else {
              n2 = getRandomInt(1, maxN2);
              n1 = n2 + ans;
            }
          }
        } else if (op === '*') {
          ans = n1 * n2;
          if (ans < min || ans > max) {
            ans = numberModeEnabled ? adjustAnswerForNumberMode(getRandomInt(min, max)) : getRandomInt(min, max);
            const factors = [];
            for (let i = 1; i * i <= ans; i++) {
              if (ans % i === 0) {
                const factor = Math.floor(ans / i);
                factors.push([i, factor]);
                if (i !== factor) {
                  factors.push([factor, i]);
                }
              }
            }
            if (factors.length > 0) {
              let validFactors = factors;
              if (numberModeEnabled) {
                if (numberModeExact) {
                  validFactors = factors.filter(([a, b]) => a === numberModeValue || b === numberModeValue);
                  if (validFactors.length === 0 && ans % numberModeValue === 0) {
                    const otherFactor = Math.floor(ans / numberModeValue);
                    validFactors = [[numberModeValue, otherFactor], [otherFactor, numberModeValue]];
                  }
                  if (validFactors.length === 0) validFactors = factors;
                } else {
                  validFactors = factors.filter(([a, b]) => a % numberModeValue === 0 || b % numberModeValue === 0);
                  if (validFactors.length === 0) validFactors = factors;
                }
              }
              const randomPairIndex = getRandomInt(0, validFactors.length - 1);
              n1 = Math.floor(validFactors[randomPairIndex][0]);
              n2 = Math.floor(validFactors[randomPairIndex][1]);
            } else {
              n1 = numberModeEnabled && numberModeExact ? numberModeValue : 1;
              n2 = ans / n1;
            }
          }
        } else { // Division
          if (n2 === 0 || n2 < 2) n2 = 2;
          ans = Math.floor(n1 / n2);
          n1 = ans * n2;
          if (ans < min || ans > max || n1 % n2 !== 0) {
            ans = numberModeEnabled ? adjustAnswerForNumberMode(getRandomInt(min, max)) : getRandomInt(min, max);
            const maxDivisor = Math.min(20, Math.max(2, Math.floor(ans)));
            if (numberModeEnabled && numberModeExact) {
              n2 = numberModeValue >= 2 && numberModeValue <= maxDivisor ? numberModeValue : 2;
              n1 = ans * n2;
            } else if (numberModeEnabled) {
              n2 = getRandomMultiple(Math.max(2, numberModeValue), maxDivisor);
              n1 = ans * n2;
            } else {
              n2 = getRandomInt(2, maxDivisor);
              n1 = ans * n2;
            }
          }
        }
        // CRITICAL: Ensure all values are integers before returning
        return {
          n1: Math.floor(n1),
          n2: Math.floor(n2),
          ans: Math.floor(ans),
          sym
        };
      }

      // Return validated and corrected values - ensure all are integers
      return {
        n1: Math.floor(validated.n1),
        n2: Math.floor(validated.n2),
        ans: Math.floor(validated.ans),
        sym: validated.sym
      };
    }

    /**
     * Calculates optimal spacing for worksheet problems based on page dimensions
     * Adjusts for multi-step equations which require wider boxes
     * @param {number} rows - Number of rows
     * @param {number} cols - Number of columns
     * @param {number} complexity - Equation complexity (1, 2, or 3 steps)
     */
    /**
     * Calculates optimal spacing for worksheet problems based on page dimensions
     * @param {number} rows - Number of rows
     * @param {number} cols - Number of columns
     */
    function calculateOptimalPrintSpacing(rows, cols) {
      const pageWidth = 8.5, pageHeight = 11, margin = 0.25, headerHeight = 0.64;
      const availableWidth = pageWidth - (margin * 2), gridAvailableHeight = pageHeight - (margin * 2) - headerHeight;
      const minGap = 0.08, optimalGapTarget = 0.12;

      // Minimum width for single-step equations
      const minProblemWidth = 0.6;

      let problemWidth, problemHeight, finalGap;
      if (cols > 1 && rows > 1) {
        const widthGap = Math.max(minGap, Math.min(optimalGapTarget, (availableWidth - (cols * 0.65)) / (cols - 1)));
        const heightGap = Math.max(minGap, Math.min(optimalGapTarget, (gridAvailableHeight - (rows * 0.6)) / (rows - 1)));
        finalGap = Math.min(widthGap, heightGap);
        problemWidth = (availableWidth - (finalGap * (cols - 1))) / cols;
        problemHeight = (gridAvailableHeight - (finalGap * (rows - 1))) / rows;

        // Ensure minimum width
        if (problemWidth < minProblemWidth) {
          problemWidth = minProblemWidth;
          finalGap = (availableWidth - (cols * problemWidth)) / (cols - 1);
        }
        if (problemHeight < 0.6) {
          problemHeight = 0.6;
          finalGap = Math.min(finalGap, (gridAvailableHeight - (rows * problemHeight)) / (rows - 1));
          problemWidth = (availableWidth - (finalGap * (cols - 1))) / cols;
          // Re-check minimum width after adjustment
          if (problemWidth < minProblemWidth) {
            problemWidth = minProblemWidth;
            finalGap = (availableWidth - (cols * problemWidth)) / (cols - 1);
          }
        }
      } else if (cols === 1) {
        problemWidth = Math.min(availableWidth, Math.max(1.5, minProblemWidth));
        finalGap = minGap;
        problemHeight = rows > 1 ? (gridAvailableHeight - (finalGap * (rows - 1))) / rows : Math.min(gridAvailableHeight, 2.0);
      } else {
        problemHeight = Math.min(gridAvailableHeight, 2.0);
        finalGap = minGap;
        problemWidth = Math.max(minProblemWidth, (availableWidth - (finalGap * (cols - 1))) / cols);
      }

      document.documentElement.style.setProperty('--print-grid-height', `${Math.min((problemHeight * rows) + (finalGap * (rows - 1)), gridAvailableHeight)}in`);
      document.documentElement.style.setProperty('--print-gap', `${finalGap}in`);
      document.documentElement.style.setProperty('--print-problem-width', `${problemWidth}in`);
      document.documentElement.style.setProperty('--print-problem-height', `${problemHeight}in`);
    }

    // Generate unique worksheet number: WS-MMDDYYYY-XXXX
    function generateWorksheetNumber() {
      const now = new Date();
      // Format: MMDDYYYY (Month Month Day Day Year Year Year Year)
      const month = String(now.getMonth() + 1).padStart(2, '0'); // Month is 0-indexed, add 1
      const day = String(now.getDate()).padStart(2, '0');
      const year = String(now.getFullYear());
      const datePart = `${month}${day}${year}`;

      // Generate 4 random digits (0000-9999) that will likely never be repeated
      // Use combination of random and timestamp for better uniqueness
      const randomDigits = Math.floor(Math.random() * 10000).toString().padStart(4, '0');
      const timestampDigits = (Date.now() % 10000).toString().padStart(4, '0');
      // Combine for better uniqueness
      const uniqueCode = String((parseInt(randomDigits) + parseInt(timestampDigits)) % 10000).padStart(4, '0');

      return `WS-${datePart}-${uniqueCode}`;
    }

    function openWorksheetInNewTab() {
      // CRITICAL: Final validation - ensure operations are set
      syncOperationsFromUI();

      // CRITICAL: Final sync of difficulty settings before generating worksheet
      // For grade-level mode, we don't set config.min/max (uses operand ranges)
      // For custom difficulty mode, we set config.min/max (uses answer ranges)
      if (difficultyType === 'grade-level' && selectedGradeLevel) {
        // Grade-level mode: Don't set config.min/max (uses operand ranges in generation)
        if (!config.min || !config.max) {
          const gradeSettings = gradeLevelSettings[selectedGradeLevel];
          if (gradeSettings) {
            config.min = 1; // Placeholder, not used in grade-level generation
            config.max = gradeSettings.answerMax; // Used for validation only
          }
        }
      } else {
        const currentDifficultySettings = difficultySettings[currentDifficulty];
        if (currentDifficultySettings) {
          config.min = currentDifficultySettings.min;
          config.max = currentDifficultySettings.max;
        }
      }

      if (selectedOperations.length === 0) {
        console.error('No operations available for worksheet generation');
        alert('Error: No math operations selected. Please go back to Step 1 and select at least one operation.');
        return;
      }

      const total = config.rows * config.cols;
      const problems = generateProblemsList(config, total);
      const worksheetNumber = generateWorksheetNumber(); // Generate unique worksheet number
      const rootStyles = getComputedStyle(document.documentElement);
      const printGap = rootStyles.getPropertyValue('--print-gap').trim() || '0.1in';
      const printProblemWidth = rootStyles.getPropertyValue('--print-problem-width').trim() || '1.2in';
      const printProblemHeight = rootStyles.getPropertyValue('--print-problem-height').trim() || '0.8in';
      const printGridHeight = rootStyles.getPropertyValue('--print-grid-height').trim() || 'auto';

      // We will embed a script in the generated HTML to handle toggling answers and downloading
      let worksheetHTML = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Math Worksheet</title>
  <style>
    /* Print Styles - Shows checked answers with colors */
    @media print {
      @page { size: 8.5in 11in; margin: 0.2in; -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important; }
      * { -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important; }
      .control-bar, .no-print { display: none !important; }
      
      /* Show correct answers (red answer keys) in print */
      .correct-answer-display { 
        display: block !important; 
        position: absolute !important;
        left: 15px !important;
        bottom: 15px !important;
        color: #e74c3c !important;
        font-weight: bold !important;
        font-size: 18px !important;
        background: white !important;
        padding: 2px 8px !important;
        border-radius: 6px !important;
        border: 2px solid #e74c3c !important;
        box-shadow: 0 2px 5px rgba(231,76,60,0.2) !important;
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
      }
      
      /* Show colored boxes for correct/incorrect answers */
      .problem.correct { 
        border: 2px solid #2ecc71 !important; 
        background-color: #f0fff4 !important;
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
      }
      .problem.incorrect { 
        border: 2px solid #e74c3c !important; 
        background-color: #fff5f5 !important;
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
      }
      
      /* Show user input values in print with proper styling */
      .problem input[type="number"] {
        color: #2c3e50 !important;
        background: white !important;
        border: 2px solid #fdc9ec !important;
        border-radius: 4px !important;
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
        -webkit-appearance: none !important;
        appearance: none !important;
        /* Ensure values are visible */
        opacity: 1 !important;
        visibility: visible !important;
      }
      
      /* Hide placeholder but show actual values */
      input::placeholder { 
        color: transparent !important; 
        opacity: 0 !important;
        visibility: hidden !important;
      }
      /* Note: input[placeholder]:before removed - pseudo-elements don't work on input elements */
      
      /* Ensure filled inputs show their values */
      input[type="number"]:not(:placeholder-shown) {
        color: #2c3e50 !important;
      }
      
      /* Position Grade Box at top right for printing */
      .score-modal.show {
        display: block !important;
        position: fixed !important;
        top: 0.1in !important;
        right: 0.1in !important;
        left: auto !important;
        transform: none !important;
        background: white !important;
        padding: 10px 20px !important;
        border-radius: 10px !important;
        border: 3px solid #2ecc71 !important;
        box-shadow: 0 4px 10px rgba(0,0,0,0.2) !important;
        z-index: 1000 !important;
        text-align: center !important;
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
      }
      .score-modal.show.grade-a { border-color: #2ecc71 !important; }
      .score-modal.show.grade-b { border-color: #3498db !important; }
      .score-modal.show.grade-c { border-color: #f1c40f !important; }
      .score-modal.show.grade-d { border-color: #e67e22 !important; }
      .score-modal.show.grade-f { border-color: #e74c3c !important; }
      .score-modal.show h2 {
        margin: 0 !important;
        color: #2ecc71 !important;
        font-size: 18px !important;
      }
      .score-modal.show.grade-a h2 { color: #2ecc71 !important; }
      .score-modal.show.grade-b h2 { color: #3498db !important; }
      .score-modal.show.grade-c h2 { color: #f1c40f !important; }
      .score-modal.show.grade-d h2 { color: #e67e22 !important; }
      .score-modal.show.grade-f h2 { color: #e74c3c !important; }
      .grade-letter.grade-a { color: #2ecc71 !important; }
      .grade-letter.grade-b { color: #3498db !important; }
      .grade-letter.grade-c { color: #f1c40f !important; }
      .grade-letter.grade-d { color: #e67e22 !important; }
      .grade-letter.grade-f { color: #e74c3c !important; }
      .score-modal.show p {
        margin: 5px 0 0 0 !important;
        font-size: 14px !important;
      }
      html, body { margin: 0 !important; padding: 0 !important; width: 8.5in !important; height: 100% !important; overflow: hidden !important; background: white !important; color: black !important; }
      #worksheet-screen { width: 8.0in !important; height: 10.5in !important; padding: 0 !important; box-shadow: none !important; }
      .header { margin: 0 0 0.1in 0 !important; }
      .header h1 { font-size: 20px !important; margin: 0 0 0.06in 0 !important; line-height: 1.1 !important; }
      .header p { font-size: 12px !important; margin: 0.03in 0 0 0 !important; gap: 0.2in !important; }
      .header input { border-bottom-width: 1.5px !important; font-size: 12px !important; width: 1.8in !important; }
      
      .problems-grid {
        display: grid !important;
        grid-template-columns: repeat(${config.cols}, ${printProblemWidth}) !important;
        gap: ${printGap} !important;
        height: ${printGridHeight} !important;
        align-content: start !important;
        justify-content: center !important;
      }
      .problem {
        box-shadow: none !important; 
        border: 1px solid #d0d0d0 !important; 
        border-radius: 6px !important;
        padding: 0.06in !important; 
        height: ${printProblemHeight} !important; 
        width: 100% !important;
        display: flex !important; 
        flex-direction: column !important; 
        justify-content: space-between !important;
        position: relative !important;
        background-color: white !important;
      }
      .math-expression { font-size: 20px !important; line-height: 1.1 !important; margin-bottom: 0.05in !important; white-space: pre !important; text-align: right !important; }
      .problem.horizontal .math-expression { white-space: normal !important; text-align: center !important; word-wrap: break-word !important; overflow-wrap: break-word !important; }
      .operator-line { border-bottom-width: 2px !important; margin-top: 0.02in !important; }
      .problem input[type="number"] {
        width: 100% !important; min-width: 0.9in !important; height: 0.4in !important; font-size: 12px !important;
        padding: 0.02in 0.04in !important; margin-top: auto !important; border: 2px solid #fdc9ec !important;
        background: white !important; border-radius: 4px !important; box-sizing: border-box !important;
      }
      .problem::before { content: attr(data-number) !important; position: absolute !important; top: -0.03in !important; left: -0.03in !important; color: #666666 !important; font-size: 9px !important; font-weight: 600 !important; background-color: #f0f0f0 !important; padding: 2px 6px !important; border-radius: 4px !important; line-height: 1 !important; z-index: 2 !important; box-shadow: 0 1px 2px rgba(0,0,0,0.1) !important; }
      
      /* Avoid breaks */
      .header, .problems-grid, .problem { page-break-inside: avoid !important; }
    }

    /* Screen Styles */
    * { box-sizing: border-box; }
    body { font-family: 'Comic Sans MS', cursive, sans-serif; color: #3498db; background: white; margin: 0; padding: 20px; min-height: 100vh; display: flex; flex-direction: column; align-items: center; }
    
    /* Control Bar */
    .control-bar {
      position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
      background: white; padding: 10px 20px; border-radius: 50px;
      box-shadow: 0 5px 20px rgba(0,0,0,0.2); z-index: 1000;
      display: flex; gap: 15px; border: 2px solid #3498db;
    }
    .btn {
      padding: 10px 20px; border: none; border-radius: 30px; cursor: pointer;
      font-family: inherit; font-weight: bold; font-size: 16px; color: white;
      transition: all 0.2s; box-shadow: 0 4px 0 rgba(0,0,0,0.1);
    }
    .btn:active { transform: translateY(2px); box-shadow: none; }
    .btn-check { background: #2ecc71; box-shadow: 0 4px 0 #27ae60; }
    .btn-check.toggled { background: #e67e22; box-shadow: 0 4px 0 #d35400; }
    .btn-print { background: #9b59b6; box-shadow: 0 4px 0 #8e44ad; }
    .btn-download { background: #3498db; box-shadow: 0 4px 0 #2980b9; }

    /* Score Modal */
    .score-modal {
      position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
      background: white; padding: 15px 30px; border-radius: 15px;
      border: 3px solid #2ecc71; box-shadow: 0 10px 30px rgba(0,0,0,0.15);
      z-index: 1000; text-align: center; display: none;
    }
    .score-modal.show { display: block; animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
    @keyframes popIn { from { transform: translate(-50%, -20px); opacity: 0; } to { transform: translate(-50%, 0); opacity: 1; } }
    
    /* Grade Color Coding */
    .grade-letter {
      font-weight: bold;
      display: inline-block;
    }
    .grade-letter.grade-a { color: #2ecc71; } /* Green for A (90-100%) */
    .grade-letter.grade-b { color: #3498db; } /* Blue for B (80-89%) */
    .grade-letter.grade-c { color: #f1c40f; } /* Yellow for C (70-79%) */
    .grade-letter.grade-d { color: #e67e22; } /* Orange for D (60-69%) */
    .grade-letter.grade-f { color: #e74c3c; } /* Red for F (Below 60%) */
    
    /* Score Modal Border and Text Colors by Grade */
    .score-modal.grade-a { border-color: #2ecc71; }
    .score-modal.grade-b { border-color: #3498db; }
    .score-modal.grade-c { border-color: #f1c40f; }
    .score-modal.grade-d { border-color: #e67e22; }
    .score-modal.grade-f { border-color: #e74c3c; }
    
    .score-modal.grade-a h2 { color: #2ecc71; }
    .score-modal.grade-b h2 { color: #3498db; }
    .score-modal.grade-c h2 { color: #f1c40f; }
    .score-modal.grade-d h2 { color: #e67e22; }
    .score-modal.grade-f h2 { color: #e74c3c; }

    #worksheet-screen {
      display: flex; width: 100%; max-width: 8.5in; flex-direction: column;
      align-items: center; padding: 20px; background: white; margin-bottom: 80px;
      box-shadow: none; border-radius: 0; border: none; min-height: 11in;
    }

    .header { text-align: center; margin-bottom: 25px; width: 100%; }
    .header h1 { font-size: 28px; margin: 0 0 15px 0; color: #2ecc71; }
    .header p { display: flex; flex-wrap: wrap; justify-content: center; gap: 20px; align-items: center; margin: 8px 0; }
    .header input { font-family: inherit; font-size: 18px; border: none; border-bottom: 2px solid #3498db; outline: none; width: 200px; padding: 5px; text-align: center; }

    .problems-grid {
      display: grid; gap: 20px; margin: 25px auto; width: 100%; justify-content: center;
      grid-template-columns: repeat(${config.cols}, 1fr);
    }

    .problem {
      border: 2px solid #eef2f7; padding: 25px 15px 15px 15px; text-align: right;
      background-color: white; border-radius: 12px; position: relative;
      display: flex; flex-direction: column; align-items: flex-end; min-height: 150px;
      transition: all 0.3s ease;
    }

    /* Grading Styles */
    .problem.correct { border: 2px solid #2ecc71; background-color: #f0fff4; }
    .problem.incorrect { border: 2px solid #e74c3c; background-color: #fff5f5; }

    .correct-answer-display {
      position: absolute; left: 15px; bottom: 15px;
      color: #e74c3c; font-weight: bold; font-size: 20px;
      background: white; padding: 2px 8px; border-radius: 6px;
      border: 2px solid #e74c3c; box-shadow: 0 2px 5px rgba(231,76,60,0.2);
    }

    .math-expression { font-size: 28px; color: #2c3e50; line-height: 1.3; margin-bottom: 15px; white-space: pre; text-align: right; }
    .problem.horizontal .math-expression { white-space: normal !important; text-align: center !important; word-wrap: break-word; overflow-wrap: break-word; }
    .operator-line { border-bottom: 3px solid #3498db; width: 100%; display: block; margin-top: 4px; }
    .problem input[type="number"] {
      width: 100%; min-width: 90px; height: 48px; font-size: 24px; text-align: right;
      border: 2px solid #fdc9ec; border-radius: 8px; font-family: inherit; padding: 0 8px;
      box-sizing: border-box;
    }
    .problem input::-webkit-outer-spin-button, .problem input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    .problem::before { content: attr(data-number); position: absolute; top: -8px; left: -8px; color: #666666; font-size: 11px; font-weight: 600; pointer-events: none; background-color: #f0f0f0; padding: 4px 8px; border-radius: 6px; line-height: 1; z-index: 2; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
    
    /* Unique Worksheet Number */
    .worksheet-number {
      position: fixed;
      top: 10px;
      left: 10px;
      color: #888888;
      font-size: 12px;
      font-weight: 500;
      font-family: 'Arial', sans-serif;
      z-index: 1000;
      background: transparent;
      pointer-events: none;
      -webkit-print-color-adjust: exact;
      print-color-adjust: exact;
    }
    
    @media print {
      .worksheet-number {
        position: fixed;
        top: 0.1in;
        left: 0.1in;
        color: #888888;
        font-size: 10px;
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
      }
    }
  </style>
</head>
<body>
  <div class="worksheet-number">${worksheetNumber}</div>
  <div id="scoreModal" class="score-modal">
    <h2 style="margin:0;">Grade: <span id="gradeLetter" class="grade-letter">A</span></h2>
    <p style="margin:5px 0 0 0; font-size: 18px;">Score: <span id="scoreNum">0</span>/<span id="totalNum">0</span></p>
  </div>

  <div id="worksheet-screen">
    <div class="header">
      <h1 id="worksheet-title">Math Worksheet</h1>
      <p>
        <label>Name:</label><input type="text" placeholder="Enter name">
        <label>Date:</label><input type="text" placeholder="Today's Date">
      </p>
    </div>

    <div class="problems-grid" id="problems">`;

      // Embed Answer Data in data-answer attribute
      problems.forEach((p, i) => {
        const formatted = formatProblemForHTML(p, i);
        worksheetHTML += `
      <div class="${formatted.problemClass}" data-number="#${i + 1}" data-answer="${formatted.answer}">
        <div class="math-expression">${formatted.expressionHTML}</div>
        <input type="number" class="ans-input" aria-label="Answer for problem ${i + 1}" placeholder="?">
      </div>`;
      });

      worksheetHTML += `
    </div>
  </div>

  <div class="control-bar">
    <button class="btn btn-print" onclick="printWorksheet()">🖨️ Print</button>
    <button class="btn btn-check" id="checkBtn" onclick="toggleAnswers()">✅ Check Answers</button>
    <button class="btn btn-download" onclick="downloadWorksheet()">💾 Save Worksheet</button>
  </div>

  <script>
    let isChecked = false;

    function toggleAnswers() {
      const btn = document.getElementById('checkBtn');
      const problems = document.querySelectorAll('.problem');
      const scoreModal = document.getElementById('scoreModal');
      let score = 0;
      let total = problems.length;

      isChecked = !isChecked;

      if (isChecked) {
        // Turn ON Grading
        btn.textContent = "🙈 Hide Answers";
        btn.classList.add('toggled');
        
        problems.forEach(p => {
          const input = p.querySelector('input');
          // Get correct answer and ensure it's a valid number
          const correctAnsRaw = p.dataset.answer;
          const correctAns = parseFloat(correctAnsRaw);
          
          // Handle user answer - check for empty or invalid input
          let userAns = null;
          if (input.value && input.value.trim() !== "") {
            const parsed = parseFloat(input.value);
            if (!isNaN(parsed) && isFinite(parsed)) {
              userAns = Math.floor(parsed); // Ensure integer for exact comparison
            }
          }

          // Reset previous states
          p.classList.remove('correct', 'incorrect');
          const oldAns = p.querySelector('.correct-answer-display');
          if (oldAns) oldAns.remove();

          // Compare answers - ensure both are valid numbers
          if (!isNaN(correctAns) && isFinite(correctAns) && userAns !== null && userAns === correctAns) {
            p.classList.add('correct');
            score++;
          } else {
            p.classList.add('incorrect');
            // Create Red Answer on Left - show correct answer
            if (!isNaN(correctAns) && isFinite(correctAns)) {
            const ansDisplay = document.createElement('div');
            ansDisplay.className = 'correct-answer-display';
              ansDisplay.textContent = Math.floor(correctAns).toLocaleString('en-US'); // Format with commas
            p.appendChild(ansDisplay);
            }
          }
        });

        // Calculate Grade (Standard Scale: A=90-100%, B=80-89%, C=70-79%, D=60-69%, F=Below 60%)
        const pct = (score / total) * 100;
        let grade = 'F';
        if (pct >= 90 && pct <= 100) grade = 'A';
        else if (pct >= 80 && pct < 90) grade = 'B';
        else if (pct >= 70 && pct < 80) grade = 'C';
        else if (pct >= 60 && pct < 70) grade = 'D';
        else grade = 'F'; // Below 60%

        const gradeLetterEl = document.getElementById('gradeLetter');
        gradeLetterEl.textContent = grade;
        
        // Apply color coding based on grade
        gradeLetterEl.className = 'grade-letter grade-' + grade.toLowerCase();
        
        // Update score modal border and text color based on grade
        const scoreModal = document.getElementById('scoreModal');
        scoreModal.className = 'score-modal show grade-' + grade.toLowerCase();
        document.getElementById('scoreNum').textContent = score;
        document.getElementById('totalNum').textContent = total;

      } else {
        // Turn OFF Grading (Revert)
        btn.textContent = "✅ Check Answers";
        btn.classList.remove('toggled');
        scoreModal.classList.remove('show');

        problems.forEach(p => {
          p.classList.remove('correct', 'incorrect');
          const oldAns = p.querySelector('.correct-answer-display');
          if (oldAns) oldAns.remove();
        });
      }
    }

    function printWorksheet() {
      // Open browser's print dialog
      window.print();
    }

    function downloadWorksheet() {
      // Get current HTML
      // We want to save the clean state, so if it's checked, toggle it off first
      if (isChecked) toggleAnswers();

      // Get worksheet number from the top-left corner (WS-MMDDYYYY-XXXX format)
      const worksheetNumberElement = document.querySelector('.worksheet-number');
      let filename = 'Math_Worksheet.html'; // Default fallback
      
      if (worksheetNumberElement && worksheetNumberElement.textContent) {
        // Extract the worksheet number (e.g., "WS-01012024-1234")
        const worksheetNumber = worksheetNumberElement.textContent.trim();
        if (worksheetNumber && worksheetNumber.length > 0) {
          // Use the worksheet number as the filename
          filename = worksheetNumber + '.html';
        }
      }

      const htmlContent = "<!DOCTYPE html>\\n<html lang='en'>" + document.documentElement.innerHTML + "</html>";
      const blob = new Blob([htmlContent], { type: 'text/html' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = filename; // Use worksheet number as default filename
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      
      // Clean up the object URL after a short delay
      setTimeout(() => {
        URL.revokeObjectURL(a.href);
      }, 100);
    }

    // Placeholder handling for print
    window.addEventListener('beforeprint', function() {
      document.querySelectorAll('input[placeholder]').forEach(input => {
        input.setAttribute('data-ph', input.getAttribute('placeholder'));
        input.removeAttribute('placeholder');
      });
    });
    window.addEventListener('afterprint', function() {
      document.querySelectorAll('input[data-ph]').forEach(input => {
        input.setAttribute('placeholder', input.getAttribute('data-ph'));
      });
    });
  <\/script>
</body>
</html>`;

      const newWindow = window.open('', '_blank');
      if (!newWindow) { alert('Please allow popups to open the worksheet.'); return; }
      newWindow.document.open();
      newWindow.document.write(worksheetHTML);
      newWindow.document.close();
      newWindow.focus();
    }

    // Utilities
    function getRandomInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
    function shuffleArray(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }
  </script>
</body>

</html>